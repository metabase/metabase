(ns metabase.db.custom-migrations.metrics-v2
  (:require
   [cheshire.core :as json]
   [metabase.util :as u]
   [metabase.util.log :as log]
   [toucan2.core :as t2]))

(set! *warn-on-reflection* true)

(defn- get-metric-migration-collection
  "Get the collection used to store the questions created from the v1 metrics.
  If and only if the collection doesn't exists and the option `create?` is truthy,
  the collection is created."
  ([]
   (get-metric-migration-collection nil))
  ([{:keys [create?]}]
   (let [coll-name "Migrated Metrics v1"
         slug (u/slugify coll-name 510)
         desc "This collection and the metrics in it were automatically generated by the migration to v50."]
     (or (t2/select-one :collection :name coll-name :slug slug :description desc)
         (when create?
           (let [collection (t2/insert-returning-instance!
                             :collection
                             {:name coll-name, :slug slug, :description desc})]
             (let [all-users-group-id (t2/select-one-fn :id :permissions_group :name "All Users")]
               (t2/insert! :permissions {:object   (format "/collection/%s/read/" (:id collection))
                                         :group_id all-users-group-id}))
             collection))))))

(defn- get-backup-collection
  ([]
   (get-backup-collection nil))
  ([{:keys [create? parent]}]
   (let [coll-name "Migrated Metrics v1 - backup"
         slug (u/slugify coll-name 510)
         desc "This collection contains the queries rewritten by the migration to v50."]
     (or (t2/select-one :collection :name coll-name :slug slug :description desc)
         (when create?
           (t2/insert-returning-instance!
            :collection
            {:name coll-name, :slug slug, :description desc
             :location (str "/" (:location parent) "/")}))))))

(defn- format-backup-description
  [card]
  (str "#" (:id card) " " (:description card)))

(defn- parse-backup-description
  [description]
  (when-let [[_ id desc] (re-matches #"#(\d+) (.*)" description)]
    [(parse-long id) desc]))

(defn- backup-card
  [card backup-coll]
  (let [backup (-> card
                   (dissoc :id)
                   (assoc :collection_id (:id backup-coll)
                          ;; TODO remove this unless needed for rollback
                          :description (format-backup-description card)))]
    (t2/insert! :report_card backup)))

(defn- restore-card
  [card]
  (if-let [[id desc] (parse-backup-description card)]
    (t2/update! :report_card (assoc card :id id :description desc))
    (log/warnf "card with ID %s and name `%s' is not a backup a card" (:id card) (:name card))))

(defn- add-metric-id
  "Add `id` (the ID of the metric being migrated) to `description`.
  This ID is parsed from the description during rollback. See [[split-metric-id]]."
  [description id]
  (str description " (Migrated from metric " id ".)"))

(defn- convert-metric-v2
  "Convert a metric v2 question from `metric-v1` defined on a table in the
  database with ID `db-id`.
  The :collection_id property is not set and the question is not persisted."
  [metric-v1 db-id]
  (let [definition (json/parse-string (:definition metric-v1) true)
        dataset-query {:type :query
                       :database db-id
                       :query definition}]
    (-> metric-v1
        (select-keys [:archived :created_at :creator_id :database_id
                      :description :name :table_id])
        (update :description add-metric-id (:id metric-v1))
        (assoc :dataset_query (json/generate-string dataset-query)
               :enable_embedding false
               :query_type "query"
               :type "metric"
               :parameters "[]"
               :parameter_mappings "[]"
               :visualization_settings "{}"
               :display "line"))))

;; TODO prevent inserting duplicates if a partial migration is retried
;; (not sure if such a thing can happen with liquibase)
(defn- create-metric-v2
  "Create and persist a metric v2 question from `metric-v1` in `metric-v2-coll`."
  [metric-v1 metric-v2-coll]
  (let [db-id (t2/select-one-fn :db-id :metabase_table (:table_id metric-v1))
        card (-> metric-v1
                 (convert-metric-v2 db-id)
                 (assoc :collection_id (:id metric-v2-coll)))]
    (t2/insert-returning-instance! :report_card card)))

(defn- metric-ref->id
  "If `expr` is a metric reference expression, return the ID of the referenced metric.
  Returns nil otherwise."
  [expr]
  (when (and (vector? expr)
             (= (u/lower-case-en (get expr 0)) "metric"))
    (let [id (get expr 1)]
      ;; GA metrics with string references are ignored
      (when (int? id)
        id))))

(defn- replace-metric-refs
  "Replaces the IDs in metric references contained in `expr` with the :id properties
  of the corresponding entities in `id->entity`.
  `expr` is an MBQL aggregation expression or a part of it.
  The mapping is from metric IDs to v2 metric cards."
  [expr id->entity]
  (if-not (vector? expr)
    expr
    (if-let [id (metric-ref->id expr)]
      (assoc expr 1 (-> id id->entity :id))
      (mapv #(replace-metric-refs % id->entity) expr))))

(defn- rewrite-metric-consuming-query
  [query metric-id->metric-card]
  (if (contains? query :source-query)
    (update query :source-query rewrite-metric-consuming-query metric-id->metric-card)
    (let [aggregation (:aggregation query)
          rewritten (replace-metric-refs aggregation metric-id->metric-card)]
      (cond-> query
        (not= rewritten aggregation) (assoc :aggregation rewritten)))))

(defn- rewrite-metric-consuming-card
  "Rewrite the question `card` replacing references to v1 metrics with references
  to the corresponding v2 metric question as specified by the mapping `metric-id->metric-card`."
  [card metric-id->metric-card]
  (let [dataset-query (json/parse-string (:dataset_query card) true)
        inner-query (:query dataset-query)
        rewritten (rewrite-metric-consuming-query inner-query metric-id->metric-card)]
    (when (not= rewritten inner-query)
      (-> card
          (assoc :dataset_query (-> dataset-query
                                    (assoc :query rewritten)
                                    json/generate-string))
          (dissoc :updated_at)))))

(defn migrate-up
  "Migrate metrics and the cards consuming them to metrics v2. This involves
  1. creating the migration collection,
  2. creating the backup collection for the metric consuming cards,
  3. creating a v2 metric cards for each v1 metric in the migration collection,
  4. creating a backup for each metric consuming card in the backup collection,
  5. rewriting the metric consuming cards to use the migrated v2 metric cards."
  []
  (when (t2/exists? :metric)
    (let [metric-v2-coll (get-metric-migration-collection {:create? true})
          backup-coll (get-backup-collection {:create? true, :parent metric-v2-coll})
          metric-id->metric-card (into {}
                                       (map (juxt :id #(create-metric-v2 % metric-v2-coll)))
                                       (t2/query {:select [:m.* [:t.db_id :database_id]]
                                                  :from [[:metric :m]]
                                                  :left-join [[:metabase_table :t] [:= :t.id :m.table_id]]}))]
      (doseq [card (t2/select :report_card {:where [:like [:lower :dataset_query] "%[\"metric\" %"]})
              :let [rewritten (rewrite-metric-consuming-card card metric-id->metric-card)]
              :when (and rewritten (not= card rewritten))]
        (backup-card card backup-coll)
        ;; TODO updating the dataset_query field only should be enough
        (t2/update! :report_card (:id card) rewritten)))))

(defn- try-deleting-collection
  [coll]
  (try
    (t2/delete! :collection :id (:id coll))
    (catch Exception _
      (log/warn "couldn't delete migration collection" (:name coll)))))

(defn migrate-down
  "Revert the migration to v2 metrics. This involves
  1. restoring the metric consuming cards from the backup,
  2. deleting the backup cards,
  3. deleting the backup collection,
  4. deleting the metric cards created by the up migration,
  5. deleting the metric migration collection."
  []
  (when-let [metric-v2-coll (get-metric-migration-collection)]
    (when-let [backup-coll (get-backup-collection)]
      (doseq [card (t2/select :report_card :collection_id (:id backup-coll))]
        (restore-card card)
        (t2/delete! :report_card :id card))
      (try-deleting-collection backup-coll))
    (doseq [metric-card (t2/select :report_card :collection_id (:id metric-v2-coll))]
      (t2/delete! :report_card :id metric-card))
    (try-deleting-collection metric-v2-coll)))

(comment
  (require '[metabase.db.connection :as mdb.connection]
           '[metabase.db.env :as mdb.env])
  (let [driver :postgres
        conn-uri "postgres://vacskamati/metabase?user=metabase&password=metasample123"
        ds-desc {:mb-db-connection-uri conn-uri}
        data-source (#'mdb.env/env->DataSource driver ds-desc)]
    (binding [mdb.connection/*application-db* (mdb.connection/application-db driver data-source)]
      #_(t2/select-one :metric)
      #_(t2/select-one :report_card)
      #_(t2/select-fn-vec (juxt :id :name :type) :collection)
      #_(t2/select :report_card {:where [:like :dataset_query "%\"metric\"%9%"]})
      #_(let [coll (get-metric-migration-collection {:create? true})
              metric (first
                      (t2/query {:select [:m.* [:t.db_id :database_id]]
                                 :from [[:metric :m]]
                                 :left-join [[:metabase_table :t] [:= :t.id :m.table_id]]
                                 :where [:= :m.id 46]}))
              card (t2/select-one :report_card :id 3691)
              v2-query (or (t2/select-one :report_card :collection_id (:id coll) :description [:like "%(Migrated from metric 46.)"])
                           (create-metric-v2 metric coll))]
          #_(get-metric-v2-cards coll)
          (rewrite-metric-consumption card {46 v2-query}))
      (let [coll (get-metric-migration-collection {:create? true})
            v2-query (t2/select-one :report_card :collection_id (:id coll) :description [:like "%(Migrated from metric 46.)"])
            metric (convert-metric-v1 v2-query)
            card (t2/select-one :report_card :id 3691)
            converted-card (rewrite-metric-consuming-card card {46 v2-query})]
        [converted-card v2-query metric]
        card
        #_(get-metric-v2-cards coll)
        #_(revert-metric-consumption converted-card {(:id v2-query) metric}))))

  (let [driver :postgres
        conn-uri "postgres://vacskamati/metabase?user=metabase&password=metasample123"
        ds-desc {:mb-db-connection-uri conn-uri}
        data-source (#'mdb.env/env->DataSource driver ds-desc)]
    (binding [mdb.connection/*application-db* (mdb.connection/application-db driver data-source)]
      #_(-> (t2/select-one :report_card :id 847)
            :dataset_query
            (json/parse-string true))
      (->> (t2/select-fn-vec :definition :metric :id [:in [49 52]])
           (map #(json/parse-string % true)))))

  (t2/select :collection :name "metrics")
  t2/query
  (get-metric-migration-collection {:create? true})
  (t2/select :permissions)
  (t2/delete! :collection :name "Migrated Metrics v1")
  (t2/select :metric)
  (require '[next.jdbc :as jdbc])
  (t2/with-connection [conn]
    (jdbc/execute! conn ["show columns from report_card"]))
  0)
