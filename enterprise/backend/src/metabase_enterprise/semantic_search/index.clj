(ns metabase-enterprise.semantic-search.index
  (:require
   [clojure.string :as str]
   [honey.sql :as sql]
   [honey.sql.helpers :as sql.helpers]
   [metabase-enterprise.semantic-search.embedding :as embedding]
   [metabase.search.core :as search]
   [metabase.util :as u]
   [metabase.util.json :as json]
   [metabase.util.log :as log]
   [nano-id.core :as nano-id]
   [next.jdbc :as jdbc])
  (:import
   [java.time LocalDate]
   [org.postgresql.util PGobject]))

(set! *warn-on-reflection* true)

(comment
  ((requiring-resolve 'metabase-enterprise.semantic-search.db/init-db!))
  (def db @@(requiring-resolve 'metabase-enterprise.semantic-search.db/data-source)))

(defn sql-format-quoted
  "Call [[sql/format]] with {:quoted true}.

  Ensures identifiers are quoted since the nano-ids used in temp table names when testing (and various other places)
  might contain uppercase chars or hyphens which need to be quoted."
  [honey-sql & {:as opts}]
  (sql/format honey-sql (merge opts {:quoted true})))

(def ^:dynamic *batch-size*
  "The number of documents to process per batch when updating the index."
  150)

(defn- index-table-schema
  "Schema for the index table."
  [vector-dimensions]
  ;; Generate unique constraint name to avoid index name conflicts between multiple test tables
  (let [unique-constraint-name (keyword (str "unique_constraint_" (nano-id/nano-id) "_model_model_id"))]
    [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
     [:model :text :not-null]
     [:model_id :text :not-null]
     [:created_at :timestamp-with-time-zone [:default [:raw "CURRENT_TIMESTAMP"]] :not-null]
     [:creator_id :int]
     [:model_created_at :timestamp-with-time-zone]
     [:last_editor_id :int]
     [:model_updated_at :timestamp-with-time-zone]
     [:archived :boolean [:default false]]
     [:verified :boolean]
     [:official_collection :boolean]
     [:legacy_input :jsonb]
     [:embedding [:raw (format "vector(%d)" vector-dimensions)] :not-null]
     [:text_search_vector :tsvector :not-null]
     [:content :text :not-null]
     [:metadata :jsonb]
     [[:constraint unique-constraint-name]
      [:unique [:composite :model :model_id]]]]))

(defn- format-embedding
  "Formats the embedding vector for SQL insertion."
  [embedding]
  (str "'[" (str/join ", " embedding) "]'::vector"))

(defn- doc->db-record
  "Convert a document to a database record with a provided embedding."
  [embedding-vec {:keys [model id searchable_text created_at creator_id updated_at
                         last_editor_id archived verified official_collection legacy_input] :as doc}]
  {:model               model
   :model_id            id
   :creator_id          creator_id
   :model_created_at    created_at
   :last_editor_id      last_editor_id
   :model_updated_at    updated_at
   :archived            archived
   :verified            verified
   :official_collection official_collection
   :embedding           [:raw (format-embedding embedding-vec)]
   :content             searchable_text
   :text_search_vector [:||
                        (search/weighted-tsvector "A" (:name doc))
                        ;; TODO: :searchable_text contains the doc's name which we don't want for B weighted results
                        (search/weighted-tsvector "B" (:searchable_text doc ""))]
   :legacy_input        [:cast (json/encode legacy_input) :jsonb]
   :metadata            [:cast (json/encode doc) :jsonb]})

(defn- batch-update!
  [connectable records->sql documents embeddings]
  (when (seq documents)
    (u/prog1 (transduce (comp (map (fn [[doc embedding]] (doc->db-record embedding doc)))
                              (partition-all *batch-size*)
                              (map (fn [db-records]
                                     (jdbc/execute! connectable (records->sql db-records))
                                     ;; TODO should this return (or at least log) the number of docs actually
                                     ;; updated, not just the number in the batch?
                                     (u/prog1 (->> db-records (map :model) frequencies)
                                       (log/trace "semantic search processed a batch of" (count db-records)
                                                  "documents with frequencies" <>)))))
                        (partial merge-with +)
                        (map vector documents embeddings))
      (log/trace "semantic search processed" (count documents) "total documents with frequencies" <>))))

(defn- batch-delete-ids!
  [connectable model ids->sql ids]
  (when (seq ids)
    (u/prog1 (->> (transduce (comp (partition-all *batch-size*)
                                   (map (fn [ids]
                                          (jdbc/execute! connectable (ids->sql ids))
                                          (u/prog1 (count ids)
                                            (log/trace "semantic search deleted a batch of" <>
                                                       "documents with model type" model)))))
                             +
                             ids)
                  (array-map model))
      (log/trace "semantic search deleted" (get <> model) "total documents with model type" model))))

(defn- db-records->update-set
  [db-records]
  (let [update-keys (-> db-records first (dissoc :id :model :model_id) keys)
        excluded-kw (fn [column] (keyword (str "excluded." (name column))))]
    (zipmap update-keys (map excluded-kw update-keys))))

(defn default-index
  "Returns the default index spec for a model."
  [embedding-model]
  (let [{:keys [model-name provider vector-dimensions]} embedding-model
        table-name (str "index_table__" provider "__" model-name "__" vector-dimensions)]
    {:embedding-model embedding-model
     :table-name table-name
     :embedding-index-name (str table-name "__hnsw_idx")
     :fts-index-name (str table-name "__gin_idx")}))

(defn upsert-index!
  "Inserts or updates documents in the index table. If a document with the same
  model + model_id already exists, it will be replaced."
  [connectable index documents]
  (log/info "Populating semantic search index with" (count documents) "documents")
  (when (seq documents)
    (let [filtered-documents (remove #(= (:model %) "indexed-entity") documents)
          text->docs         (group-by :searchable_text filtered-documents)
          searchable-texts   (map :searchable_text filtered-documents)]
      (embedding/process-embeddings-streaming
       (:embedding-model index)
       searchable-texts
       (fn [text->embedding]
         (let [batch-documents
               (mapcat (fn [text]
                         (if-let [embedding (text->embedding text)]
                           (map #(assoc % :embedding embedding) (get text->docs text))
                           (when-let [docs (get text->docs text)]
                             (log/warn "No embedding found for" (count docs) "documents with searchable text:"
                                       {:searchable_text text
                                        :document_count (count docs)}))))
                       (keys text->embedding))]
           (batch-update!
            connectable
            (fn [db-records]
              (-> (sql.helpers/insert-into (keyword (:table-name index)))
                  (sql.helpers/values db-records)
                  (sql.helpers/on-conflict :model :model_id)
                  (sql.helpers/do-update-set (db-records->update-set db-records))
                  sql-format-quoted))
            batch-documents
            (map :embedding batch-documents))))))))

(defn- drop-index-table-sql
  [{:keys [table-name]}]
  (-> (sql.helpers/drop-table :if-exists (keyword table-name))
      sql-format-quoted))

(defn drop-index-table!
  "Drops the index table for the given embedding model if it exists."
  [connectable index]
  (jdbc/execute! connectable (drop-index-table-sql index)))

(defn create-index-table!
  "Ensure that the index table exists and is ready to be populated. If
  force-reset? is true, drops and recreates the table if it exists."
  [connectable index & {:keys [force-reset?] :or {force-reset? false}}]
  (try
    (let [{:keys [embedding-model embedding-index-name fts-index-name table-name]} index
          {:keys [vector-dimensions]}                     embedding-model]
      (log/info "Creating index table" table-name)
      (jdbc/execute! connectable (sql/format (sql.helpers/create-extension :vector :if-not-exists)))
      (when force-reset? (drop-index-table! connectable index))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-table (keyword table-name) :if-not-exists)
           (sql.helpers/with-columns (index-table-schema vector-dimensions))
           sql-format-quoted))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-index
            [(keyword embedding-index-name) :if-not-exists]
            [(keyword table-name) :using-hnsw [:raw "embedding vector_cosine_ops"]])
           sql-format-quoted))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-index
            [(keyword fts-index-name) :if-not-exists]
            [(keyword table-name) :using-gin [:raw "text_search_vector"]])
           sql-format-quoted)))
    (catch Exception e
      (throw (ex-info "Failed to create index table" {} e)))))

(comment
  (def embedding-model {:provider "ollama"
                        :model-name "mxbai-embed-large"
                        :vector-dimensions 1024})
  (def index (default-index embedding-model))
  (drop-index-table! db index)
  (create-index-table! db index)
  (jdbc/execute! db ["select table_name from INFORMATION_SCHEMA.tables where table_name like 'index_table__%'"]))

(defn- search-filters
  "Generate WHERE conditions based on search context filters."
  [{:keys [archived? verified models created-at created-by last-edited-at last-edited-by]}]
  (let [conditions (filter some?
                           [(when (some? archived?)
                              [:= :archived archived?])
                            (when (some? verified)
                              [:= :verified verified])
                            (when (seq models)
                              [:in :model models])
                            (when (seq created-by)
                              [:in :creator_id created-by])
                            (when (seq last-edited-by)
                              [:in :last_editor_id last-edited-by])
                            (when (and created-at (:start created-at) (:end created-at))
                              [:between :model_created_at
                               (LocalDate/parse (:start created-at))
                               (LocalDate/parse (:end created-at))])
                            (when (and last-edited-at (:start last-edited-at) (:end last-edited-at))
                              [:between :model_updated_at
                               (LocalDate/parse (:start last-edited-at))
                               (LocalDate/parse (:end last-edited-at))])])]
    (when (seq conditions)
      (into [:and] conditions))))

(defn- keyword-search-query
  "Build a keyword search query using postgres full-text search."
  [index search-context]
  (let [filters (search-filters search-context)
        search-string (:search-string search-context)
        ts-search-vector (str/replace (search/to-tsquery-expr search-string) "'" "")
        base-query {:select [[:id :id]
                             [:model_id :model_id]
                             [:model :model]
                             [:content :content]
                             [:verified :verified]
                             [:metadata :metadata]
                             [[:raw "row_number() OVER (ORDER BY ts_rank_cd(text_search_vector, to_tsquery('" (search/tsv-language) "', '" ts-search-vector "')) DESC)"] :keyword_rank]]
                    :from   [(keyword (:table-name index))]
                    :where  [:raw (str  "text_search_vector @@ to_tsquery('" (search/tsv-language) "', '" ts-search-vector "')")]
                    :order-by [[:keyword_rank :asc]]
                    :limit  100}]
    (if filters
      (update base-query :where #(into [:and] [% filters]))
      base-query)))

(defn- semantic-search-query
  "Build a semantic search query using vector similarity."
  [index embedding search-context]
  (let [filters (search-filters search-context)
        base-query {:select [[:id :id]
                             [:model_id :model_id]
                             [:model :model]
                             [:content :content]
                             [:verified :verified]
                             [:metadata :metadata]
                             [[:raw (str "row_number() OVER (ORDER BY embedding <=> " (format-embedding embedding) " ASC)")] :semantic_rank]]
                    :from   [(keyword (:table-name index))]
                    ;; TODO: parameterize max cosine distance
                    :where [:<= [:raw (str "embedding <=> " (format-embedding embedding))] 0.35]
                    :order-by [[:semantic_rank :asc]]
                    :limit  100}]
    (if filters
      (update base-query :where #(into [:and] [% filters]))
      base-query)))

(defn- hybrid-search-query
  "Build a RRF search query using vector + keyword based search"
  [index embedding search-context]
  (let [semantic-results (semantic-search-query index embedding search-context)
        keyword-results (keyword-search-query index search-context)
        k 60
        keyword-weight 0.5
        semantic-weight 0.5
        full-query {:with [[:vector_results semantic-results]
                           [:text_results keyword-results]]
                    :select [[[:coalesce :v.id :t.id] :id]
                             [[:coalesce :v.model_id :t.model_id] :model_id]
                             [[:coalesce :v.model :t.model] :model]
                             [[:coalesce :v.content :t.content] :content]
                             [[:coalesce :v.verified :t.verified] :verified]
                             [[:coalesce :v.metadata :t.metadata] :metadata]
                             [[:coalesce :v.semantic_rank -1] :semantic_rank]
                             [[:coalesce :t.keyword_rank -1] :keyword_rank]
                             [[:+
                               [:* [:cast semantic-weight :float]
                                [:/ 1.0 [:+ k [:coalesce [:. :v :semantic_rank] 0]]]]
                               [:* [:cast keyword-weight :float]
                                [:/ 1.0 [:+ k [:coalesce [:. :t :keyword_rank] 0]]]]]
                              :rrf_rank]]
                    :from [[:vector_results :v]]
                    :full-join [[:text_results :t] [:= :v.id :t.id]]
                    :order-by [[:rrf_rank :desc]]
                    :limit 100}]
    full-query))

(defn- legacy-input-with-score
  "Fetches the legacy_input field from a result's metadata and attaches a score based on the
  embedding distance."
  [row]
  (-> (get-in row [:metadata :legacy_input])
      (assoc :score (:rrf_rank row 1.0))))

;; TODO: can the query return unqualified keys directly?
(defn- unqualify-keys
  "Remove table namespace from namespaced keywords in a result row."
  [row]
  (into {} (map (fn [[k v]] [(keyword (name k)) v]) row)))

(defn- decode-pgobject
  "Decode a PGObject (returned from a jsonb field) into a Clojure map."
  [^PGobject obj]
  (json/decode (.getValue ^PGobject obj) true))

(defn- decode-metadata
  "Decode `row`s `:metadata`."
  [row]
  (update row :metadata decode-pgobject))

(defn query-index
  "Query the index for documents similar to the search string."
  [db index search-context]
  (let [{:keys [embedding-model]} index
        search-string (:search-string search-context)]
    (when-not (str/blank? search-string)
      (let [embedding (embedding/get-embedding embedding-model search-string)
            query     (hybrid-search-query index embedding search-context)
            xform     (comp (map unqualify-keys)
                            (map decode-metadata)
                            (map legacy-input-with-score))
            reducible (jdbc/plan db (sql-format-quoted query))]
        (transduce xform conj [] reducible)))))

(comment
  (keyword-search-query index {:search-string "dog"})
  (sql-format-quoted (keyword-search-query index {:search-string "dog"}))
  (jdbc/execute! db (sql-format-quoted (keyword-search-query index {:search-string "dog"})))

  (def embed (embedding/get-embedding embedding-model "cat"))
  (semantic-search-query index embed {:search-string "cat"})
  (sql-format-quoted (semantic-search-query index embed {:search-string "cat"}))
  (jdbc/execute! db (sql-format-quoted (semantic-search-query index embed {:search-string "cat"})))

  (jdbc/execute! db (sql-format-quoted (hybrid-search-query index embed {:search-string "cat"})))

  (query-index db index {:search-string "cat"}))

(defn delete-from-index!
  "Deletes documents from the index table based on model and model_ids."
  [db index model model-ids]
  (batch-delete-ids!
   db
   model
   (fn [batch-ids]
     (-> (sql.helpers/delete-from (keyword (:table-name index)))
         (sql.helpers/where [:and
                             [:= :model model]
                             [:in :model_id batch-ids]])
         sql-format-quoted))
   model-ids))

(comment
  (def embedding-model (embedding/get-active-model))
  (def index (default-index embedding-model))
  (create-index-table! index {:force-reset? true})
  (upsert-index! db index [{:model "card"
                            :id "1"
                            :searchable_text "This is a test card"}])
  (delete-from-index! db index "card" ["1"])
  (delete-from-index! db index "dashboard" ["13"])
  ;; no user
  (query-index db index {:search-string "Copper knife"})

  #_:clj-kondo/ignore
  (require '[metabase.test :as mt])
  (mt/with-test-user :crowberto
    (doall (query-index db index {:search-string "Copper knife"}))))
