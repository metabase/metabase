databaseChangeLog:
  - objectQuotingStrategy: QUOTE_ALL_OBJECTS

  # This exists because a v56 migration was backported to v55 without renaming the migration version
  # this allows us to rename those migrations to v55 in master and the release v56 branches which ensure
  # that downgrading or upgrading to v55 picks up the correct migrations needed to run v55 in all cases
  - changeSet:
      id: v56.2025-06-05T16:48:48
      author: edpaget
      comment: Placeholder migration that makes sure the downgrade check doesn't fail
      changes:
        - output:
            message: Placeholder until other changesets
            target: STDOUT
      rollback:

  - changeSet:
      id: v56.2025-06-06T20:11:53
      author: nvoxland
      comment: Drop column query_table.analysis_id
      changes:
        - dropForeignKeyConstraint:
            baseTableName: query_table
            constraintName: fk_query_table_analysis_id
      rollback:

  - changeSet:
      id: v56.2025-06-06T20:11:54
      author: nvoxland
      comment: Drop column query_field.analysis_id
      changes:
        - dropForeignKeyConstraint:
            baseTableName: query_field
            constraintName: fk_query_field_analysis_id
      rollback:

  - changeSet:
      id: v56.2025-06-06T20:11:55
      author: nvoxland
      comment: Drop column query_table.analysis_id
      changes:
        - dropColumn:
            tableName: query_table
            columnName: analysis_id
      rollback:
        - addColumn:
            tableName: query_table
            columns:
              - column:
                  name: analysis_id
                  remarks: round of analysis
                  type: int
                  constraints:
                    nullable: false
                    referencedTableName: query_analysis
                    referencedColumnNames: id
                    foreignKeyName: fk_query_table_analysis_id
                    deleteCascade: true

  - changeSet:
      id: v56.2025-06-06T20:11:56
      author: nvoxland
      comment: Drop column query_field.analysis_id
      changes:
        - dropColumn:
            tableName: query_field
            columnName: analysis_id
      rollback:
        - addColumn:
            tableName: query_field
            columns:
              - column:
                  name: analysis_id
                  remarks: round of analysis
                  type: int
                  constraints:
                    nullable: false
                    referencedTableName: query_analysis
                    referencedColumnNames: id
                    foreignKeyName: fk_query_field_analysis_id
                    deleteCascade: true
                    deleteCascadeForce: true

  - changeSet:
      id: v56.2025-06-06T20:11:58
      author: nvoxland
      comment: Drop now-unused query_analysis table
      changes:
        - dropTable:
            tableName: query_analysis
      rollback:
        - createTable:
            tableName: query_analysis
            remarks: Parent node for query analysis records
            columns:
              - column:
                  name: id
                  remarks: PK
                  type: int
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: card_id
                  remarks: referenced card
                  type: int
                  constraints:
                    nullable: false
                    referencedTableName: report_card
                    referencedColumnNames: id
                    foreignKeyName: fk_query_analysis_card_id
                    deleteCascade: true
              - column:
                  remarks: The timestamp of when the analysis was created
                  name: created_at
                  type: ${timestamp_type}
                  defaultValueComputed: current_timestamp
                  constraints:
                    nullable: false
              - column:
                  remarks: The timestamp of when the analysis was updated
                  name: updated_at
                  type: ${timestamp_type}
                  defaultValueComputed: current_timestamp
                  constraints:
                    nullable: false
              - column:
                  name: status
                  type: ${text.type}
                  remarks: running, failed, or completed

  - changeSet:
      id: v56.2025-06-13T15:00:00
      author: rafpaf
      comment: Create content translation table
      preConditions:
        - onFail: MARK_RAN
        - not:
            - tableExists:
                tableName: content_translation
      changes:
        - createTable:
            tableName: content_translation
            remarks: Content translations
            columns:
              - column:
                  name: id
                  remarks: Unique ID
                  type: int
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: locale
                  remarks: Locale
                  type: varchar(5)
                  constraints:
                    nullable: false
              - column:
                  name: msgid
                  remarks: The raw string
                  type: ${text.type}
                  constraints:
                    nullable: false
              - column:
                  name: msgstr
                  remarks: The translation
                  type: ${text.type}
                  constraints:
                    nullable: false

  - changeSet:
      id: v56.2025-07-07T08:02:43
      author: johnswanson
      comment: improve full names in usage analytics - update view `v_users`
      changes:
        - sqlFile:
            dbms: postgresql
            path: instance_analytics_views/users/v3/postgres-users.sql
            relativeToChangelogFile: true
        - sqlFile:
            dbms: mysql,mariadb
            path: instance_analytics_views/users/v3/mysql-users.sql
            relativeToChangelogFile: true
        - sqlFile:
            dbms: h2
            path: instance_analytics_views/users/v3/h2-users.sql
            relativeToChangelogFile: true
      rollback:
        - sqlFile:
            dbms: postgresql
            path: instance_analytics_views/users/v2/postgres-users.sql
            relativeToChangelogFile: true
        - sqlFile:
            dbms: mysql,mariadb
            path: instance_analytics_views/users/v2/mysql-users.sql
            relativeToChangelogFile: true
        - sqlFile:
            dbms: h2
            path: instance_analytics_views/users/v2/h2-users.sql
            relativeToChangelogFile: true

  - changeSet:
      id: v56.2025-07-17T20:11:55
      author: edpaget
      comment: Add column to user for jwt-set attributes
      changes:
        - addColumn:
            tableName: core_user
            columns:
              - column:
                  name: jwt_attributes
                  type: ${text.type}
                  remarks: JSON object containing attributes set through jwt
                  constraints:
                    nullable: true

  - changeSet:
      id: v56.2025-07-17T20:11:56
      author: edpaget
      comment: |
        Add sync login_attributes with jwt_attributes, we need to replace jwt_attributes
        with login attributes for users with sso_source jwt so that they will get the new
        behavior where login_attributes can override jwt_attributes
      changes:
        - sql: >-
           UPDATE core_user
           SET jwt_attributes = login_attributes, login_attributes = '{}'
           WHERE sso_source = 'jwt';
      rollback:
        - sql: >-
           UPDATE core_user
           SET login_attributes = jwt_attributes
           WHERE sso_source = 'jwt';

  - changeSet:
      id: v56.2025-07-30T10:35:00
      author: bronsa
      comment: Add deactivated_at column to metabase_table
      preConditions:
        - onFail: MARK_RAN
        - not:
            - columnExists:
                tableName: metabase_table
                columnName: deactivated_at
      changes:
        - addColumn:
            tableName: metabase_table
            columns:
              - column:
                  name: deactivated_at
                  type: ${timestamp_type}
                  remarks: The timestamp when the table was deactivated (active changed from true to false)
                  constraints:
                    nullable: true

  - changeSet:
      id: v56.2025-07-30T10:35:01
      author: bronsa
      comment: Add archived_at column to metabase_table
      preConditions:
        - onFail: MARK_RAN
        - not:
            - columnExists:
                tableName: metabase_table
                columnName: archived_at
      changes:
        - addColumn:
            tableName: metabase_table
            columns:
              - column:
                  name: archived_at
                  type: ${timestamp_type}
                  remarks: The timestamp when the table was marked for archiving
                  constraints:
                    nullable: true

  - changeSet:
      id: v56.2025-07-30T10:41:00
      author: bronsa
      comment: Add composite index on metabase_table for unarchived deactivated tables by db_id (PostgreSQL)
      dbms: postgresql
      preConditions:
        - onFail: MARK_RAN
        - not:
            - indexExists:
                tableName: metabase_table
                indexName: idx_metabase_table_db_deactivated
      changes:
        - sql:
            sql: >-
              CREATE INDEX idx_metabase_table_db_deactivated
              ON metabase_table (db_id, deactivated_at)
              WHERE active = false AND archived_at IS NULL AND deactivated_at IS NOT NULL;
      rollback:
        - dropIndex:
            tableName: metabase_table
            indexName: idx_metabase_table_db_deactivated

  - changeSet:
      id: v56.2025-07-30T10:43:00
      author: bronsa
      comment: Backfill deactivated_at for existing inactive tables
      changes:
        - sql:
            sql: >-
              UPDATE metabase_table
              SET deactivated_at = updated_at
              WHERE active = false
                AND deactivated_at IS NULL;
      rollback:
        - sql:
            sql: >-
              UPDATE metabase_table
              SET deactivated_at = NULL;

  - changeSet:
      id: v56.2025-08-01T11:11:00
      author: bronsa
      comment: Migration to allow rollbacking of archived tables when possible
      changes:
        - empty: #no-op on forward migration
      rollback:
        - sql:
            dbms: postgresql
            sql: >-
              UPDATE metabase_table
              SET
                name = REGEXP_REPLACE(name, '__mbarchiv__\d+$', ''),
                archived_at = NULL
              WHERE archived_at IS NOT NULL
                AND active = false
                AND name ~ '__mbarchiv__\d+$'
                AND NOT EXISTS (
                  SELECT 1 FROM metabase_table mt2
                  WHERE mt2.db_id = metabase_table.db_id
                    AND mt2.schema IS NOT DISTINCT FROM metabase_table.schema
                    AND mt2.name = REGEXP_REPLACE(metabase_table.name, '__mbarchiv__\d+$', '')
                    AND mt2.id != metabase_table.id);
        - sql:
            dbms: mysql,mariadb
            sql: >-
              UPDATE metabase_table mt1
              LEFT JOIN metabase_table mt2 ON (
                mt2.db_id = mt1.db_id
                AND (mt2.schema = mt1.schema OR (mt2.schema IS NULL AND mt1.schema IS NULL))
                AND mt2.name = SUBSTRING(mt1.name, 1, POSITION('__mbarchiv__' IN mt1.name) - 1)
                AND mt2.id != mt1.id
              )
              SET
                mt1.name = SUBSTRING(mt1.name, 1, POSITION('__mbarchiv__' IN mt1.name) - 1),
                mt1.archived_at = NULL
              WHERE mt1.archived_at IS NOT NULL
                AND mt1.active = false
                AND mt1.name LIKE '%__mbarchiv__%'
                AND mt2.id IS NULL;
        - sql:
            dbms: h2
            sql: >-
              UPDATE metabase_table
              SET
                name = SUBSTRING(name, 1, POSITION('__mbarchiv__' IN name) - 1),
                archived_at = NULL
              WHERE archived_at IS NOT NULL
                AND active = false
                AND name LIKE '%__mbarchiv__%'
                AND NOT EXISTS (
                  SELECT 1 FROM metabase_table mt2
                  WHERE mt2.db_id = metabase_table.db_id
                    AND (mt2.schema = metabase_table.schema OR (mt2.schema IS NULL AND metabase_table.schema IS NULL))
                    AND mt2.name = SUBSTRING(metabase_table.name, 1, POSITION('__mbarchiv__' IN metabase_table.name) - 1)
                    AND mt2.id != metabase_table.id);

  - changeSet:
      id: v56.2025-08-22T12:00:00
      author: sloansparger
      comment: Add use_verified_content column to metabot
      changes:
        - addColumn:
            tableName: metabot
            columns:
              - column:
                  name: use_verified_content
                  type: ${boolean.type}
                  remarks: Whether this metabot should only use verified content
                  constraints:
                    nullable: true
                  defaultValueBoolean: false

  - changeSet:
      id: v56.2025-08-22T12:00:01
      author: sloansparger
      comment: Add collection_id column to metabot
      changes:
        - addColumn:
            tableName: metabot
            columns:
              - column:
                  name: collection_id
                  type: int
                  remarks: ID of the collection this metabot can access
                  constraints:
                    nullable: true

  - changeSet:
      id: v56.2025-08-22T12:00:02
      author: sloansparger
      comment: Add metabot_id column to metabot_prompt
      changes:
        - addColumn:
            tableName: metabot_prompt
            columns:
              - column:
                  name: metabot_id
                  type: int
                  remarks: The metabot this prompt is associated with
                  constraints:
                    nullable: true

  - changeSet:
      id: v56.2025-08-22T12:00:03
      author: sloansparger
      comment: Migrate collection references from metabot_entity to metabot.collection_id with exception to the default metabot instance
      changes:
        - sql:
            comment: Migrate collection references from metabot_entity to metabot.collection_id with exception to the default metabot instance
            sql: >-
              UPDATE metabot
              SET collection_id = (
                SELECT me.model_id
                FROM metabot_entity me
                WHERE me.metabot_id = metabot.id
                  AND me.model = 'collection'
                LIMIT 1
              )
              WHERE EXISTS (
                SELECT 1
                FROM metabot_entity me
                WHERE me.metabot_id = metabot.id
                  AND me.model = 'collection'
              )
              AND metabot.entity_id != 'metabotmetabotmetabot';
      rollback:
        - sql:
            comment: Clear collection_id values set by the migration
            sql: >-
              UPDATE metabot
              SET collection_id = NULL
              WHERE collection_id IS NOT NULL
              AND metabot.entity_id != 'metabotmetabotmetabot';

  - changeSet:
      id: v56.2025-08-22T12:00:04
      author: sloansparger
      comment: Migrate metabot_prompt.metabot_entity_id to metabot_prompt.metabot_id
      changes:
        - sql:
            comment: Migrate metabot_prompt.metabot_entity_id to metabot_prompt.metabot_id
            sql: >-
              UPDATE metabot_prompt
              SET metabot_id = (
                SELECT me.metabot_id
                FROM metabot_entity me
                WHERE me.id = metabot_prompt.metabot_entity_id
              );
      rollback:
        - sql:
            comment: Clear metabot_id values set by the migration
            sql: >-
              UPDATE metabot_prompt
              SET metabot_id = NULL
              WHERE metabot_id IS NOT NULL;

  - changeSet:
      id: v56.2025-08-22T12:00:05
      author: sloansparger
      comment: Add not null constraint to metabot_prompt.metabot_id
      changes:
        - addNotNullConstraint:
            tableName: metabot_prompt
            columnName: metabot_id
            columnDataType: int

  - changeSet:
      id: v56.2025-08-22T12:00:06
      author: sloansparger
      comment: Add index on metabot_prompt.metabot_id
      changes:
        - createIndex:
            tableName: metabot_prompt
            indexName: idx_metabot_prompt_metabot_id
            columns:
              - column:
                  name: metabot_id

  - changeSet:
      id: v56.2025-08-22T12:00:07
      author: sloansparger
      comment: Add foreign key constraint metabot_prompt.metabot_id -> metabot.id
      changes:
        - addForeignKeyConstraint:
            baseTableName: metabot_prompt
            baseColumnNames: metabot_id
            referencedTableName: metabot
            referencedColumnNames: id
            constraintName: fk_metabot_prompt_metabot_id
            onDelete: CASCADE

  - changeSet:
      id: v56.2025-08-22T12:00:08
      author: sloansparger
      comment: Drop foreign key constraint metabot_prompt.metabot_entity_id
      changes:
        - dropForeignKeyConstraint:
            baseTableName: metabot_prompt
            constraintName: fk_metabot_prompt_metabot_entity_id
      rollback:
        - addForeignKeyConstraint:
            baseTableName: metabot_prompt
            baseColumnNames: metabot_entity_id
            referencedTableName: metabot_entity
            referencedColumnNames: id
            constraintName: fk_metabot_prompt_metabot_entity_id
            onDelete: CASCADE

  - changeSet:
      id: v56.2025-08-22T12:00:09
      author: sloansparger
      comment: Drop index on metabot_prompt.metabot_entity_id
      changes:
        - dropIndex:
            tableName: metabot_prompt
            indexName: idx_metabot_prompt_metabot_entity_id
      rollback:
        - createIndex:
            tableName: metabot_prompt
            indexName: idx_metabot_prompt_metabot_entity_id
            columns:
              - column:
                  name: metabot_entity_id

  - changeSet:
      id: v56.2025-08-22T12:00:10
      author: sloansparger
      comment: Drop metabot_entity_id column from metabot_prompt
      changes:
        - dropColumn:
            tableName: metabot_prompt
            columnName: metabot_entity_id
      rollback:
        - addColumn:
            tableName: metabot_prompt
            columns:
              - column:
                  name: metabot_entity_id
                  type: int
                  remarks: The metabot entity this prompt is associated with
                  constraints:
                    nullable: true
            preConditions:
              - onFail: MARK_RAN
              - not:
                  - columnExists:
                      tableName: metabot_prompt
                      columnName: metabot_entity_id
        - sql:
            comment: Restore metabot_prompt.metabot_entity_id values from metabot_prompt.metabot_id
            sql: >-
              UPDATE metabot_prompt
              SET metabot_entity_id = (
                SELECT me.id
                FROM metabot_entity me
                WHERE me.metabot_id = metabot_prompt.metabot_id
                  AND me.model = 'collection'
                LIMIT 1
              );
        - addNotNullConstraint:
            tableName: metabot_prompt
            columnName: metabot_entity_id
            columnDataType: int

  - changeSet:
      id: v56.2025-08-22T12:00:11
      author: sloansparger
      comment: Remove metabot_entity table as collection association is now direct
      changes:
        - dropTable:
            tableName: metabot_entity
            cascadeConstraints: true
            comment: Remove metabot_entity table as collection association is now direct
      rollback:
        - createTable:
            tableName: metabot_entity
            remarks: Entities associated with a metabot
            columns:
              - column:
                  name: id
                  type: int
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: metabot_id
                  type: int
                  remarks: The metabot this entity is associated with
                  constraints:
                    nullable: false
              - column:
                  name: model
                  type: varchar(32)
                  remarks: The type of model this entity references
                  constraints:
                    nullable: false
              - column:
                  name: model_id
                  type: int
                  remarks: The ID of the model this entity references
                  constraints:
                    nullable: false
              - column:
                  name: entity_id
                  type: char(21)
                  remarks: Random NanoID tag for unique identity
                  constraints:
                    nullable: true
                    unique: true
              - column:
                  remarks: The timestamp of when the entity was created
                  name: created_at
                  type: ${timestamp_type}
                  defaultValueComputed: current_timestamp
                  constraints:
                    nullable: false
        - createIndex:
            tableName: metabot_entity
            indexName: idx_metabot_entity_metabot_id
            columns:
              - column:
                  name: metabot_id
        - addForeignKeyConstraint:
            baseTableName: metabot_entity
            baseColumnNames: metabot_id
            referencedTableName: metabot
            referencedColumnNames: id
            constraintName: fk_metabot_entity_metabot_id
            onDelete: CASCADE
        - sql:
            comment: Restore collection references to metabot_entity from metabot.collection_id
            sql: >-
              INSERT INTO metabot_entity (metabot_id, model, model_id)
              SELECT id, 'collection', collection_id
              FROM metabot
              WHERE collection_id IS NOT NULL;

# >>>>>>>>>> DO NOT ADD NEW MIGRATIONS BELOW THIS LINE! ADD THEM ABOVE <<<<<<<<<<

########################################################################################################################
#
# ADVICE:
#
# 1) Think through some of these points when writing a migration, learn from our past mistakes:
#    - Do you really need a migration? Could the feature work without it? Prefer not to if possible.
#      Data in the wild can be vastly different from what you expect, and it's hard to get right.
#    - Make sure your migration is backward compatible: it might not be possible to add a constraint back
#      if you drop it in a migration.
#    - Postgres, MySQL and H2 have their differences. Make sure your migration works for all.
#    - Database encryption is a major issue:
#      - Fields like `metabase_database.details` or `setting.value` can be encrypted, so you need to decrypt them in
#        your migration. See #42617, #44048.
#      - Database could be partially encrypted, see https://www.notion.so/72575933ef2a446bafd16909e05a7387
#    - Custom migrations:
#      - Prefer SQL migrations when possible.
#      - Never use application code: it can change and *will* break your migration.
#      - Do not use Toucan models - refer table names directly.
#      - If it's a big change, consider using Quartz, see #42279
#      - More in `metabase.app_db.custom_migrations` namespace doc.
#    - Never delete a migration: users won't be able to downgrade. If you really need to, see #44908
#    - Migration id (`vXX.<date>`) must match its earliest released version:
#      - Do not backport `v51....` to version 50, Metabase will try to downgrade it.
#      - Instead, write a migration with an oldest target you plan to backport to in mind.
#
# 2) Migrations should go in the ###_update_migrations.yaml file for the target version.
#
# 3) Run mage lint-migrations-file to run core.spec checks against any changes you make here. Liquibase is pretty
#    forgiving and won't complain if you accidentally mix up things like deleteCascade and onDelete: CASCADE. CI runs
#    this check but it's nicer to know now instead of waiting for CI.
#
# 3) Migration IDs should follow the format
#
#    vMM.TIMESTAMP
#
#    Where
#
#    M         = major version
#    TIMESTAMP = the current timestamp with format `yyyy-MM-dd'T'HH:mm:ss`
#                To get this timestamp, evaluate this in your REPL: `(dev/migration-timestamp)`
#
#    E.g: You're adding a new migration for version 49, And it's 10:30:00AM on April 1, 2023 (UTC),
#    your migration id should be: `v49.2023-04-01T10:30:00`.
#
# PLEASE KEEP THIS MESSAGE AT THE BOTTOM OF THIS FILE!!!!! Add new migrations above the message.
#
########################################################################################################################
