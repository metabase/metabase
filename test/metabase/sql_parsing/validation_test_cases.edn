;; SQL Query Validation Test Cases
;; Each test case has:
;; - :name - descriptive name for the test
;; - :sql - the SQL query to validate
;; - :dialect - SQL dialect (postgres, mysql, snowflake, bigquery, redshift, duckdb)
;; - :expected - either :valid or a map with :valid false and :errors containing error patterns to match
;;
;; Error patterns can be:
;; - A string - must be contained in the error message (case-insensitive)
;; - A vector of strings - ANY of the strings must be contained (logical OR)
;; - :has-location - true if line/col should be present, false if not expected

{:valid-queries
 [;; Basic queries
  {:name "simple-select"
   :sql "SELECT * FROM users"
   :dialect "postgres"
   :expected :valid}

  {:name "select-with-columns"
   :sql "SELECT id, name, email FROM users"
   :dialect "postgres"
   :expected :valid}

  {:name "select-with-where"
   :sql "SELECT * FROM users WHERE active = true"
   :dialect "postgres"
   :expected :valid}

  {:name "select-with-order-by"
   :sql "SELECT * FROM users ORDER BY created_at DESC"
   :dialect "postgres"
   :expected :valid}

  {:name "select-with-limit"
   :sql "SELECT * FROM users LIMIT 10"
   :dialect "postgres"
   :expected :valid}

  ;; Joins
  {:name "inner-join"
   :sql "SELECT u.name, o.total FROM users u INNER JOIN orders o ON u.id = o.user_id"
   :dialect "postgres"
   :expected :valid}

  {:name "left-join"
   :sql "SELECT u.name, o.total FROM users u LEFT JOIN orders o ON u.id = o.user_id"
   :dialect "postgres"
   :expected :valid}

  {:name "multiple-joins"
   :sql "SELECT u.name, o.total, p.name FROM users u LEFT JOIN orders o ON u.id = o.user_id LEFT JOIN products p ON o.product_id = p.id"
   :dialect "postgres"
   :expected :valid}

  ;; Subqueries
  {:name "subquery-in-from"
   :sql "SELECT * FROM (SELECT id, name FROM users WHERE active = true) AS active_users"
   :dialect "postgres"
   :expected :valid}

  {:name "subquery-in-where"
   :sql "SELECT * FROM orders WHERE user_id IN (SELECT id FROM users WHERE active = true)"
   :dialect "postgres"
   :expected :valid}

  ;; CTEs
  {:name "simple-cte"
   :sql "WITH active_users AS (SELECT * FROM users WHERE active = true) SELECT * FROM active_users"
   :dialect "postgres"
   :expected :valid}

  {:name "multiple-ctes"
   :sql "WITH active_users AS (SELECT * FROM users WHERE active = true), recent_orders AS (SELECT * FROM orders WHERE created_at > '2024-01-01') SELECT * FROM active_users JOIN recent_orders ON active_users.id = recent_orders.user_id"
   :dialect "postgres"
   :expected :valid}

  ;; Aggregations
  {:name "count-aggregate"
   :sql "SELECT COUNT(*) FROM users"
   :dialect "postgres"
   :expected :valid}

  {:name "group-by"
   :sql "SELECT country, COUNT(*) FROM users GROUP BY country"
   :dialect "postgres"
   :expected :valid}

  {:name "having-clause"
   :sql "SELECT country, COUNT(*) as cnt FROM users GROUP BY country HAVING COUNT(*) > 10"
   :dialect "postgres"
   :expected :valid}

  ;; Set operations
  {:name "union"
   :sql "SELECT id FROM users UNION SELECT id FROM archived_users"
   :dialect "postgres"
   :expected :valid}

  {:name "union-all"
   :sql "SELECT id FROM users UNION ALL SELECT id FROM archived_users"
   :dialect "postgres"
   :expected :valid}

  ;; Window functions
  {:name "window-function"
   :sql "SELECT name, salary, RANK() OVER (ORDER BY salary DESC) FROM employees"
   :dialect "postgres"
   :expected :valid}

  {:name "window-with-partition"
   :sql "SELECT name, department, salary, AVG(salary) OVER (PARTITION BY department) FROM employees"
   :dialect "postgres"
   :expected :valid}

  ;; Case expressions
  {:name "case-expression"
   :sql "SELECT name, CASE WHEN age < 18 THEN 'minor' ELSE 'adult' END AS age_group FROM users"
   :dialect "postgres"
   :expected :valid}

  ;; Schema-qualified tables
  {:name "schema-qualified"
   :sql "SELECT * FROM public.users"
   :dialect "postgres"
   :expected :valid}

  {:name "multiple-schemas"
   :sql "SELECT * FROM public.users u JOIN other_schema.orders o ON u.id = o.user_id"
   :dialect "postgres"
   :expected :valid}

  ;; Different dialects
  {:name "mysql-backticks"
   :sql "SELECT `id`, `name` FROM `users`"
   :dialect "mysql"
   :expected :valid}

  {:name "bigquery-project-dataset"
   :sql "SELECT * FROM `project.dataset.table`"
   :dialect "bigquery"
   :expected :valid}

  {:name "snowflake-database-schema"
   :sql "SELECT * FROM database.schema.table"
   :dialect "snowflake"
   :expected :valid}

  ;; Complex queries
  {:name "complex-nested-query"
   :sql "WITH ranked_users AS (SELECT id, name, RANK() OVER (ORDER BY created_at DESC) as rank FROM users) SELECT * FROM ranked_users WHERE rank <= 10"
   :dialect "postgres"
   :expected :valid}

  {:name "multiple-aggregates"
   :sql "SELECT department, COUNT(*) as total, AVG(salary) as avg_salary, MAX(salary) as max_salary FROM employees GROUP BY department"
   :dialect "postgres"
   :expected :valid}]

 :invalid-queries
 [;; Note: sqlglot's parser is permissive and accepts some queries that would fail in actual databases
  ;; These tests verify what sqlglot considers syntactically invalid

  ;; Syntax errors that sqlglot catches
  {:name "typo-in-keyword-form-instead-of-from"
   :sql "SELECT * FORM users"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Unexpected token"]
                        :has-location true}]}}

  {:name "typo-in-keyword-selct-instead-of-select"
   :sql "SELCT * FROM users"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Required keyword"]
                        :has-location true}]}}

  {:name "missing-table-name"
   :sql "SELECT * FROM"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains "Expected table name"
                        :has-location true}]}}

  {:name "incomplete-join"
   :sql "SELECT * FROM users JOIN"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains "Expected table name"
                        :has-location true}]}}

  {:name "unclosed-parenthesis"
   :sql "SELECT * FROM (SELECT * FROM users"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains "Expecting )"
                        :has-location true}]}}

  {:name "invalid-where-clause"
   :sql "SELECT * FROM users WHERE"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Required keyword"]
                        :has-location true}]}}

  {:name "unmatched-quote"
   :sql "SELECT * FROM users WHERE name = 'John"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Error tokenizing" "Unexpected error"]
                        :has-location false}]}}

  {:name "missing-cte-body"
   :sql "WITH active_users AS SELECT * FROM active_users"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Required keyword" "Expecting"]
                        :has-location true}]}}

  {:name "invalid-union"
   :sql "SELECT * FROM users UNION"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Required keyword" "Expecting"]
                        :has-location false}]}}

  {:name "invalid-operator"
   :sql "SELECT * FROM users WHERE id === 1"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Required keyword" "expression" "missing"]
                        :has-location true}]}}

  {:name "missing-order-by-expression"
   :sql "SELECT * FROM users ORDER BY"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Required keyword"]
                        :has-location true}]}}

  {:name "invalid-case-expression"
   :sql "SELECT CASE WHEN THEN 'yes' END FROM users"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Invalid expression" "Required keyword"]
                        :has-location true}]}}

  ;; Completely invalid SQL
  {:name "nonsense-query"
   :sql "complete nonsense query"
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains "Invalid expression"
                        :has-location false}]}}

  {:name "empty-string"
   :sql ""
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Failed to parse" "Invalid SQL"]
                        :has-location false}]}}

  {:name "only-whitespace"
   :sql "   \n  \t  "
   :dialect "postgres"
   :expected {:valid false
              :errors [{:contains ["Failed to parse" "Invalid SQL"]
                        :has-location false}]}}]

 ;; Edge cases that ARE valid in sqlglot (even if they might fail in real databases)
 :edge-case-valid-queries
 [{:name "missing-from-with-where"
   :sql "SELECT * WHERE id = 1"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot accepts this, though most databases would reject it"}

  {:name "missing-select-expression"
   :sql "SELECT FROM users"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot accepts SELECT FROM (selects all columns)"}

  {:name "join-without-on"
   :sql "SELECT * FROM users JOIN orders"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot accepts JOIN without ON (cross join)"}

  {:name "multiple-statements-semicolon"
   :sql "SELECT * FROM users; SELECT * FROM orders"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot parses multiple statements"}

  {:name "trailing-semicolon"
   :sql "SELECT * FROM users;"
   :dialect "postgres"
   :expected :valid}

  {:name "group-by-without-expression"
   :sql "SELECT COUNT(*) FROM users GROUP BY"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot allows GROUP BY with no expression"}

  {:name "double-comma"
   :sql "SELECT id,, name FROM users"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot allows double comma (treats as null between)"}

  {:name "incomplete-limit-clause"
   :sql "SELECT 1 LIMIT"
   :dialect "postgres"
   :expected :valid
   :note "sqlglot parses as 'SELECT 1 AS LIMIT' treating LIMIT as column alias"}

  {:name "incomplete-limit-clause-snowflake"
   :sql "SELECT 1 LIMIT"
   :dialect "snowflake"
   :expected :valid
   :note "sqlglot parses as 'SELECT 1 AS LIMIT' treating LIMIT as column alias"}

  {:name "incomplete-limit-clause-mysql"
   :sql "SELECT 1 LIMIT"
   :dialect "mysql"
   :expected :valid
   :note "sqlglot parses as 'SELECT 1 AS LIMIT' treating LIMIT as column alias"}]}
