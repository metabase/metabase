(ns metabase-enterprise.representations.v0.question-test
  (:require
   ;; TODO: determine new tests to replace old singleton import/export
   #_[metabase-enterprise.representations.export :as export]
   #_[metabase-enterprise.representations.import :as import]
   [clojure.test :refer :all]
   [metabase-enterprise.representations.core :as rep]
   [metabase-enterprise.representations.v0.common :as v0-common]
   [metabase-enterprise.representations.yaml :as rep-yaml]
   [metabase.test :as mt]
   [metabase.test.fixtures :as fixtures]
   [toucan2.core :as t2]))

(use-fixtures :once (fixtures/initialize :db))

(def singleton-yamls ["test_resources/representations/v0/singletons/monthly-revenue.question.yml"])

(deftest validate-example-yamls
  (testing "Testing valid examples"
    (doseq [filename singleton-yamls]
      (testing (str "Validating: " filename)
        (let [rep (rep-yaml/from-file filename)]
          (is (rep/normalize-representation rep))))))
  (testing "Testing invalid examples"
    (doseq [filename
            ["test_resources/representations/v0/invalid.question.yml"]]
      (testing (str "Validating: " filename)
        (let [rep (rep-yaml/from-file filename)]
          (is (thrown? clojure.lang.ExceptionInfo (rep/normalize-representation rep))))))))

(deftest validate-exported-questions
  (doseq [query [(mt/native-query {:query "select 1"})
                 (mt/mbql-query users)]]
    (mt/with-temp [:model/Card question {:type :question
                                         :dataset_query query}]
      (let [edn (rep/export question)
            ;; convert to yaml and read back in to convert keywords to strings, etc
            yaml (rep-yaml/generate-string edn)
            rep (rep-yaml/parse-string yaml)]
        (is (rep/normalize-representation rep))))))

(deftest can-import
  (let [filename "test_resources/representations/v0/monthly-revenue.question.yml"
        rep (rep-yaml/from-file filename)
        ref-index {(v0-common/unref (:database rep))
                   (t2/select-one :model/Database (mt/id))}]
    (is (rep/persist! rep ref-index))))

#_(deftest import-export-singleton-test
    (testing "Testing import then export roundtrip with IDs"
      (doseq [filename singleton-yamls]
        (testing (str "Importing-Exporting: " filename)
          (let [db-id (mt/id)
                rep (-> (import/import-yaml filename)
                        (assoc :database db-id))
                persisted (rep/persist! rep nil)]
            (is persisted)
            (let [question (t2/select-one :model/Card :id (:id persisted))
                  edn (rep/export-with-ids question)
                  yaml (rep-yaml/generate-string edn)
                  rep2 (rep-yaml/parse-string yaml)]
              (is (= db-id (:database rep2))
                  "Database should be exported as integer ID")
              (is (=? (dissoc rep :ref) rep2)
                  "Exported representation should match imported (except autogenerated ref)")))))))

#_(deftest export-import-singleton-test
    (testing "Testing export then import roundtrip"
      (doseq [query [(mt/native-query {:query "select 1"})
                     (mt/mbql-query users)]]
        (mt/with-temp [:model/Card question {:type :question
                                             :dataset_query query}]
          (let [card-edn (rep/export-with-refs question)
                card-yaml (rep-yaml/generate-string card-edn)
                card-rep (rep-yaml/parse-string card-yaml)
                card-rep (rep/normalize-representation card-rep)

              ;; For MBQL queries, also export MBQL data
                mbql-edn (when (= :query (:type query))
                           (export/export-mbql-data question))

              ;; For MBQL queries, serialize to YAML and parse back
                mbql-rep (when mbql-edn
                           (let [mbql-yaml (-> mbql-edn export/export-entity rep-yaml/generate-string)
                                 parsed (rep-yaml/parse-string mbql-yaml)]
                             (rep/normalize-representation parsed)))

              ;; Build ref-index with database and MBQL data (if present)
                ref-index (cond-> {(v0-common/unref (:database card-edn)) (t2/select-one :model/Database (mt/id))}
                            mbql-rep (assoc (:ref mbql-rep) (import/persist! mbql-rep nil)))

                question (rep/persist! card-rep ref-index)
                question (t2/select-one :model/Card :id (:id question))
                edn (rep/export-with-refs question)
                yaml (rep-yaml/generate-string edn)
                rep2 (rep-yaml/parse-string yaml)
                rep2 (rep/normalize-representation rep2)]
            (is (=? (dissoc card-rep :ref) rep2)))))))
