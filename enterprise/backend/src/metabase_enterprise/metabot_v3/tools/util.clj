(ns metabase-enterprise.metabot-v3.tools.util
  (:require
   [clojure.string :as str]
   [medley.core :as m]
   [metabase.api.common :as api]
   [metabase.lib.core :as lib]
   [metabase.lib.types.isa :as lib.types.isa]
   [metabase.models.interface :as mi]
   [metabase.util :as u]
   [toucan2.core :as t2]))

(defn handle-agent-error
  "Return an agent output for agent errors, re-throw `e` otherwise."
  [e]
  (if (-> e ex-data :agent-error?)
    {:output (ex-message e)}
    (throw e)))

(defn convert-field-type
  "Return tool type for `column`."
  [column]
  (let [column (u/normalize-map column)]
    (cond
      (lib.types.isa/boolean? column)                :boolean
      (lib.types.isa/string-or-string-like? column)  :string
      (lib.types.isa/numeric? column)                :number
      (isa? (:effective-type column) :type/DateTime) :datetime
      (isa? (:effective-type column) :type/Time)     :time
      (lib.types.isa/temporal? column)               :date)))

(defn table-field-id-prefix
  "Return the field ID prefix for `table-id`."
  [table-id]
  (str "t" table-id "/"))

(defn card-field-id-prefix
  "Return the field ID prefix for a model or a metric with ID `card-id`."
  [card-id]
  (str "c" card-id "/"))

(defn query-field-id-prefix
  "Return the field ID prefix for `query-id`."
  [query-id]
  (str "q" query-id "/"))

(def any-prefix-pattern
  "A prefix pattern accepting columns from any entity."
  #"^.*/(\d+)")

(defn- find-column-indexes
  [col-to-find cols]
  (keep-indexed (fn [i col]
                  (when (= col (select-keys col-to-find (keys col)))
                    i))
                cols))

(defn ->result-column
  "Return tool result columns for `column` of `query`. The position of `column` is determined by `index-or-columns`
  unless the latter is a sequence of columns, in which case the index of `column` in `index-or-columns` is used.
  The ID is then generated by prefixing the position with `field-id-prefix`."
  [query column index-or-columns field-id-prefix]
  (let [pos (if (sequential? index-or-columns)
              (first (find-column-indexes column index-or-columns))
              index-or-columns)
        semantic-type (some-> (:semantic-type column) name u/->snake_case_en)]
    (-> {:field-id (str field-id-prefix pos)
         :name (lib/display-name query column)
         :type (convert-field-type column)}
        (m/assoc-some :description (:description column)
                      :semantic-type semantic-type
                      :field-values (:field-values column)
                      :table-reference (:table-reference column)))))

(defn resolve-column-index
  "Resolve the reference `field_id` to the index of the result columns in the entity with `field-id-prefix`."
  [field-id field-id-prefix]
  (if (string? field-id-prefix)
    (if (str/starts-with? field-id field-id-prefix)
      (-> field-id (subs (count field-id-prefix)) parse-long)
      (throw (ex-info (str "field " field-id " not found") {:agent-error? true
                                                            :expected-prefix field-id-prefix})))
    (if-let [id-str (when (instance? java.util.regex.Pattern field-id-prefix)
                      (-> (re-matches field-id-prefix field-id)
                          second))]
      (parse-long id-str)
      (throw (ex-info (str "invalid field_id " field-id " for prefix " field-id-prefix)
                      {:agent-error? true
                       :expected-prefix (str field-id-prefix)
                       :field-id field-id})))))

(defn resolve-column
  "Resolve the reference `field-id` in filter `item` by finding the column in `columns` specified by `field-id`.
  `field-id-prefix` is used to check if the filter refers to a column from the right entity."
  [{:keys [field-id] :as item} field-id-prefix columns]
  (let [index (resolve-column-index field-id field-id-prefix)]
    (assoc item :column (nth columns index))))

(defn get-table
  "Get the `fields` of the table with ID `id`."
  [id & fields]
  (when-let [table (t2/select-one (into [:model/Table :id] fields) id)]
    (when (mi/can-read? table)
      table)))

(defn get-card
  "Retrieve the card with `id` from the app DB."
  [id]
  (-> (t2/select-one :model/Card :id id)
      api/read-check))

(defn get-metrics-and-models
  "Retrieve the metric and model cards from the collection with name `collection-name` from the app DB."
  [collection-name]
  (let [collection-query {:select [:id]
                          :from :collection
                          :where [:= :name collection-name]}]
    (-> (t2/select :model/Card
                   :type [:in [:metric :model]]
                   :collection_id [:in collection-query]
                   :archived false
                   {:order-by [:id]})
        (->> (filter mi/can-read?)))))

(comment
  (binding [api/*current-user-permissions-set* (delay #{"/"})]
    (let [collection-name "__METABOT__"]
      (map #(dissoc % :result_metadata :creator :collection) (get-metrics-and-models collection-name))))
  -)
