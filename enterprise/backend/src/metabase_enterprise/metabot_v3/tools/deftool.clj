(ns metabase-enterprise.metabot-v3.tools.deftool
  "Macro for defining metabot tool endpoints with standard encoding/decoding behavior.

  The `deftool` macro provides a declarative way to define tool endpoints that eliminates
  the boilerplate previously repeated across all tool endpoints. It handles:
  - Logging incoming requests and outgoing responses
  - Encoding arguments from snake_case to kebab-case
  - Decoding results from kebab-case to snake_case
  - Attaching `conversation_id` to responses
  - Extracting `:metabot-id` from the request and including it in arguments"
  (:require
   [malli.core :as mc]
   [malli.transform :as mtx]
   [metabase-enterprise.metabot-v3.context :as metabot-v3.context]
   [metabase.api.macros :as api.macros]
   [metabase.util.malli.registry :as mr]
   [metabase.util.malli.schema :as ms]))

;;; ---------------------------------------------------- Schemas ----------------------------------------------------

(mr/def ::tool-request
  "Base schema for all tool requests. Contains the conversation ID."
  [:map [:conversation_id ms/UUIDString]])

(def ^:private request-transformer
  "Transformer for encoding tool request arguments (snake_case -> kebab-case)."
  (mtx/transformer {:name :tool-api-request}))

(def ^:private response-transformer
  "Transformer for decoding tool response data (kebab-case -> snake_case)."
  (mtx/transformer {:name :tool-api-response}))

(defn invoke-tool
  "Core tool invocation logic. Handles encoding, calling the handler, decoding, and logging.

  This is the runtime implementation called by endpoints generated by `deftool`.

  Arguments:
  - `body` - The request body containing `:arguments` and `:conversation_id`
  - `request` - The Ring request map (used to extract `:metabot-v3/metabot-id`)
  - `opts` - A map with:
    - `:api-name` - Keyword name for logging (e.g., `:field-values`)
    - `:args-schema` - Malli schema for encoding arguments (optional)
    - `:result-schema` - Malli schema for decoding results (optional)
    - `:handler` - Function to call with encoded arguments (receives args map with :metabot-id)
    - `:skip-decode?` - If true, skip decoding the result

  The handler receives a single map argument containing the encoded args plus `:metabot-id`
  (extracted from the request). For no-args tools, the handler receives just `{:metabot-id ...}`."
  [{:keys [arguments conversation_id] :as body}
   request
   {:keys [api-name args-schema result-schema handler skip-decode?]}]
  (metabot-v3.context/log (assoc body :api api-name) :llm.log/llm->be)
  (let [metabot-id   (:metabot-v3/metabot-id request)
        encoded-args (cond-> (if args-schema
                               (mc/encode args-schema arguments request-transformer)
                               {})
                       metabot-id (assoc :metabot-id metabot-id))
        raw-result   (handler encoded-args)
        result       (if (or skip-decode? (nil? result-schema))
                       raw-result
                       (mc/decode result-schema raw-result response-transformer))]
    (doto (assoc result :conversation_id conversation_id)
      (metabot-v3.context/log :llm.log/be->llm))))

(defmacro deftool
  "Define a tool endpoint with standard encoding/decoding and logging behavior.

  This macro generates a `defendpoint` with the boilerplate needed for tool endpoints:
  - Logging incoming requests and outgoing responses
  - Encoding arguments from snake_case to kebab-case (via `:tool-api-request` transformer)
  - Decoding results from kebab-case to snake_case (via `:tool-api-response` transformer)
  - Attaching `conversation_id` to responses
  - Extracting `:metabot-id` from the request and including it in the args map

  Options:
    :args-schema    - Malli schema for arguments (optional - omit for no-args tools)
    :args-optional? - If true, arguments are marked as optional in the request body schema
    :result-schema  - Malli schema for result (required for response schema generation)
    :handler        - Function to call. Always receives an args map (may be empty for no-args tools)
                      with `:metabot-id` included when available from the request.
    :skip-decode?   - If true, return handler result without decoding through `:result-schema`

  Examples:

    ;; Standard tool with args and result schemas
    (deftool \"/field-values\"
      \"Return statistics and/or values for a given field.\"
      {:args-schema   ::field-values-arguments
       :result-schema ::field-values-result
       :handler       metabot-v3.tools.field-stats/field-values})

    ;; No-args tool (handler still receives {:metabot-id ...})
    (deftool \"/get-current-user\"
      \"Get information about the current user.\"
      {:result-schema ::get-current-user-result
       :handler       metabot-v3.dummy-tools/get-current-user})

    ;; Tool that skips result decoding (handler returns final shape)
    (deftool \"/create-dashboard-subscription\"
      \"Create a dashboard subscription.\"
      {:args-schema   ::create-dashboard-subscription-arguments
       :result-schema [:map [:output :string]]
       :handler       create-dashboard-subscription
       :skip-decode?  true})

    ;; Tool that uses metabot-id from the request
    (deftool \"/search\"
      \"Search for entities.\"
      {:args-schema    ::search-arguments
       :args-optional? true
       :result-schema  ::search-result
       :handler        (fn [{:keys [metabot-id] :as args}]
                         (search-impl metabot-id args))})"
  [route docstring {:keys [args-schema args-optional? result-schema handler skip-decode?]}]
  (let [api-name        (keyword (subs route 1)) ; "/field-values" -> :field-values
        body-schema     (if args-schema
                          (if args-optional?
                            `[:merge [:map [:arguments {:optional true} ~args-schema]] ::tool-request]
                            `[:merge [:map [:arguments ~args-schema]] ::tool-request])
                          `::tool-request)
        response-schema `[:merge ~result-schema ::tool-request]
        tool-opts       {:api-name      api-name
                         :args-schema   args-schema
                         :result-schema result-schema
                         :handler       handler
                         :skip-decode?  skip-decode?}]
    `(api.macros/defendpoint :post ~route :- ~response-schema
       ~docstring
       [~'_route-params ~'_query-params ~'body :- ~body-schema ~'request]
       (invoke-tool ~'body ~'request ~tool-opts))))
