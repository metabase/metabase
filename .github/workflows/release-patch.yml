name: Release 1b - Auto Patch
run-name: Patch Release ${{ inputs.version }}

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Major Metabase version (e.g. 45, 52, 68)'
        type: number
        required: true
      override_sha:
        description: DANGEROUSLY allow releasing from this commit sha, regardless of the state of CI (can be empty)
        type: string
        required: false
        default: ''
  schedule:
    - cron: '0 21 * * 1-5' # every weekday at 4 pm EST/5 pm EDT

jobs:
  auto-patch-trigger:
    # don't run this workflow on a cron for forks
    if: ${{ github.event_name != 'schedule' || github.repository == 'metabase/metabase' }}
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: release
      - name: Install bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: "1.3.7"
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Prepare build scripts
        run: bun install --cwd release --frozen-lockfile && bun run --cwd release build
      - name: Trigger auto-patch
        uses: actions/github-script@v7
        with:
          script: | # js
            const {
              getLatestGreenCommit,
              getNextPatchVersion,
              hasCommitBeenReleased,
            } = require('${{ github.workspace }}/release/dist/index.cjs');

            const currentRelease = Number('${{ vars.CURRENT_VERSION }}');
            const lastRelease = currentRelease - 1;
            const AUTO_RELEASE_VERSIONS = [lastRelease, currentRelease];

            async function releasePatchFor(majorVersion, overrideSha) {
              const nextPatch = await getNextPatchVersion({
                github,
                owner: context.repo.owner,
                repo: context.repo.repo,
                majorVersion,
              });

              const releaseCommit = overrideSha || await getLatestGreenCommit({
                github,
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: `release-x.${majorVersion}.x`,
              });

              const hasBeenReleased = await hasCommitBeenReleased({
                github,
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: releaseCommit,
                majorVersion: Number(majorVersion),
              });

              console.log(
                { nextPatch, releaseCommit, hasBeenReleased }
              );

              if (nextPatch && releaseCommit && !hasBeenReleased) {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'tag-for-release.yml',
                  ref: 'refs/heads/master',
                  inputs: {
                    commit: releaseCommit,
                    version: nextPatch,
                    auto: true,
                  }
                }).catch(console.error);
              } else {
                console.error(`No new patch version or no green commit found for v${majorVersion}`);
              }
            }

            if (context.eventName === 'workflow_dispatch') {
              const inputVersion = Number(context.payload.inputs.version);

              if (typeof inputVersion !== 'number') {
                console.log('Invalid version number', inputVersion);
                throw new Error(`Invalid version number: ${inputVersion}`);
              }

              // only allow overriding the commit SHA for workflow_dispatch events with a provided sha
              const overrideSha = String(context.payload?.inputs?.override_sha ?? '').trim();
              const isValidOverride = overrideSha.length === 40;

              if (!isValidOverride && overrideSha.length > 0) {
                throw new Error(`Invalid override SHA provided: ${overrideSha}`);
              }

              await releasePatchFor(inputVersion, isValidOverride ? overrideSha : undefined);
            } else { // scheduled release of AUTO_RELEASE_VERSIONS
              await Promise.all(AUTO_RELEASE_VERSIONS.map(version => releasePatchFor(version)));
            }
