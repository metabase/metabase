name: "Claude Code Bug Fix"

on:
  issues:
    types:
      - labeled
  pull_request_review:
    types:
      - submitted
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to fix"
        required: true
        type: string
      override_employee_check:
        description: "Override employee check for issue creator"
        required: false
        default: false
        type: boolean

jobs:
  check-employee-and-issue:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    permissions:
      contents: read
      issues: read
    if: |
      (github.event_name == 'issues' && github.event.label.name == 'Claude Bug Fix' && github.event.issue.state == 'open') ||
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'pull_request_review' && github.event.review.state == 'changes_requested' && startsWith(github.event.pull_request.head.ref, 'claude-fix/'))
    outputs:
      is_employee: ${{ steps.check_employee.outputs.is_employee }}
      issue_number: ${{ steps.get_issue.outputs.issue_number }}
      issue_data: ${{ steps.get_issue.outputs.issue_data }}
      issue_comments: ${{ steps.get_issue.outputs.issue_comments }}
      pr_reviews: ${{ steps.get_issue.outputs.pr_reviews }}
      trigger_type: ${{ steps.get_issue.outputs.trigger_type }}
    steps:
      - name: Generate GitHub App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ secrets.METABASE_BOT_APP_ID }}
          private-key: ${{ secrets.METABASE_BOT_APP_PRIVATE_KEY }}

      - name: Get issue data
        id: get_issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            let issueNumber, issueData, prReviews = [];
            const triggerType = context.eventName;

            if (context.eventName === 'issues') {
              // Original issue label event
              issueNumber = context.payload.issue.number;
              issueData = context.payload.issue;
            } else if (context.eventName === 'workflow_dispatch') {
              // Manual trigger with issue number input
              issueNumber = parseInt('${{ github.event.inputs.issue_number }}');
              const { data } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              issueData = data;
            } else if (context.eventName === 'pull_request_review') {
              // Pull request review trigger - extract issue number from branch or PR body
              const prNumber = context.payload.pull_request.number;
              const branchName = context.payload.pull_request.head.ref;
              
              // Extract issue number from branch name (format: claude-fix/issue-{number}-{title})
              const branchMatch = branchName.match(/claude-fix\/issue-(\d+)-/);
              if (branchMatch) {
                issueNumber = parseInt(branchMatch[1]);
              } else {
                // Fallback: extract from PR body
                const { data: prData } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                const bodyMatch = prData.body.match(/#(\d+)/);
                if (bodyMatch) {
                  issueNumber = parseInt(bodyMatch[1]);
                } else {
                  core.setFailed('Could not extract issue number from branch name or PR body');
                  return;
                }
              }
              
              // Get the original issue data
              const { data } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              issueData = data;
              
              // Get PR reviews
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Filter to reviews that request changes by Metabase employees
              const membershipCache = new Map();
              for (const review of reviews) {
                if (review.state === 'CHANGES_REQUESTED') {
                  const username = review.user.login;
                  
                  // Check if reviewer is employee
                  let isEmployee = false;
                  if (membershipCache.has(username)) {
                    isEmployee = membershipCache.get(username);
                  } else {
                    try {
                      const { data: membership } = await github.rest.orgs.getMembershipForUser({
                        org: 'metabase',
                        username: username
                      });
                      isEmployee = membership.state === 'active';
                      membershipCache.set(username, isEmployee);
                    } catch (error) {
                      if (error.status === 404) {
                        membershipCache.set(username, false);
                      }
                    }
                  }
                  
                  if (isEmployee) {
                    prReviews.push(review);
                    console.log(`Including review with changes requested by employee: ${username}`);
                  }
                }
              }
            }

            // Fetch issue comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            // Filter comments to only include those by Metabase employees
            const employeeComments = [];
            const membershipCache = new Map(); // Cache to avoid duplicate API calls

            for (const comment of comments) {
              const username = comment.user.login;
              
              // Check cache first
              if (membershipCache.has(username)) {
                const isEmployee = membershipCache.get(username);
                if (isEmployee) {
                  employeeComments.push(comment);
                  console.log(`Including comment by employee (cached): ${username}`);
                } else {
                  console.log(`Skipping comment by non-employee (cached): ${username}`);
                }
                continue;
              }
              
              // Not in cache, check membership
              try {
                const { data: membership } = await github.rest.orgs.getMembershipForUser({
                  org: 'metabase',
                  username: username
                });
                
                const isEmployee = membership.state === 'active';
                membershipCache.set(username, isEmployee);
                
                if (isEmployee) {
                  employeeComments.push(comment);
                  console.log(`Including comment by employee: ${username}`);
                } else {
                  console.log(`Skipping comment by non-employee: ${username}`);
                }
              } catch (error) {
                if (error.status === 404) {
                  membershipCache.set(username, false);
                  console.log(`Skipping comment by non-employee: ${username}`);
                } else if (error.status === 403) {
                  console.error(`Permission denied checking membership for ${username}. GitHub App may lack organization member permissions.`);
                  core.setFailed(`Unable to check organization membership: ${error.message}`);
                  return;
                } else {
                  console.error(`Error checking membership for ${username}:`, error);
                  core.setFailed(`Failed to check organization membership: ${error.message}`);
                  return;
                }
              }
            }

            core.setOutput('issue_number', issueNumber);
            core.setOutput('issue_data', JSON.stringify(issueData));
            core.setOutput('issue_comments', JSON.stringify(employeeComments));
            core.setOutput('pr_reviews', JSON.stringify(prReviews));
            core.setOutput('trigger_type', triggerType);

            console.log(`Trigger type: ${triggerType}`);
            console.log(`Issue #${issueNumber}: ${issueData.title}`);
            console.log(`Issue author: ${issueData.user.login}`);
            console.log(`Issue has ${comments.length} total comments, ${employeeComments.length} from employees`);
            if (prReviews.length > 0) {
              console.log(`Found ${prReviews.length} reviews requesting changes from employees`);
            }

      - name: Check if issue creator is a Metabase employee
        id: check_employee
        uses: actions/github-script@v7
        env:
          ISSUE_DATA: ${{ steps.get_issue.outputs.issue_data }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const issueData = JSON.parse(process.env.ISSUE_DATA);
            const issueAuthor = issueData.user.login;
            const overrideEmployeeCheck = '${{ github.event.inputs.override_employee_check }}' === 'true';

            // Check if we should override the employee check (only for workflow_dispatch)
            if (context.eventName === 'workflow_dispatch' && overrideEmployeeCheck) {
              console.log(`Employee check overridden for issue creator: ${issueAuthor}. Proceeding with bug fix automation.`);
              core.setOutput('is_employee', 'true');
              return;
            }

            try {
              // Check if user is a member of the metabase organization (including private members)
              const { data: membership } = await github.rest.orgs.getMembershipForUser({
                org: 'metabase',
                username: issueAuthor
              });

              if (membership.state === 'active') {
                console.log(`User ${issueAuthor} is an active member of the Metabase organization. Proceeding with bug fix automation.`);
                core.setOutput('is_employee', 'true');
              } else {
                console.log(`User ${issueAuthor} is not an active member of the Metabase organization. Skipping bug fix automation.`);
                core.setOutput('is_employee', 'false');
              }
            } catch (error) {
              if (error.status === 404) {
                console.log(`User ${issueAuthor} is not a member of the Metabase organization. Skipping bug fix automation.`);
              } else {
                console.error('Error checking organization membership:', error);
              }
              core.setOutput('is_employee', 'false');
            }

  auto-fix-bug:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
    needs: check-employee-and-issue
    if: needs.check-employee-and-issue.outputs.is_employee == 'true' || github.event.inputs.override_employee_check == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up git configuration
        run: |
          git config --global user.name "Claude Code[bot]"
          git config --global user.email "noreply@anthropic.com"

      - name: Prepare dynamic issue info
        id: prepare_issue_info
        uses: actions/github-script@v7
        env:
          ISSUE_DATA: ${{ needs.check-employee-and-issue.outputs.issue_data }}
          ISSUE_COMMENTS: ${{ needs.check-employee-and-issue.outputs.issue_comments }}
          PR_REVIEWS: ${{ needs.check-employee-and-issue.outputs.pr_reviews }}
          TRIGGER_TYPE: ${{ needs.check-employee-and-issue.outputs.trigger_type }}
        with:
          script: |
            const issueData = JSON.parse(process.env.ISSUE_DATA);
            const issueComments = JSON.parse(process.env.ISSUE_COMMENTS);
            const prReviews = JSON.parse(process.env.PR_REVIEWS);
            const triggerType = process.env.TRIGGER_TYPE;
            const issueNumber = '${{ needs.check-employee-and-issue.outputs.issue_number }}';

            // Convert issue title to kebab case
            const issueTitle = issueData.title || 'untitled';
            const kebabTitle = issueTitle
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '')
              .replace(/-+/g, '-')
              .substring(0, 50); // Limit length

            // Create base branch name
            const baseBranchName = `claude-fix/issue-${issueNumber}-${kebabTitle}`;
            core.exportVariable('BASE_BRANCH_NAME', baseBranchName);

            // Export issue info for the prompt
            core.exportVariable('ISSUE_NUMBER', issueNumber);
            core.exportVariable('ISSUE_TITLE', issueData.title);
            core.exportVariable('ISSUE_AUTHOR', issueData.user.login);
            core.exportVariable('ISSUE_CREATED', issueData.created_at);
            core.exportVariable('ISSUE_BODY', issueData.body || 'No description provided');
            core.exportVariable('TRIGGER_TYPE', triggerType);

            // Format comments for the prompt
            let commentsText = '';
            if (issueComments.length > 0) {
              commentsText = issueComments.map(comment => 
                `**Comment by @${comment.user.login} on ${comment.created_at}:**\n${comment.body}`
              ).join('\n\n---\n\n');
            }
            core.exportVariable('ISSUE_COMMENTS_FORMATTED', commentsText);

            // Format PR reviews for the prompt
            let reviewsText = '';
            if (prReviews.length > 0) {
              reviewsText = prReviews.map(review => 
                `**Review by @${review.user.login} on ${review.submitted_at} (Changes Requested):**\n${review.body || 'No review comment provided'}`
              ).join('\n\n---\n\n');
            }
            core.exportVariable('PR_REVIEWS_FORMATTED', reviewsText);

      - name: Determine branch strategy
        run: |
          # Use the base branch name (no counters)
          BRANCH_NAME="${{ env.BASE_BRANCH_NAME }}"

          # Check if this exact branch already exists
          if git branch -r --list "origin/${BRANCH_NAME}" | grep -q .; then
            echo "Branch already exists: $BRANCH_NAME"
            echo "Will push to existing branch and skip PR creation"
            echo "BRANCH_EXISTS=true" >> $GITHUB_ENV
          else
            echo "Creating new branch: $BRANCH_NAME"
            echo "Will create new PR"
            echo "BRANCH_EXISTS=false" >> $GITHUB_ENV
          fi

          # Export the branch name
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Prepare bug fix prompt
        id: prepare_prompt
        run: |
          # Prepare the prompt for Claude based on trigger type
          if [ "${{ env.TRIGGER_TYPE }}" = "pull_request_review" ]; then
            # Review-triggered prompt
            cat << 'EOF' >> $GITHUB_ENV
            BUG_FIX_PROMPT<<PROMPT_END
            You are helping to improve an automated bug fix based on reviewer feedback for GitHub issue #${{ env.ISSUE_NUMBER }}.

            ## Original Bug Report
            **Title:** ${{ env.ISSUE_TITLE }}
            **Reporter:** ${{ env.ISSUE_AUTHOR }}
            **Created:** ${{ env.ISSUE_CREATED }}

            **Description:**
            ${{ env.ISSUE_BODY }}

            **Comments:**
            ${{ env.ISSUE_COMMENTS_FORMATTED }}

            ## Previous Fix Attempt - NEEDS IMPROVEMENT
            A previous automated fix was attempted for this issue, but reviewers have requested changes.

            ## Reviewer Feedback (MUST ADDRESS)
            ${{ env.PR_REVIEWS_FORMATTED }}

            ## Instructions
            1. **Review the current PR branch** - Examine the existing fix attempt on branch `${{ env.BRANCH_NAME }}`
            2. **Understand reviewer feedback** - Carefully read all review comments above
            3. **Address specific concerns** - Modify the existing fix to address reviewer feedback
            4. **Test thoroughly** - Run tests using commands in CLAUDE.md:
               - JavaScript/TypeScript: `yarn test-unit path/to/file.unit.spec.js`
               - Clojure: `clojure -X:dev:test :only namespace/test-name`
               - Lint: `yarn lint-eslint-pure` for JS/TS, `./bin/mage kondo <file>` for Clojure

            ## Important Guidelines
            - **PRIORITY**: Address reviewer feedback first and foremost
            - Follow the development patterns in CLAUDE.md
            - Keep changes minimal and focused on reviewer concerns
            - Don't commit changes - leave that for the workflow
            - The existing PR will be updated with your improvements

            ## Scratchpad Directory
            A `.claude-scratchpad/` directory has been created for your temporary files:
            - Use this directory for ALL temporary verification files
            - Only modify actual production code in the main repository directories
            - The scratchpad will be cleaned up automatically

            Start by examining the current fix and understanding exactly what reviewers want changed.
            PROMPT_END
            EOF
          else
            # Original issue-triggered prompt
            cat << 'EOF' >> $GITHUB_ENV
            BUG_FIX_PROMPT<<PROMPT_END
            You are helping to automatically fix a bug reported in GitHub issue #${{ env.ISSUE_NUMBER }}.

            ## Bug Report Details
            **Title:** ${{ env.ISSUE_TITLE }}
            **Reporter:** ${{ env.ISSUE_AUTHOR }}
            **Created:** ${{ env.ISSUE_CREATED }}

            **Description:**
            ${{ env.ISSUE_BODY }}

            **Comments:**
            ${{ env.ISSUE_COMMENTS_FORMATTED }}

            ## Instructions
            1. **Analyze the issue description and comments** - Understand what the issue is describing
              a. Pay particular attention to reproduction steps and if there's an agreed upon fix. 
            2. **Search the codebase** - Use Grep and Glob tools to find relevant files
            3. **Implement a fix** - Follow existing code patterns and conventions
            4. **Test the fix** - Run appropriate tests using the commands in CLAUDE.md:
               - JavaScript/TypeScript: `yarn test-unit path/to/file.unit.spec.js`
               - Clojure: `clojure -X:dev:test :only namespace/test-name`
               - Lint: `yarn lint-eslint-pure` for JS/TS, `./bin/mage kondo <file>` for Clojure
            5. **Verify the fix** - Ensure tests pass and code follows conventions

            ## Important Guidelines
            - Follow the development patterns in CLAUDE.md
            - Write failing tests first, then fix them
            - Work in small, testable increments
            - Don't commit changes - leave that for the workflow
            - IMPORTANT: Focus only on fixing the reported bug, don't make unrelated changes

            ## Scratchpad Directory
            A `.claude-scratchpad/` directory has been created for your temporary files:
            - Use this directory for ALL temporary verification files. However, prefer using production test files rather than adhoc ones.
            - Only modify actual production code in the main repository directories
            - The scratchpad will be cleaned up automatically - nothing from it will be committed

            Start by understanding the bug and then systematically work toward a solution.
            PROMPT_END
            EOF
          fi

      - name: Create scratchpad directory for Claude
        run: |
          # Create a scratchpad directory for Claude to use for temporary files
          mkdir -p .claude-scratchpad
          echo "Scratchpad directory created for Claude's temporary verification files"

      - name: Generate GitHub App Token for Claude
        uses: actions/create-github-app-token@v1
        id: claude-app-token
        with:
          app-id: ${{ secrets.METABASE_BOT_APP_ID }}
          private-key: ${{ secrets.METABASE_BOT_APP_PRIVATE_KEY }}

      - name: Generate Bug Fix with Claude Code
        uses: anthropics/claude-code-action@beta
        with:
          mode: agent
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.claude-app-token.outputs.token }}
          direct_prompt: ${{ env.BUG_FIX_PROMPT }}
          timeout_minutes: "25"
          allowed_tools: "Bash(yarn test-unit*),Bash(yarn lint-eslint-pure),Bash(./bin/mage*),Bash(clojure*),Bash(find*),Bash(ls*),Bash(grep*),Write,Read,Glob,Grep,Edit,MultiEdit"
          disallowed_tools: "Bash(git commit*),Bash(git push*),Bash(gh*)"

      - name: Clean up scratchpad directory
        run: |
          # Remove the scratchpad directory so its contents don't get committed
          rm -rf .claude-scratchpad/
          # Remove output file generated by Claude Code action
          rm -f output.txt
          echo "Scratchpad directory and action output files cleaned up"

      - name: Check for changes and analysis
        id: check_changes
        run: |
          # Now check for actual code changes (excluding analysis file)
          if [ -n "$(git status --porcelain)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected:"
            git status --short
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes made by Claude."
          fi

      - name: Get issue team labels and prepare reviewers
        if: steps.check_changes.outputs.has_changes == 'true'
        id: prepare_reviewers
        uses: actions/github-script@v7
        env:
          ISSUE_DATA: ${{ needs.check-employee-and-issue.outputs.issue_data }}
        with:
          script: |
            // Get existing team labels from the issue
            const issueData = JSON.parse(process.env.ISSUE_DATA);
            const issueLabels = issueData.labels.map(label => label.name);
            const teamLabels = issueLabels.filter(label => label.startsWith('.Team/'));

            console.log('Issue labels:', issueLabels);
            console.log('Team labels found:', teamLabels);

            // Add issue creator as reviewer
            const issueCreator = issueData.user.login;

            core.setOutput('team_labels', teamLabels.join(','));
            core.setOutput('reviewers', issueCreator);

            console.log('Reviewer:', issueCreator);

      - name: Create Pull Request
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ env.BRANCH_NAME }}
          base: master
          commit-message: |
            Fix: ${{ env.ISSUE_TITLE }}

            Fixes #${{ env.ISSUE_NUMBER }}

            ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

            Co-Authored-By: Claude <noreply@anthropic.com>
          committer: "Claude Code[bot] <noreply@anthropic.com>"
          author: "Claude Code[bot] <noreply@anthropic.com>"
          title: "Fix: ${{ env.ISSUE_TITLE }}"
          body: |
            This PR automatically fixes the bug reported in #${{ env.ISSUE_NUMBER }}.

            ## Bug Report
            **Original Issue:** #${{ env.ISSUE_NUMBER }}
            **Reporter:** @${{ env.ISSUE_AUTHOR }}
            **Issue Title:** ${{ env.ISSUE_TITLE }}

            ## Automated Fix
            ðŸ¤– This fix was generated automatically by Claude Code based on the issue description.

            **Please review carefully:**
            - [ ] The fix addresses the reported issue
            - [ ] Tests pass and code follows conventions
            - [ ] No unrelated changes were introduced
            - [ ] The solution is appropriate and maintainable

            ## Next Steps
            - Review the changes and test thoroughly
            - If the fix looks good, approve and merge
            - If issues are found, either fix them or close this PR

            ---
            Closes #${{ env.ISSUE_NUMBER }}

            ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

            Co-Authored-By: Claude <noreply@anthropic.com>
          labels: |
            ${{ steps.prepare_reviewers.outputs.team_labels }}
            automated-fix
            ci skip
          reviewers: ${{ steps.prepare_reviewers.outputs.reviewers }}

      - name: Log existing branch update
        if: steps.check_changes.outputs.has_changes == 'true' && env.BRANCH_EXISTS == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('ðŸ”„ Updated existing branch: ${{ env.BRANCH_NAME }}');
            console.log('The changes have been pushed to the existing PR for this issue.');

      - name: Log analysis for no changes
        if: steps.check_changes.outputs.has_changes == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('ðŸ¤– No code changes were made by Claude.');
