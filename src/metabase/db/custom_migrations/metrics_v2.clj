(ns metabase.db.custom-migrations.metrics-v2
  (:require
   [cheshire.core :as json]
   [metabase.util :as u]
   [metabase.util.log :as log]
   [toucan2.core :as t2]))

(set! *warn-on-reflection* true)

(defn- get-metric-migration-collection
  "Get the collection used to store the questions created from the v1 metrics.
  If and only if the collection doesn't exists and the option `create?` is truthy,
  the collection is created."
  ([]
   (get-metric-migration-collection nil))
  ([{:keys [create?]}]
   (let [coll-name "Migrated Metrics v1"
         slug (u/slugify coll-name 510)
         desc "This collection and the metrics in it were automatically generated by the migration to v50."]
     (or (t2/select-one :collection :name coll-name :slug slug :description desc)
         (when create?
           (let [collection (t2/insert-returning-instance!
                             :collection
                             {:name coll-name, :slug slug, :description desc})]
             (let [all-users-group-id (t2/select-one-fn :id :permissions_group :name "All Users")]
               (t2/insert! :permissions {:object   (format "/collection/%s/read/" (:id collection))
                                         :group_id all-users-group-id}))
             collection))))))

(defn- get-backup-collection
  ([]
   (get-backup-collection nil))
  ([{:keys [create? parent]}]
   (let [coll-name "Migrated Metrics v1 - backup"
         slug (u/slugify coll-name 510)
         desc "This collection contains the queries rewritten by the migration to v50."]
     (or (t2/select-one :collection :name coll-name :slug slug :description desc)
         (when create?
           (t2/insert-returning-instance!
            :collection
            {:name coll-name, :slug slug, :description desc
             :location (str "/" (:location parent) "/")}))))))

(defn- format-backup-description
  [card]
  (str "#" (:id card) " " (:description card)))

(defn- parse-backup-description
  [description]
  (when-let [[_ id desc] (re-matches #"#(\d+) (.*)" description)]
    [(parse-long id) desc]))

(defn- backup-card
  [card backup-coll]
  (let [backup (-> card
                   (dissoc :id)
                   (assoc :collection_id (:id backup-coll)
                          ;; TODO remove this unless needed for rollback
                          :description (format-backup-description card)))]
    (t2/insert! :report_card backup)))

(defn- restore-card
  [card]
  (if-let [[id desc] (parse-backup-description card)]
    (t2/update! :report_card (assoc card :id id :description desc))
    (log/warnf "card with ID %s and name `%s' is not a backup a card" (:id card) (:name card))))

(defn- add-metric-id
  "Add `id` (the ID of the metric being migrated) to `description`.
  This ID is parsed from the description during rollback. See [[split-metric-id]]."
  [description id]
  (str description " (Migrated from metric " id ".)"))

(defn- convert-metric-v2
  "Convert a metric v2 question from `metric-v1` defined on a table in the
  database with ID `db-id`.
  The :collection_id property is not set and the question is not persisted."
  [metric-v1 db-id]
  (let [definition (json/parse-string (:definition metric-v1) true)
        dataset-query {:type :query
                       :database db-id
                       :query definition}]
    (-> metric-v1
        (select-keys [:archived :created_at :creator_id :database_id
                      :description :name :table_id])
        (update :description add-metric-id (:id metric-v1))
        (assoc :dataset_query (json/generate-string dataset-query)
               :enable_embedding false
               :query_type "query"
               :type "metric"
               :parameters "[]"
               :parameter_mappings "[]"
               :visualization_settings "{}"
               :display "line"))))

;; TODO prevent inserting duplicates if a partial migration is retried
;; (not sure if such a thing can happen with liquibase)
(defn- create-metric-v2
  "Create and persist a metric v2 question from `metric-v1` in `metric-v2-coll`."
  [metric-v1 metric-v2-coll]
  (let [db-id (t2/select-one-fn :db-id :metabase_table (:table_id metric-v1))
        card (-> metric-v1
                 (convert-metric-v2 db-id)
                 (assoc :collection_id (:id metric-v2-coll)))]
    (t2/insert-returning-instance! :report_card card)))

(defn- metric-ref->id
  "If `expr` is a metric reference expression, return the ID of the referenced metric.
  Returns nil otherwise."
  [expr]
  (when (and (vector? expr)
             (= (get expr 0) "metric"))
    (get expr 1)))

(defn- replace-metric-refs
  "Replaces the IDs in metric references contained in `expr` with the :id properties
  of the corresponding entities in `id->entity`. It the entity has an :alias, it is
  set as :join-alias.
  `expr` is an MBQL aggregation expression or a part of it.
  The mapping is from metric IDs to v2 metric cards.
  Returns a pair with the rewritten expression in the first element and the set
  of IDs replaced in the second."
  [expr id->entity]
  (if-not (vector? expr)
    [expr #{}]
    (if-let [id (metric-ref->id expr)]
      (let [{mapped-id :id, alias :alias} (id->entity id)]
        [(cond-> (assoc expr 1 mapped-id)
           alias (conj {:join-alias alias}))
         #{id}])
      (reduce (fn [[rewritten ids] sub-expr]
                (let [[sub-rewritten sub-ids] (replace-metric-refs sub-expr id->entity)]
                  [(conj rewritten sub-rewritten) (into ids sub-ids)]))
              [[] #{}]
              expr))))

(defn- rewrite-single-metric-query
  [query rewritten-aggregation metric-id->metric-card]
  (assoc query
         :aggregation rewritten-aggregation
         :source-table (str "card__" (-> metric-id->metric-card first val :id))))

(defn- collect-join-aliases
  [query]
  (if-let [joins (:joins query)]
    (-> #{}
        (into (map :join-alias) joins)
        (into (mapcat (comp collect-join-aliases :source-query) joins)))
    #{}))

(defn- table-fields
  [table-id]
  (t2/select :metabase_field :table_id table-id))

(defn- get-pk-columns
  "Get the primary key fields of the table with ID `table-id`.

  We assume that there are no duplicate rows, and consider the set of all fields
  a primary key. This is not necessarily true, and when it's not, the migrated
  query might produce results different from the original query.

  V1 metrics can only be used at the first stage and when the source is a real
  table."
  [table-id]
  {:pre [(pos-int? table-id)]}
  (let [all-fields (table-fields table-id)
        pk-fields (filter #(= (:semantic_type %) "type/PK") all-fields)]
    (if (seq pk-fields)
      pk-fields
      all-fields)))

(defn- unique-join-alias
  [alias used-aliases]
  (if (contains? used-aliases alias)
    (->> (range 2)
         (map #(str alias "_" %))
         (remove used-aliases)
         first)
    alias))

(defn- metric-card-joins
  "Returns a map mapping the metric IDs to their joins for each metric card
  in `metric-cards` to be added to `query`. (This is possible, because it's
  impossible to have a v1 metric multiple times in a query.)
  Each generated join queries the metric card, has a unique join alias based
  on the name of the metric and a condition matching all PK columns of the
  source of `query` (which must be the same as the source of the metric card).

  The generated join aliases are unique in `query`, not necessarily in the top
  level query which might be embedding `query`."
  [query metric-cards]
  (let [join-field-ids (into [] (map :id) (get-pk-columns (:source-table query)))]
    (first
     (reduce
      (fn metric-join-generator [[metric-id->join used-join-aliases] metric-card]
        (let [alias (unique-join-alias (u/slugify (:name metric-card)) used-join-aliases)
              card-id (:id metric-card)
              condition (into [:and]
                              (map (fn [id]
                                     [:= [:field id] [:field id {:join-alias alias}]]))
                              join-field-ids)
              join {:source-table (str "card__" card-id)
                    :alias alias
                    :strategy :inner-join
                    :fields :none
                    :condition condition}]
          [(assoc metric-id->join card-id join) (conj used-join-aliases alias)]))
      [{} (collect-join-aliases query)]
      metric-cards))))

(defn- add-metric-aliases
  [aggregation metric-id->join]
  ;; this call to replace-metric-refs doesn't change the IDs, it only
  ;; adds the join aliases
  (replace-metric-refs aggregation (into {}
                                         (map (fn [[id join]]
                                                [id (assoc join :id id)]))
                                         metric-id->join)))

(defn- rewrite-multi-metric-query
  [query rewritten-aggregation metric-id->metric-card]
  (let [metric-id->join (metric-card-joins query (vals metric-id->metric-card))]
    (assoc query
           :joins (into (vec (:joins query)) (vals metric-id->join))
           :aggregation (add-metric-aliases rewritten-aggregation metric-id->join))))

(defn- rewrite-metric-consuming-query
  [query metric-id->metric-card]
  (if (contains? query :source-query)
    (update query :source-query rewrite-metric-consuming-query metric-id->metric-card)
    (let [aggregation (:aggregation query)
          [rewritten metric-ids] (replace-metric-refs aggregation metric-id->metric-card)]
      (if (not= rewritten aggregation)
        (let [rewrite-fn (if (next metric-ids)
                           rewrite-multi-metric-query
                           rewrite-single-metric-query)
              used-metrics (select-keys metric-id->metric-card metric-ids)]
          (rewrite-fn query rewritten used-metrics))
        query))))

(defn- rewrite-metric-consuming-card
  "Rewrite the question `card` replacing references to v1 metrics with references
  to the corresponding v2 metric question as specified by the mapping `metric-id->metric-card`."
  [card metric-id->metric-card]
  (let [dataset-query (json/parse-string (:dataset_query card) true)
        inner-query (:query dataset-query)
        rewritten (rewrite-metric-consuming-query inner-query metric-id->metric-card)]
    (when (not= rewritten inner-query)
      (-> card
          (assoc :dataset_query (-> dataset-query
                                    (assoc :query rewritten)
                                    json/generate-string))
          (dissoc :updated_at)))))

(defn migrate-up
  "Migrate metrics and the cards consuming them to metrics v2. This involves
  1. creating the migration collection,
  2. creating the backup collection for the metric consuming cards,
  3. creating a v2 metric cards for each v1 metric in the migration collection,
  4. creating a backup for each metric consuming card in the backup collection,
  5. rewriting the metric consuming cards to use the migrated v2 metric cards."
  []
  (when (t2/exists? :metric)
    (let [metric-v2-coll (get-metric-migration-collection {:create? true})
          backup-coll (get-backup-collection {:create? true, :parent metric-v2-coll})
          metric-id->metric-card (into {}
                                    ;; the created card should store the info necessary
                                    ;; for the reconstruction of the metric
                                    (map (juxt :id #(create-metric-v2 % metric-v2-coll)))
                                    (t2/query {:select [:m.* [:t.db_id :database_id]]
                                               :from [[:metric :m]]
                                               :left-join [[:metabase_table :t] [:= :t.id :m.table_id]]}))]
      (doseq [card (t2/select :report_card {:where [:like :dataset_query "%[\"metric\" %"]})
              :let [rewritten (rewrite-metric-consuming-card card metric-id->metric-card)]
              :when (and rewritten (not= card rewritten))]
        (backup-card card backup-coll)
        ;; TODO updating the dataset_query field only should be enough
        (t2/update! :report_card (:id card) rewritten)))))

(defn- try-deleting-collection
  [coll]
  (try
    (t2/delete! :collection :id (:id coll))
    (catch Exception _
      (log/warn "couldn't delete migration collection" (:name coll)))))

(defn migrate-down
  "Revert the migration to v2 metrics. This involves
  1. restoring the metric consuming cards from the backup,
  2. deleting the backup cards,
  3. deleting the backup collection,
  4. deleting the metric cards created by the up migration,
  5. deleting the metric migration collection."
  []
  (when-let [metric-v2-coll (get-metric-migration-collection)]
    (when-let [backup-coll (get-backup-collection)]
      (doseq [card (t2/select :report_card :collection_id (:id backup-coll))]
        (restore-card card)
        (t2/delete! :report_card :id card))
      (try-deleting-collection backup-coll))
    (doseq [metric-card (t2/select :report_card :collection_id (:id metric-v2-coll))]
      (t2/delete! :report_card :id metric-card))
    (try-deleting-collection metric-v2-coll)))

(comment
  (require '[metabase.db.connection :as mdb.connection]
           '[metabase.db.env :as mdb.env])
  (let [driver :postgres
        conn-uri "postgres://vacskamati/metabase?user=metabase&password=metasample123"
        ds-desc {:mb-db-connection-uri conn-uri}
        data-source (#'mdb.env/env->DataSource driver ds-desc)]
    (binding [mdb.connection/*application-db* (mdb.connection/application-db driver data-source)]
      #_(t2/select-one :metric)
      #_(t2/select-one :report_card)
      #_(t2/select-fn-vec (juxt :id :name :type) :collection)
      #_(t2/select :report_card {:where [:like :dataset_query "%\"metric\"%9%"]})
      #_(let [coll (get-metric-migration-collection {:create? true})
              metric (first
                      (t2/query {:select [:m.* [:t.db_id :database_id]]
                                 :from [[:metric :m]]
                                 :left-join [[:metabase_table :t] [:= :t.id :m.table_id]]
                                 :where [:= :m.id 46]}))
              card (t2/select-one :report_card :id 3691)
              v2-query (or (t2/select-one :report_card :collection_id (:id coll) :description [:like "%(Migrated from metric 46.)"])
                           (create-metric-v2 metric coll))]
          #_(get-metric-v2-cards coll)
          (rewrite-metric-consumption card {46 v2-query}))
      (let [coll (get-metric-migration-collection {:create? true})
            v2-query (t2/select-one :report_card :collection_id (:id coll) :description [:like "%(Migrated from metric 46.)"])
            metric (convert-metric-v1 v2-query)
            card (t2/select-one :report_card :id 3691)
            converted-card (rewrite-metric-consuming-card card {46 v2-query})]
        [converted-card v2-query metric]
        card
        #_(get-metric-v2-cards coll)
        #_(revert-metric-consumption converted-card {(:id v2-query) metric}))))

  (let [driver :postgres
        conn-uri "postgres://vacskamati/metabase?user=metabase&password=metasample123"
        ds-desc {:mb-db-connection-uri conn-uri}
        data-source (#'mdb.env/env->DataSource driver ds-desc)]
    (binding [mdb.connection/*application-db* (mdb.connection/application-db driver data-source)]
      #_(-> (t2/select-one :report_card :id 847)
            :dataset_query
            (json/parse-string true))
      (->> (t2/select-fn-vec :definition :metric :id [:in [49 52]])
           (map #(json/parse-string % true)))))

  (t2/select :collection :name "metrics")
  t2/query
  (get-metric-migration-collection {:create? true})
  (t2/select :permissions)
  (t2/delete! :collection :name "Migrated Metrics v1")
  0)
