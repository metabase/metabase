# This workflow is the single source of truth for generating and updating various caches used by our CI pipeline.
# It sets the fresh cache each Monday but provides a manual trigger to update it on-demand.
#
# All other jobs only restore from this cache; *they never update it*!
# They should always use `actions/cache/restore@v4` because `actions/cache@v4` would attempt to save the cache.
#
# Our agreed-upon strategy is to use a deterministic cache key based on the week of the year.
# Jobs can utilize the prior week's cache if the current week's cache is not found.
#
#
# PRINCIPLES:
#   - The cache is never wrong!
#   - Caches are immutable once created.
#   - Caches are for speeding up builds, not for correctness.
#   - It is faster to download a large cache than to re-resolve missing dependencies.
#
#
# DESIGN:
#
# 1. Prepare
#     - A job first prepares the local environment (e.g., installs JDK, Clojure, Node.js, etc.)
#     - This fetches the dependencies from the cache (if it exists) and warms up the local cache for this workflow.
# 2. Resolve
#     - The next step pre-resolves all dependencies, ensuring that the local cache is fully populated and up-to-date.
# 3. Update
#     - The final step saves the local cache back to GitHub Actions cache with a deterministic key.
#     - If a cache entry already exists for that key, it is deleted first to ensure immutability.
#
name: Cache Generator

on:
  schedule:
    - cron: "0 3 * * 1" # Mondays at 03:00 UTC
  workflow_dispatch: # manually update the cache

concurrency:
  group: cache-generator
  cancel-in-progress: true

jobs:
  get-cache-keys:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Get cache keys
        uses: ./.github/actions/get-cache-keys
        id: get-cache-keys
    outputs:
      m2-cache-key: ${{ steps.get-cache-keys.outputs.m2-cache-key }}
      node-cache-key: ${{ steps.get-cache-keys.outputs.node-cache-key }}

  generate-m2-cache:
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    needs: get-cache-keys
    env:
      M2_CACHE_KEY: ${{ needs.get-cache-keys.outputs.m2-cache-key }}
    steps:
      - uses: actions/checkout@v4
      - name: Prepare backend
        uses: ./.github/actions/prepare-backend

      # Add or remove aliases to affect the cache size and its contents.
      # Adjust to taste, then redeploy this workflow.
      - name: Pre-resolve dependencies
        run: clojure -A:build:dev:ee:ee-dev:drivers:drivers-dev:cljs -P

      - name: Update M2 cache
        uses: ./.github/actions/update-cache
        with:
          path: |
            ~/.m2
            ~/.gitlibs
          key: ${{ env.M2_CACHE_KEY }}

  generate-node-modules-cache:
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    needs: get-cache-keys
    env:
      NODE_CACHE_KEY: ${{ needs.get-cache-keys.outputs.node-cache-key }}
    steps:
      - uses: actions/checkout@v4
      # `prepare-frontend` action (1) prepares Node.js and (2) fetches the node_modules cache if it exists.
      # It then (3) runs `yarn install --frozen-lockfile --prefer-offline` which ensures the local cache is fully populated.
      # IMPORTANT: Caching node_modules after patches are already applied will break any PR that attempts to either:
      #   - upgrade a patched library
      #   - change a patch
      # Hence why we explicitly exclude patches from the cache (controlled by the `apply-patches` action input).
      - name: Install front-end dependencies
        uses: ./.github/actions/prepare-frontend
        with:
          apply-patches: "false"

      - name: Update node_modules cache
        uses: ./.github/actions/update-cache
        with:
          path: node_modules
          key: ${{ env.NODE_CACHE_KEY }}
