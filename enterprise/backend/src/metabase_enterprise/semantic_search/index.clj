(ns metabase-enterprise.semantic-search.index
  (:require
   [clojure.string :as str]
   [honey.sql :as sql]
   [honey.sql.helpers :as sql.helpers]
   [metabase-enterprise.semantic-search.embedding :as embedding]
   [metabase.analytics.core :as analytics]
   [metabase.models.interface :as mi]
   [metabase.search.core :as search]
   [metabase.util :as u]
   [metabase.util.json :as json]
   [metabase.util.log :as log]
   [nano-id.core :as nano-id]
   [next.jdbc :as jdbc]
   [toucan2.core :as t2])
  (:import
   [java.time LocalDate]
   [org.postgresql.util PGobject]))

(set! *warn-on-reflection* true)

(comment
  ((requiring-resolve 'metabase-enterprise.semantic-search.db/init-db!))
  (def db @@(requiring-resolve 'metabase-enterprise.semantic-search.db/data-source)))

(defn sql-format-quoted
  "Call [[sql/format]] with {:quoted true}.

  Ensures identifiers are quoted since the nano-ids used in temp table names when testing (and various other places)
  might contain uppercase chars or hyphens which need to be quoted."
  [honey-sql & {:as opts}]
  (sql/format honey-sql (merge opts {:quoted true})))

(def ^:dynamic *batch-size*
  "The number of documents to process per batch when updating the index."
  150)

(def ^:dynamic *vector-dimensions*
  "The number of dimensions in the vector embeddings for the current model."
  1024)

(defn- index-table-schema
  "Schema for the index table."
  [vector-dimensions]
  ;; Generate unique constraint name to avoid index name conflicts between multiple test tables
  (let [unique-constraint-name (keyword (str "unique_constraint_" (nano-id/nano-id) "_model_model_id"))]
    [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
     [:model :text :not-null]
     [:model_id :text :not-null]
     [:created_at :timestamp-with-time-zone [:default [:raw "CURRENT_TIMESTAMP"]] :not-null]
     [:creator_id :int]
     [:model_created_at :timestamp-with-time-zone]
     [:last_editor_id :int]
     [:model_updated_at :timestamp-with-time-zone]
     [:archived :boolean [:default false]]
     [:verified :boolean]
     [:official_collection :boolean]
     [:database_id :int]
     [:collection_id :int]
     [:display_type :text]
     [:legacy_input :jsonb]
     [:embedding [:raw (format "vector(%d)" vector-dimensions)] :not-null]
     [:text_search_vector :tsvector :not-null]
     [:text_search_with_native_query_vector :tsvector :not-null]
     [:content :text :not-null]
     [:metadata :jsonb]
     [[:constraint unique-constraint-name]
      [:unique [:composite :model :model_id]]]]))

(defn- format-embedding
  "Formats and validates the embedding vector for SQL insertion."
  [embedding]
  ;; Validate all values are numeric as a safe-guard against malformed/malicious embeddings
  (doseq [value embedding]
    (when-not (number? value)
      (throw (ex-info "Embedding contains non-numeric value"
                      {:invalid-value value
                       :embedding embedding}))))
  (str "'[" (str/join ", " embedding) "]'::vector"))

(defn- doc->db-record
  "Convert a document to a database record with a provided embedding."
  [embedding-vec {:keys [model id searchable_text created_at creator_id updated_at
                         last_editor_id archived verified official_collection database_id collection_id display_type legacy_input] :as doc}]
  {:model               model
   :model_id            id
   :creator_id          creator_id
   :model_created_at    created_at
   :last_editor_id      last_editor_id
   :model_updated_at    updated_at
   :archived            archived
   :verified            verified
   :official_collection official_collection
   :database_id         database_id
   :collection_id       collection_id
   :display_type        display_type
   :embedding           [:raw (format-embedding embedding-vec)]
   :content             searchable_text
   :text_search_vector (if (:name doc)
                         [:||
                          (search/weighted-tsvector "A" (:name doc))
                          (search/weighted-tsvector "B" (:searchable_text doc ""))]
                         (search/weighted-tsvector "A" (:searchable_text doc "")))
   :text_search_with_native_query_vector
   (if (:name doc)
     [:||
      (search/weighted-tsvector "A" (:name doc))
      (search/weighted-tsvector "B"
                                (str/join " " (remove str/blank? [(:searchable_text doc "")
                                                                  (:native_query doc "")])))]
     (search/weighted-tsvector "A"
                               (str/join " " (remove str/blank? [(:searchable_text doc "")
                                                                 (:native_query doc "")]))))
   :legacy_input        [:cast (json/encode legacy_input) :jsonb]
   :metadata            [:cast (json/encode doc) :jsonb]})

(defn- analytics-set-index-size!
  "Set the semantic-index-size metric to the number of rows in the index table."
  [connectable table-name]
  (try
    (->> (jdbc/execute-one! connectable
                            (-> (sql.helpers/select [:%count.* :count])
                                (sql.helpers/from (keyword table-name))
                                (sql.helpers/limit 1)
                                sql-format-quoted))
         :count
         (analytics/set! :metabase-search/semantic-index-size))
    (catch Exception e
      (log/warn e "Failed to set :metabase-search/semantic-index-size metric"))))

(defn- batch-update!
  [connectable table-name records->sql documents embeddings]
  (when (seq documents)
    (u/prog1 (transduce (comp (map (fn [[doc embedding]] (doc->db-record embedding doc)))
                              (partition-all *batch-size*)
                              (map (fn [db-records]
                                     (jdbc/execute! connectable (records->sql db-records))
                                     ;; TODO should this return (or at least log) the number of docs actually
                                     ;; updated, not just the number in the batch?
                                     (u/prog1 (->> db-records (map :model) frequencies)
                                       (log/debug "semantic search processed a batch of" (count db-records)
                                                  "documents with frequencies" <>)))))
                        (partial merge-with +)
                        (map vector documents embeddings))
      (log/info "semantic search processed" (count documents) "total documents with frequencies" <>)
      (analytics-set-index-size! connectable table-name))))

(defn- batch-delete-ids!
  [connectable table-name model ids->sql ids]
  (when (seq ids)
    (u/prog1 (->> (transduce (comp (partition-all *batch-size*)
                                   (map (fn [ids]
                                          (jdbc/execute! connectable (ids->sql ids))
                                          (u/prog1 (count ids)
                                            (log/debug "semantic search deleted a batch of" <>
                                                       "documents with model type" model)))))
                             +
                             ids)
                  (array-map model))
      (log/info "semantic search deleted" (get <> model) "total documents with model type" model)
      (analytics-set-index-size! connectable table-name))))

(defn- db-records->update-set
  [db-records]
  (let [update-keys (-> db-records first (dissoc :id :model :model_id) keys)
        excluded-kw (fn [column] (keyword (str "excluded." (name column))))]
    (zipmap update-keys (map excluded-kw update-keys))))

(defn default-index
  "Returns the default index spec for a model."
  [embedding-model]
  (let [{:keys [model-name provider vector-dimensions]} embedding-model
        ;; This is a hack to ensure we don't exceed postgres' limit of 63 chars for identifier names.
        abbreviated-model-name (embedding/model->abbrev model-name model-name)
        table-name (str "index_table_" provider "_" abbreviated-model-name "_" vector-dimensions)]
    {:embedding-model embedding-model
     :table-name table-name
     :version 0}))

(defn upsert-index!
  "Inserts or updates documents in the index table. If a document with the same
  model + model_id already exists, it will be replaced."
  [connectable index documents]
  (log/info "Populating semantic search index with" (count documents) "documents")
  (when (seq documents)
    (let [text->docs         (group-by :searchable_text documents)
          searchable-texts   (map :searchable_text documents)]
      (embedding/process-embeddings-streaming
       (:embedding-model index)
       searchable-texts
       (fn [text->embedding]
         (let [batch-documents
               (mapcat (fn [text]
                         (if-let [embedding (text->embedding text)]
                           (map #(assoc % :embedding embedding) (get text->docs text))
                           (when-let [docs (get text->docs text)]
                             (log/warn "No embedding found for" (count docs) "documents with searchable text:"
                                       {:searchable_text text
                                        :document_count (count docs)}))))
                       (keys text->embedding))]
           (batch-update!
            connectable
            (:table-name index)
            (fn [db-records]
              (-> (sql.helpers/insert-into (keyword (:table-name index)))
                  (sql.helpers/values db-records)
                  (sql.helpers/on-conflict :model :model_id)
                  (sql.helpers/do-update-set (db-records->update-set db-records))
                  sql-format-quoted))
            batch-documents
            (map :embedding batch-documents))))))))

(defn- drop-index-table-sql
  [{:keys [table-name]}]
  (-> (sql.helpers/drop-table :if-exists (keyword table-name))
      sql-format-quoted))

(defn drop-index-table!
  "Drops the index table for the given embedding model if it exists."
  [connectable index]
  (jdbc/execute! connectable (drop-index-table-sql index)))

;; We can't use full column names in the various index names, because otherwise we overflow postgres' max name length.
;; NOTE If you add a new index, add it to index-embedding-name-length-test as well
(defn- index-name
  "Returns the name for an index for the given index configuration, column, and index type."
  [index suffix]
  (str (:table-name index) suffix))

(defn hnsw-index-name
  "Returns the name for a HNSW database index for the given semantic search index configuration."
  [index]
  ;; embedding => embed
  (index-name index "_embed_hnsw_idx"))

(defn fts-index-name
  "Returns the name for a full-text database index for the given semantic search index configuration."
  [index]
  ;; text_search_vector => tsv
  (index-name index "_tsv_gin_idx"))

(defn fts-native-index-name
  "Returns the name for a full-text database index with native queries for the given semantic search index configuration."
  [index]
  ;; text_search_with_native_query_vector => tswnqv
  (index-name index "_tswnqv_gin_idx"))

(defn create-index-table-if-not-exists!
  "Ensure that the index table exists and is ready to be populated. If
  force-reset? is true, drops and recreates the table if it exists."
  [connectable index & {:keys [force-reset?] :or {force-reset? false}}]
  (try
    (let [{:keys [embedding-model table-name]} index
          _ (assert (not (re-find #"\s" table-name))
                    (format "whitespace in the table name (%s) is not currently supported" table-name))
          {:keys [vector-dimensions]}          embedding-model]
      (log/info "Creating index table" table-name)
      (jdbc/execute! connectable (sql/format (sql.helpers/create-extension :vector :if-not-exists)))
      (when force-reset? (drop-index-table! connectable index))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-table (keyword table-name) :if-not-exists)
           (sql.helpers/with-columns (index-table-schema vector-dimensions))
           sql-format-quoted))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-index
            [(keyword (hnsw-index-name index)) :if-not-exists]
            [(keyword table-name) :using-hnsw [:raw "embedding vector_cosine_ops"]])
           sql-format-quoted))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-index
            [(keyword (fts-index-name index)) :if-not-exists]
            [(keyword table-name) :using-gin :text_search_vector])
           sql-format-quoted))
      (jdbc/execute!
       connectable
       (-> (sql.helpers/create-index
            [(keyword (fts-native-index-name index)) :if-not-exists]
            [(keyword table-name) :using-gin :text_search_with_native_query_vector])
           sql-format-quoted)))
    (catch Exception e
      (throw (ex-info "Failed to create index table" {} e)))))

(comment
  (def embedding-model {:provider "ollama"
                        :model-name "mxbai-embed-large"
                        :vector-dimensions 1024})
  (def index (default-index embedding-model))
  (drop-index-table! db index)
  (create-index-table-if-not-exists! db index)
  (jdbc/execute! db ["select table_name from INFORMATION_SCHEMA.tables where table_name like 'index_table_%'"]))

(defn- search-filters
  "Generate WHERE conditions based on search context filters."
  [{:keys [archived? verified models created-at created-by last-edited-at last-edited-by table-db-id ids display-type]}]
  (let [conditions (filter some?
                           [(when (some? archived?)
                              [:= :archived archived?])
                            (when (some? verified)
                              [:= :verified verified])
                            (when (seq models)
                              [:in :model models])
                            (when (seq created-by)
                              [:in :creator_id created-by])
                            (when (seq last-edited-by)
                              [:in :last_editor_id last-edited-by])
                            (when table-db-id
                              [:= :database_id table-db-id])
                            (when (seq ids)
                              [:in :model_id (map str ids)])
                            (when (seq display-type)
                              [:in :display_type display-type])
                            (when (and created-at (:start created-at) (:end created-at))
                              [:between :model_created_at
                               (LocalDate/parse (:start created-at))
                               (LocalDate/parse (:end created-at))])
                            (when (and last-edited-at (:start last-edited-at) (:end last-edited-at))
                              [:between :model_updated_at
                               (LocalDate/parse (:start last-edited-at))
                               (LocalDate/parse (:end last-edited-at))])])]
    (when (seq conditions)
      (into [:and] conditions))))

(defn- keyword-search-query [index search-context]
  (let [filters (search-filters search-context)
        ts-search-expr (search/to-tsquery-expr (:search-string search-context))
        tsv-lang (search/tsv-language)
        vector-column (if (:search-native-query search-context)
                        :text_search_with_native_query_vector
                        :text_search_vector)]
    {:select [[:id :id]
              [:model_id :model_id]
              [:model :model]
              [:content :content]
              [:verified :verified]
              [:metadata :metadata]
              [[:raw (format "row_number() OVER (ORDER BY ts_rank_cd(%s, query) DESC)" (name vector-column))]
               :keyword_rank]]
     :from [(keyword (:table-name index))]
     ;; Using a join allows us to share the query expression between our SELECT and WHERE clauses.
     ;; This follows the same secure pattern as metabase.search.appdb.specialization.postgres/base-query
     :join [[[:raw "to_tsquery('" tsv-lang "', " [:lift ts-search-expr] ")"]
             :query] [:= 1 1]]
     :where (let [ts-query-filter [:raw (format "%s @@ query" (name vector-column))]]
              (if (seq filters)
                (into [:and ts-query-filter] [filters])
                ts-query-filter))
     :order-by [[:keyword_rank :asc]]
     :limit 100}))

(defn- semantic-search-query
  "Build a semantic search query using vector similarity."
  [index embedding search-context]
  (let [filters (search-filters search-context)
        embedding-literal (format-embedding embedding)
        max-cosine-distance 0.7
        base-query {:select [[:id :id]
                             [:model_id :model_id]
                             [:model :model]
                             [:content :content]
                             [:verified :verified]
                             [:metadata :metadata]
                             [[:raw (str "embedding <=> " embedding-literal)] :semantic_score]
                             [[:raw (str "row_number() OVER (ORDER BY embedding <=> " embedding-literal " ASC)")] :semantic_rank]]
                    :from   [(keyword (:table-name index))]
                    :where [:<= [:raw (str "embedding <=> " embedding-literal)] max-cosine-distance]
                    :order-by [[:semantic_rank :asc]]
                    :limit  100}]
    (if filters
      (update base-query :where #(into [:and] [% filters]))
      base-query)))

(defn- hybrid-search-query
  "Build a hybrid search query using vector + keyword based searches and reranking with RRF"
  [index embedding search-context]
  (let [semantic-results (semantic-search-query index embedding search-context)
        keyword-results (keyword-search-query index search-context)
        k 60
        keyword-weight 0.51
        semantic-weight 0.49
        full-query {:with [[:vector_results semantic-results]
                           [:text_results keyword-results]]
                    :select [[[:coalesce :v.id :t.id] :id]
                             [[:coalesce :v.model_id :t.model_id] :model_id]
                             [[:coalesce :v.model :t.model] :model]
                             [[:coalesce :v.content :t.content] :content]
                             [[:coalesce :v.verified :t.verified] :verified]
                             [[:coalesce :v.metadata :t.metadata] :metadata]
                             [[:coalesce :v.semantic_rank -1] :semantic_rank]
                             [[:coalesce :t.keyword_rank -1] :keyword_rank]
                             [[:+
                               [:* [:cast semantic-weight :float]
                                [:coalesce [:/ 1.0 [:+ k [:. :v :semantic_rank]]] 0]]
                               [:* [:cast keyword-weight :float]
                                [:coalesce [:/ 1.0 [:+ k [:. :t :keyword_rank]]] 0]]]
                              :rrf_rank]]
                    :from [[:vector_results :v]]
                    :full-join [[:text_results :t] [:= :v.id :t.id]]
                    :order-by [[:rrf_rank :desc]]
                    :limit 100}]
    full-query))

(defn- legacy-input-with-score
  "Fetches the legacy_input field from a result's metadata and attaches a score based on the
  embedding distance."
  [row]
  (-> (get-in row [:metadata :legacy_input])
      (assoc :score (:rrf_rank row 1.0))))

;; TODO: can the query return unqualified keys directly?
(defn- unqualify-keys
  "Remove table namespace from namespaced keywords in a result row."
  [row]
  (into {} (map (fn [[k v]] [(keyword (name k)) v]) row)))

(defn- unwrap-pgobject
  [^PGobject obj]
  (.getValue ^PGobject obj))

(defn- decode-pgobject
  "Decode a PGObject (returned from a jsonb field) into a Clojure map."
  [^PGobject obj]
  (json/decode (unwrap-pgobject obj) true))

(defn- decode-metadata
  "Decode `row`s `:metadata`."
  [row]
  (update row :metadata decode-pgobject))

(defn- filter-read-permitted
  "Returns only those documents in `docs` whose corresponding t2 instances pass an mi/can-read? check for the bound api user."
  [docs]
  (let [doc->t2-model (fn [doc] (:model (search/spec (:model doc))))
        t2-instances  (for [[t2-model docs] (group-by doc->t2-model docs)
                            ;; NOTE an "indexed-entity" (:model/ModelIndexValue) does not have an :id column. For now
                            ;; we are filtering indexed-entities out and they should not appear here.
                            t2-instance     (t2/select t2-model :id [:in (map :id docs)])]
                        t2-instance)
        doc->t2       (comp (u/index-by (juxt :id t2/model) t2-instances)
                            (fn [doc]
                              [(:id doc) (doc->t2-model doc)]))]
    (filterv (fn [doc] (some-> doc doc->t2 mi/can-read?)) docs)))

(defn- filter-by-collection
  "Filter documents based on personal collection preferences.
  Equivalent to metabase.search.filter/personal-collections-where-clause but operates on docs in memory.

  | Filter         | Personal | Others' Personal | Shared Coll. | No Coll. |
  |----------------|----------|------------------|--------------|----------|
  | all            | ✅       | ✅               | ✅           | ✅       |
  | only-mine      | ✅       | ❌               | ❌           | ❌       |
  | only           | ✅       | ✅               | ❌           | ❌       |
  | exclude        | ❌       | ❌               | ✅           | ✅       |
  | exclude-others | ✅       | ❌               | ✅           | ✅       |
  "
  [docs {:keys [filter-items-in-personal-collection current-user-id]}]
  (let [filter-type (or filter-items-in-personal-collection "all")]
    (case filter-type
      "all" docs

      "only-mine"
      (let [user-personal-collection-id (t2/select-one-pk :model/Collection :personal_owner_id [:= current-user-id])
            user-personal-location-pattern (when user-personal-collection-id (str "/" user-personal-collection-id "/"))]
        (filterv (fn [doc]
                   (when-let [collection-id (:collection_id doc)]
                     (when-let [collection (t2/select-one [:collection :personal_owner_id :location] :id collection-id)]
                       (or (= (:personal_owner_id collection) current-user-id)
                           ;; Sub-collection of user's personal collection
                           (and user-personal-location-pattern
                                (str/starts-with? (str (:location collection)) user-personal-location-pattern))))))
                 docs))

      "exclude-others"
      (let [only-mine-docs (filter-by-collection docs {:filter-items-in-personal-collection "only-mine" :current-user-id current-user-id})
            exclude-docs   (filter-by-collection docs {:filter-items-in-personal-collection "exclude" :current-user-id current-user-id})]
        (vec (concat only-mine-docs exclude-docs)))

      "only"
      (filterv (fn [doc]
                 (when-let [collection-id (:collection_id doc)]
                   (when-let [collection (t2/select-one [:collection :personal_owner_id :location] :id collection-id)]
                     (let [personal-ids (t2/select-pks-vec :model/Collection :personal_owner_id [:not= nil])
                           child-patterns (map #(str "/" % "/") personal-ids)]
                       (or (and (some? (:personal_owner_id collection))
                                (= (:location collection) "/"))
                           (some #(str/starts-with? (str (:location collection)) %) child-patterns))))))
               docs)

      "exclude"
      (filterv (fn [doc]
                 (let [collection-id (:collection_id doc)]
                   (or (nil? collection-id)
                       (when-let [collection (t2/select-one [:collection :personal_owner_id :location] :id collection-id)]
                         (let [personal-ids (t2/select-pks-vec :model/Collection :personal_owner_id [:not= nil])
                               child-patterns (map #(str "/" % "/") personal-ids)]
                           (and (nil? (:personal_owner_id collection))
                                (not (some #(str/starts-with? (str (:location collection)) %) child-patterns))))))))
               docs))))

(defn- apply-collection-filter
  "Apply personal collection filtering with logging."
  [docs search-context]
  (let [filter-type (:filter-items-in-personal-collection search-context)]
    (if (or (nil? filter-type) (= filter-type "all"))
      docs
      (let [timer (u/start-timer)
            filtered-docs (filter-by-collection docs search-context)]
        (log/debug "Collection filter" {:filter  filter-type
                                        :before  (count docs)
                                        :after   (count filtered-docs)
                                        :dropped (- (count docs) (count filtered-docs))
                                        :time_ms (u/since-ms timer)})
        filtered-docs))))

(defn query-index
  "Query the index for documents similar to the search string."
  [db index search-context]
  (let [{:keys [embedding-model]} index
        search-string (:search-string search-context)]
    (when-not (str/blank? search-string)
      (let [embedding (embedding/get-embedding embedding-model search-string)
            query     (hybrid-search-query index embedding search-context)
            xform     (comp (map unqualify-keys)
                            (map decode-metadata)
                            (map legacy-input-with-score))
            reducible (jdbc/plan db (sql-format-quoted query))]
        (comment
          (jdbc/execute! db (sql-format-quoted query)))
        (-> (transduce xform conj [] reducible)
            filter-read-permitted
            (apply-collection-filter search-context))))))

(comment
  (def embedding-model (embedding/get-configured-model))
  (def index (default-index embedding-model))
  (def search-ctx {:search-string "pasta"})
  (def embed (embedding/get-embedding embedding-model (:search-string search-ctx)))

  (keyword-search-query index search-ctx)
  (sql-format-quoted (keyword-search-query index search-ctx))
  (jdbc/execute! db (sql-format-quoted (keyword-search-query index search-ctx)))

  (semantic-search-query index embed search-ctx)
  (sql/format (semantic-search-query index embed search-ctx))
  (jdbc/execute! db (sql-format-quoted (semantic-search-query index embed search-ctx)))

  (hybrid-search-query index embed search-ctx)
  (sql-format-quoted (hybrid-search-query index embed search-ctx))
  (jdbc/execute! db (sql-format-quoted (hybrid-search-query index embed search-ctx)))

  (query-index db index search-ctx))

(defn delete-from-index!
  "Deletes documents from the index table based on model and model_ids."
  [db index model model-ids]
  (batch-delete-ids!
   db
   (:table-name index)
   model
   (fn [batch-ids]
     (-> (sql.helpers/delete-from (keyword (:table-name index)))
         (sql.helpers/where [:and
                             [:= :model model]
                             [:in :model_id batch-ids]])
         sql-format-quoted))
   model-ids))

(comment
  (def embedding-model (embedding/get-configured-model))
  (def index (default-index embedding-model))
  (create-index-table-if-not-exists! index {:force-reset? true})
  (upsert-index! db index [{:model "card"
                            :id "1"
                            :searchable_text "This is a test card"}])
  (delete-from-index! db index "card" ["1"])
  (delete-from-index! db index "dashboard" ["13"])
  ;; no user
  (query-index db index {:search-string "Copper knife"})

  #_:clj-kondo/ignore
  (require '[metabase.test :as mt])
  (mt/with-test-user :crowberto
    (doall (query-index db index {:search-string "Copper knife"}))))
