(ns metabase-enterprise.metabot-v3.tools.deftool
  "Macro for defining metabot tool endpoints with standard encoding/decoding behavior.

  The `deftool` macro provides a declarative way to define tool endpoints that eliminates
  the boilerplate previously repeated across all tool endpoints. It handles:
  - Logging incoming requests and outgoing responses
  - Encoding arguments from snake_case to kebab-case
  - Decoding results from kebab-case to snake_case
  - Attaching `conversation_id` to responses"
  (:require
   [malli.core :as mc]
   [malli.transform :as mtx]
   [metabase-enterprise.metabot-v3.context :as metabot-v3.context]
   [metabase.api.macros :as api.macros]
   [metabase.util.malli.registry :as mr]
   [metabase.util.malli.schema :as ms]))

;;; ---------------------------------------------------- Schemas ----------------------------------------------------

(mr/def ::tool-request
  "Base schema for all tool requests. Contains the conversation ID."
  [:map [:conversation_id ms/UUIDString]])

(def ^:private request-transformer
  "Transformer for encoding tool request arguments (snake_case -> kebab-case)."
  (mtx/transformer {:name :tool-api-request}))

(def ^:private response-transformer
  "Transformer for decoding tool response data (kebab-case -> snake_case)."
  (mtx/transformer {:name :tool-api-response}))

(defn invoke-tool
  "Core tool invocation logic. Handles encoding, calling the handler, decoding, and logging.

  This is the runtime implementation called by endpoints generated by `deftool`.

  Arguments:
  - `body` - The request body containing `:arguments` and `:conversation_id`
  - `opts` - A map with:
    - `:api-name` - Keyword name for logging (e.g., `:field-values`)
    - `:args-schema` - Malli schema for encoding arguments (optional)
    - `:result-schema` - Malli schema for decoding results (optional)
    - `:handler` - Function to call with encoded arguments
    - `:skip-decode?` - If true, skip decoding the result"
  [{:keys [arguments conversation_id] :as body}
   {:keys [api-name args-schema result-schema handler skip-decode?]}]
  (metabot-v3.context/log (assoc body :api api-name) :llm.log/llm->be)
  (let [encoded-args (when args-schema
                       (mc/encode args-schema arguments request-transformer))
        raw-result   (if encoded-args
                       (handler encoded-args)
                       (handler))
        result       (if (or skip-decode? (nil? result-schema))
                       raw-result
                       (mc/decode result-schema raw-result response-transformer))]
    (doto (assoc result :conversation_id conversation_id)
      (metabot-v3.context/log :llm.log/be->llm))))

(defn invoke-tool-with-request
  "Tool invocation that passes the request to the handler (for metabot-id access, etc.).

  The handler receives `(handler encoded-args conversation_id request)`.

  Arguments:
  - `body` - The request body containing `:arguments` and `:conversation_id`
  - `request` - The Ring request map
  - `opts` - Same as `invoke-tool`"
  [{:keys [arguments conversation_id] :as body}
   request
   {:keys [api-name args-schema result-schema handler skip-decode?]}]
  (metabot-v3.context/log (assoc body :api api-name) :llm.log/llm->be)
  (let [encoded-args (when args-schema
                       (mc/encode args-schema arguments request-transformer))
        raw-result   (handler encoded-args conversation_id request)
        result       (if (or skip-decode? (nil? result-schema))
                       raw-result
                       (mc/decode result-schema raw-result response-transformer))]
    (doto (assoc result :conversation_id conversation_id)
      (metabot-v3.context/log :llm.log/be->llm))))

(defmacro deftool
  "Define a tool endpoint with standard encoding/decoding and logging behavior.

  This macro generates a `defendpoint` with the boilerplate needed for tool endpoints:
  - Logging incoming requests and outgoing responses
  - Encoding arguments from snake_case to kebab-case (via `:tool-api-request` transformer)
  - Decoding results from kebab-case to snake_case (via `:tool-api-response` transformer)
  - Attaching `conversation_id` to responses

  Options:
    :args-schema    - Malli schema for arguments (optional - omit for no-args tools)
    :args-optional? - If true, arguments are marked as optional in the request body schema
    :result-schema  - Malli schema for result (required for response schema generation)
    :handler        - Function to call. Receives encoded args, or no args if `:args-schema` is nil
    :skip-decode?   - If true, return handler result without decoding through `:result-schema`
    :needs-request? - If true, handler receives `(args conversation_id request)` instead of just `(args)`

  Examples:

    ;; Standard tool with args and result schemas
    (deftool \"/field-values\"
      \"Return statistics and/or values for a given field.\"
      {:args-schema   ::field-values-arguments
       :result-schema ::field-values-result
       :handler       metabot-v3.tools.field-stats/field-values})

    ;; No-args tool
    (deftool \"/get-current-user\"
      \"Get information about the current user.\"
      {:result-schema ::get-current-user-result
       :handler       metabot-v3.dummy-tools/get-current-user})

    ;; Tool that skips result decoding (handler returns final shape)
    (deftool \"/create-dashboard-subscription\"
      \"Create a dashboard subscription.\"
      {:args-schema   ::create-dashboard-subscription-arguments
       :result-schema [:map [:output :string]]
       :handler       create-dashboard-subscription
       :skip-decode?  true})

    ;; Tool that needs access to the request (e.g., for metabot-id)
    (deftool \"/search\"
      \"Search for entities.\"
      {:args-schema    ::search-arguments
       :args-optional? true
       :result-schema  ::search-result
       :handler        search-handler
       :needs-request? true})"
  [route docstring {:keys [args-schema args-optional? result-schema handler skip-decode? needs-request?]}]
  (let [api-name        (keyword (subs route 1)) ; "/field-values" -> :field-values
        body-schema     (if args-schema
                          (if args-optional?
                            `[:merge [:map [:arguments {:optional true} ~args-schema]] ::tool-request]
                            `[:merge [:map [:arguments ~args-schema]] ::tool-request])
                          `::tool-request)
        response-schema `[:merge ~result-schema ::tool-request]
        tool-opts       {:api-name      api-name
                         :args-schema   args-schema
                         :result-schema result-schema
                         :handler       handler
                         :skip-decode?  skip-decode?}]
    (if needs-request?
      `(api.macros/defendpoint :post ~route :- ~response-schema
         ~docstring
         [~'_route-params ~'_query-params ~'body :- ~body-schema ~'request]
         (invoke-tool-with-request ~'body ~'request ~tool-opts))
      `(api.macros/defendpoint :post ~route :- ~response-schema
         ~docstring
         [~'_route-params ~'_query-params ~'body :- ~body-schema]
         (invoke-tool ~'body ~tool-opts)))))
