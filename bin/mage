#!/usr/bin/env bash

set -euo pipefail

# using relative path ./bin/bb
BB_BIN_DIR="."
BB_EXEC="${BB_BIN_DIR}/bb"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color


log_info() {
  echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
  echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warning() {
  echo -e "${YELLOW}[WARNING]${NC} $*" >&2
}

log_error() {
  echo -e "${RED}[ERROR]${NC} $*" >&2
}

dbg_info() {
  if [[ -z "${MAGE_DEBUG+}" ]]; then
    echo -e "${BLUE}[INFO]${NC} $*" >&2
  fi
}

dbg_success() {
  if [[ -z "${MAGE_DEBUG+}" ]]; then
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
  fi
}

dbg_warning() {
  if [[ -z "${MAGE_DEBUG+}" ]]; then
    echo -e "${YELLOW}[WARNING]${NC} $*" >&2
  fi
}

dbg_error() {
  if [[ -z "${MAGE_DEBUG+}" ]]; then
    echo -e "${RED}[ERROR]${NC} $*" >&2
  fi
}


# Debug function to see file content
dbg_file_content() {
  if [ -n "${MAGE_DEBUG:-}" ]; then
    local file="$1"
    echo "Content of $file:" >&2
    cat "$file" >&2
    echo "" >&2
  fi
}

# Get Babashka version from bb.edn
get_min_bb_version() {
  local edn_file="${BB_EDN_PATH:-"../bb.edn"}"
  local default_version="1.3.186"  # Fallback version

  if [ ! -f "$edn_file" ]; then
    log_warning "bb.edn not found at ${edn_file}, using default version: ${default_version}"
    echo "$default_version"
    return
  fi

  # Debug: print file content when in debug mode
  dbg_file_content "$edn_file"

  # Simple approach for the specific format :min-bb-version "x.y.z"
  bb_version=$(grep -o ':min-bb-version "[0-9]\+\.[0-9]\+\.[0-9]\+"' "$edn_file" | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+')

  if [ -z "$bb_version" ]; then
    log_warning "Could not parse min-bb-version from bb.edn, using default: ${default_version}"
    echo "$default_version"
  else
    dbg_info "Found Babashka version ${bb_version} in bb.edn"
    echo "$bb_version"
  fi
}

# Compare semantic versions
compare_versions() {
  local version1=$1
  local version2=$2

  # Split versions into arrays
  IFS='.' read -ra ver1 <<< "$version1"
  IFS='.' read -ra ver2 <<< "$version2"

  # Pad arrays to equal length
  local max_length=${#ver1[@]}
  if [ ${#ver2[@]} -gt $max_length ]; then
    max_length=${#ver2[@]}
  fi

  # Compare each component
  for ((i=0; i<$max_length; i++)); do
    local v1_component=${ver1[$i]:-0}
    local v2_component=${ver2[$i]:-0}

    # Remove leading zeros for numeric comparison
    v1_component=$(echo "$v1_component" | sed 's/^0*//')
    v2_component=$(echo "$v2_component" | sed 's/^0*//')

    # Default to 0 if empty after removing leading zeros
    v1_component=${v1_component:-0}
    v2_component=${v2_component:-0}

    if [ "$v1_component" -lt "$v2_component" ]; then
      echo "-1"  # version1 < version2
      return
    elif [ "$v1_component" -gt "$v2_component" ]; then
      echo "1"   # version1 > version2
      return
    fi
  done

  echo "0"  # Versions are equal
}

# Detect OS and architecture
detect_platform() {
  local os arch

  case "$(uname -s)" in
    Linux*)  os="linux" ;;
    Darwin*) os="macos" ;;
    *) log_error "Unsupported OS: $(uname -s)"; exit 1 ;;
  esac

  case "$(uname -m)" in
    x86_64|amd64) arch="amd64" ;;
    arm64|aarch64) arch="aarch64" ;;
    *) log_error "Unsupported architecture: $(uname -m)"; exit 1 ;;
  esac

  echo "${os}-${arch}"
}

# Download babashka if not found
install_babashka() {
  local platform tmp_dir download_url min_bb_version

  # Get required Babashka version
  min_bb_version=$(get_min_bb_version)

  log_info "Babashka not found at ${BB_EXEC}. Installing version ${min_bb_version}..."

  platform=$(detect_platform)
  log_info "Detected platform: ${platform}"

  tmp_dir=$(mktemp -d)
  dbg_info "Created temporary directory: ${tmp_dir}"

  download_url="https://github.com/babashka/babashka/releases/download/v${min_bb_version}/babashka-${min_bb_version}-${platform}.tar.gz"
  log_info "Download URL: ${download_url}"

  # Create bin directory relative to the script location
  dbg_info "Creating bin directory: ${BB_BIN_DIR}"
  mkdir -p "${BB_BIN_DIR}"

  # Download the file first
  curl -L "${download_url}" -o "${tmp_dir}/babashka.tar.gz"

  if [ ! -f "${tmp_dir}/babashka.tar.gz" ]; then
    log_error "Download failed! Could not find downloaded file"
    exit 1
  fi

  log_info "Download complete. Extracting archive..."
  tar -xzf "${tmp_dir}/babashka.tar.gz" -C "${tmp_dir}"

  # List the temp directory contents to see if extraction worked
  dbg_info "Files in temp directory after extraction:"
  ls -la "${tmp_dir}"

  if [ -f "${tmp_dir}/bb" ]; then
    dbg_info "Moving bb to ${BB_EXEC}"
    mv "${tmp_dir}/bb" "${BB_EXEC}"
    chmod +x "${BB_EXEC}"

    # Verify installation
    if [ -x "${BB_EXEC}" ]; then
      dbg_info "Testing installed binary..."
      "${BB_EXEC}" --version
      log_success "Babashka ${min_bb_version} successfully installed at ${BB_EXEC}"
    else
      log_error "Installation failed! ${BB_EXEC} is not executable"
      exit 1
    fi
  else
    log_error "Extraction failed! Could not find bb executable in extracted files - are you sure the version is correct?"
    exit 1
  fi

  rm -rf "${tmp_dir}"
}

# Check if babashka is available at ./bin/bb
check_babashka() {
  dbg_info "Checking for Babashka at ${BB_EXEC}"

  if [ -x "${BB_EXEC}" ]; then
    dbg_info "Found executable at ${BB_EXEC}"
    # Check if installed version meets minimum requirements
    local installed_version min_bb_version
    min_bb_version=$(get_min_bb_version)

    installed_version=$("${BB_EXEC}" --version 2>/dev/null | head -n 1 | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+')

    if [ -z "${installed_version}" ]; then
      log_warning "Could not determine installed Babashka version"
      return 1
    fi

    dbg_info "Installed version: ${installed_version}, Required minimum: ${min_bb_version}"

    # Proper semantic version comparison
    local comparison_result
    comparison_result=$(compare_versions "${installed_version}" "${min_bb_version}")

    if [ "$comparison_result" -lt "0" ]; then
      log_warning "Installed Babashka version ${installed_version} is older than required ${min_bb_version}"
      return 1
    fi

    dbg_success "Using Babashka ${installed_version} at ${BB_EXEC}"
    return 0
  else
    log_error "Babashka not found at ${BB_EXEC}"
    return 1
  fi
}

# Main execution
main() {
  # Find the real location of this script for relative paths
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  dbg_info "Script directory: ${SCRIPT_DIR}"

  # When checking babashka version, we need to look relative to this script
  export BB_EDN_PATH="${SCRIPT_DIR}/../bb.edn"
  dbg_info "BB_EDN_PATH set to: ${BB_EDN_PATH}"

  # Make BB_BIN_DIR relative to the script directory
  BB_BIN_DIR="${SCRIPT_DIR}"
  BB_EXEC="${BB_BIN_DIR}/bb"
  dbg_info "Babashka binary path: ${BB_EXEC}"

  # First, ensure babashka is installed in the local ./bin directory
  if ! check_babashka; then
    log_info "Babashka not found or version is too old, installing..."
    install_babashka
  fi

  # Check if BB_EXEC exists now
  if [ ! -x "${BB_EXEC}" ]; then
    log_error "Babashka binary not found at ${BB_EXEC} after installation attempt!"
    exit 1
  fi

  # Construct the path to ./bin/mage_core (sibling file to this script)
  MAGE_CORE_PATH="${SCRIPT_DIR}/mage_core"
  # log_info "mage_core path: ${MAGE_CORE_PATH}"

  # Ensure mage_core exists and is executable
  if [ ! -x "$MAGE_CORE_PATH" ]; then
    log_error "mage_core executable not found or not executable: $MAGE_CORE_PATH"
    exit 1
  fi

  # Export BB_EXEC so mage_core can find babashka
  export BB_EXEC
  dbg_info "Exported BB_EXEC=${BB_EXEC}"

  # Execute mage_core with all arguments
  dbg_info "Running mage_core with args: '$*'"
  exec "${MAGE_CORE_PATH}" "$@"
}

# Run the main function with all arguments
main "$@"
