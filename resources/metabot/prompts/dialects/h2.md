# H2 Database SQL Dialect Instructions

H2 is a lightweight Java SQL database, commonly used for testing and embedded applications. Follow these dialect-specific rules.

## Identifier Quoting

- Use **double quotes** for identifiers: `"MyColumn"`, `"table-name"`
- Unquoted identifiers are **converted to uppercase** by default
- String literals use **single quotes**: `'string value'`
- H2 supports multiple compatibility modes (PostgreSQL, MySQL, etc.)

```sql
SELECT "CamelCase", "reserved-word" FROM "My Table"
```

## String Operations

```sql
-- Concatenation: || operator or CONCAT function
SELECT first_name || ' ' || last_name AS full_name
SELECT CONCAT(first_name, ' ', last_name) AS full_name

-- String functions
SELECT
  LOWER(name), UPPER(name),
  TRIM(name), LTRIM(name), RTRIM(name),
  SUBSTR(name, 1, 3),                    -- 1-indexed (alias: SUBSTRING)
  LENGTH(name), CHAR_LENGTH(name),
  REPLACE(name, 'old', 'new'),
  POSITION('sub' IN name),               -- Find substring position
  LOCATE('sub', name),                   -- Alternative (1-indexed)
  LEFT(name, 3), RIGHT(name, 3),
  LPAD(str, 10, '0'), RPAD(str, 10, ' '),
  REPEAT(str, 3),
  REVERSE(str),
  SPACE(5),                              -- 5 space characters
  REGEXP_REPLACE(text, 'pattern', 'replacement'),
  REGEXP_LIKE(text, 'pattern')           -- Returns BOOLEAN

-- Pattern matching
SELECT * FROM t WHERE name LIKE 'A%'
SELECT * FROM t WHERE name LIKE 'A%' ESCAPE '\'   -- Custom escape char
SELECT * FROM t WHERE REGEXP_LIKE(name, '^[A-Z]') -- Regex match
```

## Date and Time

```sql
-- Current date/time
SELECT
  CURRENT_DATE,                          -- DATE
  CURRENT_TIME,                          -- TIME
  CURRENT_TIMESTAMP,                     -- TIMESTAMP
  NOW(),                                 -- Same as CURRENT_TIMESTAMP
  LOCALTIME, LOCALTIMESTAMP              -- Without timezone

-- Date truncation
SELECT TRUNC(order_date)                 -- Truncate to day
SELECT DATE_TRUNC('MONTH', order_date)   -- YEAR, QUARTER, MONTH, WEEK, DAY, HOUR
SELECT TRUNCATE(order_date, 'MM')        -- Alternative syntax

-- Date arithmetic
SELECT
  DATEADD('DAY', 7, order_date),         -- Add 7 days
  DATEADD('MONTH', 1, order_date),       -- Add 1 month
  DATEADD('HOUR', 2, ts),                -- Add 2 hours
  order_date + INTERVAL '7' DAY,         -- INTERVAL syntax
  order_date + 7,                        -- Add days directly (integer)
  DATEDIFF('DAY', start_date, end_date), -- Days between
  DATEDIFF('MONTH', start_date, end_date)

-- Extraction
SELECT
  YEAR(order_date), MONTH(order_date), DAY(order_date),
  DAYOFWEEK(order_date),                 -- 1=Sunday, 7=Saturday
  DAYOFYEAR(order_date),
  HOUR(ts), MINUTE(ts), SECOND(ts),
  QUARTER(order_date), WEEK(order_date),
  EXTRACT(YEAR FROM order_date),         -- Standard SQL
  EXTRACT(EPOCH FROM ts)                 -- Unix timestamp (seconds)

-- Formatting and parsing
SELECT
  FORMATDATETIME(order_date, 'yyyy-MM-dd'),
  FORMATDATETIME(ts, 'yyyy-MM-dd HH:mm:ss'),
  PARSEDATETIME('2024-01-15', 'yyyy-MM-dd'),
  PARSEDATETIME('2024-01-15 10:30:00', 'yyyy-MM-dd HH:mm:ss')
```

**Important**: Date format patterns use Java SimpleDateFormat: `yyyy` (year), `MM` (month), `dd` (day), `HH` (24-hour), `mm` (minute), `ss` (second).

## Type Casting

```sql
-- CAST syntax
SELECT CAST(string_col AS INT)
SELECT CAST(string_col AS DOUBLE)
SELECT CAST(string_col AS DATE)
SELECT CAST(string_col AS TIMESTAMP)
SELECT CAST(123 AS VARCHAR)

-- Type names: INT, INTEGER, BIGINT, SMALLINT, TINYINT, BOOLEAN,
--             DOUBLE, REAL, FLOAT, DECIMAL(p,s), NUMERIC(p,s),
--             VARCHAR, CHAR, CLOB, DATE, TIME, TIMESTAMP,
--             BINARY, BLOB, UUID, ARRAY, JSON
```

## NULL Handling

```sql
SELECT
  COALESCE(nullable_col, 'default'),     -- First non-null value
  NVL(nullable_col, 'default'),          -- Two-argument (alias: IFNULL)
  IFNULL(nullable_col, 'default'),       -- Two-argument
  NVL2(col, 'not null', 'null'),         -- If col not null, return 2nd, else 3rd
  NULLIF(col, ''),                       -- Returns NULL if col = ''
  CASEWHEN(condition, true_val, false_val),  -- H2-specific ternary
  CASE WHEN col IS NULL THEN 'N/A' ELSE col END
```

## Boolean Expressions

```sql
SELECT * FROM t WHERE flag = TRUE
SELECT * FROM t WHERE flag IS TRUE      -- NULL-safe
SELECT * FROM t WHERE flag IS NOT FALSE

-- Boolean functions
SELECT
  GREATEST(1, 2, 3),                     -- Returns 3
  LEAST(1, 2, 3),                        -- Returns 1
  DECODE(status, 'A', 'Active', 'I', 'Inactive', 'Unknown')  -- Switch expression
```

## Arrays

```sql
-- Array literal
SELECT ARRAY[1, 2, 3]
SELECT (1, 2, 3)                          -- Alternative syntax

-- Array access (1-indexed!)
SELECT my_array[1] AS first_element

-- Array functions
SELECT
  CARDINALITY(arr),                      -- Array length
  ARRAY_LENGTH(arr),                     -- Alias
  ARRAY_CONTAINS(arr, value),            -- Membership test
  ARRAY_CAT(arr1, arr2),                 -- Concatenate arrays
  ARRAY_APPEND(arr, element),
  ARRAY_SLICE(arr, 1, 3),                -- Slice from index 1 to 3
  ARRAY_GET(arr, 1)                      -- Get element (1-indexed)

-- UNNEST: flatten array to rows
SELECT * FROM UNNEST(ARRAY[1, 2, 3])
SELECT t.id, u.* FROM t CROSS JOIN UNNEST(t.arr) AS u(element)
```

## JSON Handling

```sql
-- JSON column type
SELECT JSON '{"name": "Alice", "age": 30}'

-- JSON extraction (H2 2.x)
SELECT
  json_col FORMAT JSON,                  -- Output as JSON string
  json_col.name,                         -- Dot notation access
  JSON_VALUE(json_col, '$.name'),        -- Extract scalar
  JSON_QUERY(json_col, '$.nested'),      -- Extract JSON object/array
  JSON_ARRAY(1, 2, 3),                   -- Create JSON array
  JSON_OBJECT('key': 'value')            -- Create JSON object
```

## Window Functions

```sql
SELECT
  ROW_NUMBER() OVER (PARTITION BY cat ORDER BY amt DESC),
  RANK() OVER (PARTITION BY cat ORDER BY amt DESC),
  DENSE_RANK() OVER (PARTITION BY cat ORDER BY amt DESC),
  SUM(amt) OVER (PARTITION BY cat),
  LAG(amt, 1, 0) OVER (ORDER BY dt),     -- With default value
  LEAD(amt) OVER (ORDER BY dt),
  FIRST_VALUE(amt) OVER (PARTITION BY cat ORDER BY dt),
  LAST_VALUE(amt) OVER (
    PARTITION BY cat ORDER BY dt
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
  ),
  NTH_VALUE(amt, 2) OVER w,
  NTILE(4) OVER (ORDER BY amt),
  PERCENT_RANK() OVER w,
  CUME_DIST() OVER w,
  SUM(amt) OVER (ORDER BY dt ROWS UNBOUNDED PRECEDING) AS running_total
FROM t
WINDOW w AS (PARTITION BY cat ORDER BY dt)
```

## Aggregation

```sql
SELECT
  COUNT(*), COUNT(DISTINCT col),
  SUM(amount), AVG(amount),
  MIN(val), MAX(val),
  GROUP_CONCAT(name SEPARATOR ', '),     -- String aggregation (MySQL mode)
  LISTAGG(name, ', '),                   -- Standard SQL string aggregation
  ARRAY_AGG(col),                        -- Aggregate to array
  BOOL_AND(flag), BOOL_OR(flag),         -- Boolean aggregates
  BIT_AND(col), BIT_OR(col),             -- Bitwise aggregates
  STDDEV_POP(col), STDDEV_SAMP(col),     -- Standard deviation
  VAR_POP(col), VAR_SAMP(col)            -- Variance
FROM t GROUP BY category
```

## Common Table Expressions (CTEs)

```sql
-- Standard CTE
WITH active_users AS (
  SELECT * FROM users WHERE status = 'active'
)
SELECT * FROM active_users

-- Recursive CTE
WITH RECURSIVE subordinates AS (
  SELECT id, name, manager_id, 1 AS depth
  FROM employees WHERE id = 1
  UNION ALL
  SELECT e.id, e.name, e.manager_id, s.depth + 1
  FROM employees e JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates
```

## MERGE Statement (Upsert)

```sql
MERGE INTO target_table t
USING source_table s ON t.id = s.id
WHEN MATCHED THEN UPDATE SET t.name = s.name, t.amount = s.amount
WHEN NOT MATCHED THEN INSERT (id, name, amount) VALUES (s.id, s.name, s.amount)
```

## Table Value Constructor

```sql
-- Create inline table
SELECT * FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) AS t(id, name)

-- Use in INSERT
INSERT INTO t (id, name) VALUES (1, 'a'), (2, 'b'), (3, 'c')
```

## Sequence and Identity

```sql
-- Auto-increment (most common)
CREATE TABLE t (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(100)
)

-- Sequence
CREATE SEQUENCE my_seq START WITH 1 INCREMENT BY 1
SELECT NEXT VALUE FOR my_seq
SELECT CURRVAL('my_seq')                 -- Current value

-- Identity column (SQL standard)
CREATE TABLE t (
  id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name VARCHAR(100)
)
```

## LIMIT and Pagination

```sql
-- Basic limit
SELECT * FROM t LIMIT 100

-- Offset
SELECT * FROM t ORDER BY id LIMIT 100 OFFSET 200

-- Alternative syntax
SELECT * FROM t ORDER BY id FETCH FIRST 100 ROWS ONLY
SELECT * FROM t ORDER BY id OFFSET 200 ROWS FETCH NEXT 100 ROWS ONLY
```

## Compatibility Modes

H2 supports compatibility modes that change SQL behavior:

```sql
-- Set mode in connection URL
jdbc:h2:mem:test;MODE=PostgreSQL

-- Available modes: REGULAR (default), DB2, Derby, HSQLDB, MariaDB,
--                  MySQL, Oracle, PostgreSQL, MSSQLServer
```

## Common Patterns

### Safe Division
```sql
SELECT
  CASEWHEN(denominator = 0, 0, numerator / denominator),
  numerator / NULLIF(denominator, 0)
```

### Conditional Aggregation
```sql
SELECT
  COUNT(*) AS total,
  SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) AS active_count,
  SUM(CASE WHEN type = 'revenue' THEN amount ELSE 0 END) AS revenue
FROM t
```

### Generate Series
```sql
-- Using system range table
SELECT x FROM SYSTEM_RANGE(1, 10)        -- 1 to 10

-- Date range
SELECT DATEADD('DAY', x, DATE '2024-01-01') AS dt
FROM SYSTEM_RANGE(0, 364)
```

### Pivoting (Manual)
```sql
SELECT
  category,
  SUM(CASE WHEN year = 2023 THEN amount ELSE 0 END) AS "2023",
  SUM(CASE WHEN year = 2024 THEN amount ELSE 0 END) AS "2024"
FROM sales
GROUP BY category
```

### Insert Ignore / On Duplicate
```sql
-- Skip if exists (MERGE alternative)
MERGE INTO t (id, name) KEY (id) VALUES (1, 'updated_name')
```

## Key Differences from Other Dialects

| Feature | H2 | PostgreSQL | MySQL | BigQuery |
|---------|-----|------------|-------|----------|
| Identifier quotes | `"double"` | `"double"` | `` `backtick` `` | `` `backtick` `` |
| Case sensitivity | Uppercase | Lowercase | Case-preserving | Case-insensitive |
| Array index | 1-based | 1-based | N/A | 0-based |
| Concat | `\|\|` | `\|\|` | `CONCAT` | `\|\|` or `CONCAT` |
| Date add | `DATEADD` | `+INTERVAL` | `DATE_ADD` | `DATE_ADD` |
| String agg | `LISTAGG` | `STRING_AGG` | `GROUP_CONCAT` | `STRING_AGG` |
| Generate series | `SYSTEM_RANGE` | `GENERATE_SERIES` | N/A | `GENERATE_ARRAY` |
| Upsert | `MERGE` | `ON CONFLICT` | `ON DUPLICATE KEY` | `MERGE` |
| Top-N per group | Window function | `DISTINCT ON` | Window function | `QUALIFY` |
