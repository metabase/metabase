(ns metabase-enterprise.semantic-search.index
  (:require
   [clojure.string :as str]
   [honey.sql :as sql]
   [honey.sql.helpers :as sql.helpers]
   [metabase-enterprise.semantic-search.db :as db]
   [metabase-enterprise.semantic-search.embedding :as embedding]
   [metabase.util.json :as json]
   [nano-id.core :as nano-id]
   [next.jdbc :as jdbc])
  (:import
   [java.time LocalDate]
   [org.postgresql.util PGobject]))

(set! *warn-on-reflection* true)

(def ^:dynamic *index-table-name*
  :search_index)

(defn- index-table-schema
  "Schema for the index table."
  []
  ;; Generate unique constraint name to avoid index name conflicts between multiple test tables
  (let [unique-constraint-name (keyword (str "unique_constraint_" (nano-id/nano-id) "_model_model_id"))]
    [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
     [:model :text :not-null]
     [:model_id :text :not-null]
     [:created_at :timestamp-with-time-zone [:default [:raw "CURRENT_TIMESTAMP"]] :not-null]
     [:creator_id :int]
     [:model_created_at :timestamp-with-time-zone]
     [:last_editor_id :int]
     [:model_updated_at :timestamp-with-time-zone]
     [:archived :boolean [:default false]]
     [:official_collection :boolean]
     [:legacy_input :jsonb]
     [:embedding [:raw "vector(1024)"] :not-null]
     [:content :text :not-null]
     [:metadata :jsonb]
     [[:constraint unique-constraint-name]
      [:unique [:composite :model :model_id]]]]))

(defn- format-embedding
  "Formats the embedding vector for SQL insertion."
  [embedding]
  (str "'[" (str/join ", " embedding) "]'::vector"))

(defn- doc->db-record
  "Convert a document to a database record with embedding."
  [{:keys [model id searchable_text created_at creator_id updated_at
           last_editor_id archived official_collection legacy_input] :as doc}]
  (let [embedding (embedding/get-embedding searchable_text)]
    {:model               model
     :model_id            id
     :creator_id          creator_id
     :model_created_at    created_at
     :last_editor_id      last_editor_id
     :model_updated_at    updated_at
     :archived            archived
     :official_collection official_collection
     :embedding           [:raw (format-embedding embedding)]
     :content             searchable_text
     :legacy_input        [:cast (json/encode legacy_input) :jsonb]
     :metadata            [:cast (json/encode doc) :jsonb]}))

(defn populate-index!
  "Inserts a set of documents into the index table."
  [documents]
  (jdbc/with-transaction [tx @db/data-source]
    (doseq [doc documents]
      (jdbc/execute!
       tx
       (sql/format
        (-> (sql.helpers/insert-into *index-table-name*)
            (sql.helpers/values [(doc->db-record doc)])))))))

(defn- upsert-honeysql
  [doc]
  (let [db-record (doc->db-record doc)]
    (->
     (sql.helpers/insert-into *index-table-name*)
     (sql.helpers/values [db-record])
     (sql.helpers/on-conflict :model :model_id)
     (sql.helpers/do-update-set
      (dissoc db-record :model :model_id)))))

(defn upsert-index!
  "Inserts or updates documents in the index table. If a document with the same
  model + model_id already exists, it will be replaced."
  [documents]
  (jdbc/with-transaction [tx @db/data-source]
    (doseq [doc documents]
      (jdbc/execute!
       tx
       (sql/format
        (upsert-honeysql doc))))))

(defn- drop-index-table-sql
  []
  (sql/format (sql.helpers/drop-table :if-exists *index-table-name*)))

(defn drop-index-table!
  "Drop the index table if it exists."
  ([]   (jdbc/execute! @db/data-source (drop-index-table-sql)))
  ([tx] (jdbc/execute! tx (drop-index-table-sql))))

(defn create-index-table!
  "Ensure that the index table exists and is ready to be populated. If
  force-reset? is true, drops and recreates the table if it exists."
  [{:keys [force-reset?] :or {force-reset? false}}]
  (try
    (jdbc/with-transaction [tx @db/data-source]
      (jdbc/execute! tx (sql/format (sql.helpers/create-extension :vector :if-not-exists)))
      (when force-reset? (drop-index-table! tx))
      (jdbc/execute!
       tx
       (-> (sql.helpers/create-table *index-table-name*)
           (sql.helpers/with-columns (index-table-schema))
           sql/format)))
    (catch Exception e
      (throw (ex-info "Failed to create index table" {:cause e})))))

(defn- search-filters
  "Generate WHERE conditions based on search context filters."
  [{:keys [archived? models created-at created-by last-edited-at last-edited-by]}]
  (let [conditions (filter some?
                           [(when (some? archived?)
                              [:= :archived archived?])
                            (when (seq models)
                              [:in :model models])
                            (when (seq created-by)
                              [:in :creator_id created-by])
                            (when (seq last-edited-by)
                              [:in :last_editor_id last-edited-by])
                            (when (and created-at (:start created-at) (:end created-at))
                              [:between :model_created_at
                               (LocalDate/parse (:start created-at))
                               (LocalDate/parse (:end created-at))])
                            (when (and last-edited-at (:start last-edited-at) (:end last-edited-at))
                              [:between :model_updated_at
                               (LocalDate/parse (:start last-edited-at))
                               (LocalDate/parse (:end last-edited-at))])])]
    (when (seq conditions)
      (into [:and] conditions))))

(defn- semantic-search-query
  "Build a semantic search query using vector similarity."
  [embedding search-context]
  (let [filters (search-filters search-context)
        base-query {:select [[:model_id :model_id]
                             [:model :model]
                             [:content :content]
                             [[:raw (str "embedding <=> " (format-embedding embedding))] :distance]
                             [:metadata :metadata]]
                    :from   [*index-table-name*]
                    :order-by [[:distance :asc]]
                    :limit  100}]
    (if filters
      (assoc base-query :where filters)
      base-query)))

(defn- legacy-input-with-score
  "Fetches the legacy_input field from a result's metadata and attaches a score based on the
  embedding distance."
  [row]
  (-> (get-in row [:metadata :legacy_input])
      (assoc :score (- 1.0 (:distance row 1.0)))))

;; TODO: can the query return unqualified keys directly?
(defn- unqualify-keys
  "Remove table namespace from namespaced keywords in a result row."
  [row]
  (into {} (map (fn [[k v]] [(keyword (name k)) v]) row)))

(defn- decode-metadata
  "Decode a PGObject (returned from a jsonb field) into a Clojure map."
  [row]
  (update row :metadata #(json/decode (.getValue ^PGobject %) true)))

(defn query-index
  "Query the index for documents similar to the search string."
  [search-context]
  (let [search-string (:search-string search-context)]
    (when-not (str/blank? search-string)
      (let [embedding (embedding/get-embedding search-string)
            query     (semantic-search-query embedding search-context)]
        (->> (jdbc/execute! @db/data-source (sql/format query))
             (map unqualify-keys)
             (map decode-metadata)
             (map legacy-input-with-score))))))

(defn delete-from-index!
  "Deletes documents from the index table based on model and model_ids."
  [model model-ids]
  (jdbc/with-transaction [tx @db/data-source]
    (jdbc/execute!
     tx
     (sql/format
      (-> (sql.helpers/delete-from *index-table-name*)
          (sql.helpers/where [:and
                              [:= :model model]
                              [:in :model_id model-ids]]))))))

(comment
  (create-index-table! {:force-reset? true})
  (populate-index! [{:model "card"
                     :id "1"
                     :searchable_text "This is a test card"}])
  (delete-from-index! "dashboard" ["13"])
  (query-index {:search-string "Copper knife"}))
