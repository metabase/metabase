(ns metabase.mbql.schema
  "Schema for validating a *normalized* MBQL query. This is also the definitive grammar for MBQL, wow!"
  (:refer-clojure :exclude [count distinct min max + - / * and or not not-empty = < > <= >= time case concat replace abs])
  #?@
  (:clj
   [(:require
     [clojure.core :as core]
     [clojure.set :as set]
     [metabase.mbql.schema.helpers :as helpers :refer [is-clause?]]
     [metabase.mbql.schema.macros :refer [defclause one-of]]
     [schema.core :as s])
    (:import java.time.format.DateTimeFormatter)]
   :cljs
   [(:require
     [clojure.core :as core]
     [clojure.set :as set]
     [metabase.mbql.schema.helpers :as helpers :refer [is-clause?]]
     [metabase.mbql.schema.macros :refer [defclause one-of]]
     [schema.core :as s])]))

;; A NOTE ABOUT METADATA:
;;
;; Clauses below are marked with the following tags for documentation purposes:
;;
;; *  Clauses marked `^:sugar` are syntactic sugar primarily intended to make generating queries easier on the
;;    frontend. These clauses are automatically rewritten as simpler clauses by the `desugar` or `expand-macros`
;;    middleware. Thus driver implementations do not need to handle these clauses.
;;
;; *  Clauses marked `^:internal` are automatically generated by `wrap-value-literals` or other middleware from values
;;    passed in. They are not intended to be used by the frontend when generating a query. These add certain
;;    information that simplify driver implementations. When writing MBQL queries yourself you should pretend these
;;    clauses don't exist.
;;
;; *  Clauses marked `^{:requires-features #{feature+}}` require a certain set of features to be used. At some date in
;;    the future we will likely add middleware that uses this metadata to automatically validate that a driver has the
;;    features needed to run the query in question.

;;; +----------------------------------------------------------------------------------------------------------------+
;;; |                                                  MBQL Clauses                                                  |
;;; +----------------------------------------------------------------------------------------------------------------+

;;; ------------------------------------------------- Datetime Stuff -------------------------------------------------

;; `:day-of-week` depends on the [[metabase.public-settings/start-of-week]] Setting, by default Sunday.
;; 1 = first day of the week (e.g. Sunday)
;; 7 = last day of the week (e.g. Saturday)
(def date-bucketing-units
  "Set of valid units for bucketing or comparing against a *date* Field."
  #{:default :day :day-of-week :day-of-month :day-of-year :week :week-of-year
    :month :month-of-year :quarter :quarter-of-year :year})

(def time-bucketing-units
  "Set of valid units for bucketing or comparing against a *time* Field."
  #{:default :millisecond :second :minute :minute-of-hour :hour :hour-of-day})

(def datetime-bucketing-units
  "Set of valid units for bucketing or comparing against a *datetime* Field."
  (set/union date-bucketing-units time-bucketing-units))

(def DateUnit
  "Valid unit for *date* bucketing."
  (s/named
   (apply s/enum date-bucketing-units)
   "date-bucketing-unit"))

;; it could make sense to say hour-of-day(field) =  hour-of-day("2018-10-10T12:00")
;; but it does not make sense to say month-of-year(field) = month-of-year("08:00:00"),
;; does it? So we'll restrict the set of units a TimeValue can have to ones that have no notion of day/date.
(def TimeUnit
  "Valid unit for *time* bucketing."
  (s/named
   (apply s/enum time-bucketing-units)
   "time-bucketing-unit"))

(def DateTimeUnit
  "Valid unit for *datetime* bucketing."
  (s/named
   (apply s/enum datetime-bucketing-units)
   "datetime-bucketing-unit"))

(def ^:private RelativeDatetimeUnit
  (s/named
   (apply s/enum #{:default :minute :hour :day :week :month :quarter :year})
   "relative-datetime-unit"))

#?(:clj
   (defn- can-parse-iso-8601?
     [^DateTimeFormatter formatter ^String s]
     (when (string? s)
       (try
         (.parse formatter s)
         true
         (catch Throwable _
           false))))

   :cljs
   (defn- can-parse-iso-8601?
     [s]
     (when (string? s)
       (not= (.parse js/Date s) ##NaN))))

;; TODO -- currently these are all the same between date/time/datetime

(def ^{:arglists '([s])} can-parse-date?
  "Returns whether a string can be parsed to an ISO 8601 date or not."
  #?(:clj (partial can-parse-iso-8601? DateTimeFormatter/ISO_DATE)
     :cljs can-parse-iso-8601?))

(def ^{:arglists '([s])} can-parse-datetime?
  "Returns whether a string can be parsed to an ISO 8601 datetime or not."
  #?(:clj (partial can-parse-iso-8601? DateTimeFormatter/ISO_DATE_TIME)
     :cljs can-parse-iso-8601?))

(def ^{:arglists '([s])} can-parse-time?
  "Returns whether a string can be parsed to an ISO 8601 time or not."
  #?(:clj (partial can-parse-iso-8601? DateTimeFormatter/ISO_TIME)
     :cljs can-parse-iso-8601?))

(def LiteralDateString
  "Schema for an ISO-8601-formatted date string literal."
  (s/constrained helpers/NonBlankString can-parse-date? "valid ISO-8601 datetime string literal"))

(def LiteralDatetimeString
  "Schema for an ISO-8601-formattedor datetime string literal."
  (s/constrained helpers/NonBlankString can-parse-datetime? "valid ISO-8601 datetime string literal"))

(def LiteralTimeString
  "Schema for an ISO-8601-formatted time string literal."
  (s/constrained helpers/NonBlankString can-parse-time? "valid ISO-8601 time string literal"))

(def TemporalLiteralString
  "Schema for either a literal datetime string, literal date string, or a literal time string."
  (s/named
   (s/conditional
    can-parse-datetime? LiteralDatetimeString
    can-parse-date?     LiteralDateString
    can-parse-time?     LiteralTimeString)
   "valid ISO-8601 datetime, date, or time string literal"))

;; TODO - `unit` is not allowed if `n` is `current`
(defclause relative-datetime
  n    (s/cond-pre (s/eq :current) s/Int)
  unit (optional RelativeDatetimeUnit))

(defclause interval
  n    s/Int
  unit RelativeDatetimeUnit)

;; This clause is automatically generated by middleware when datetime literals (literal strings or one of the Java
;; types) are encountered. Unit is inferred by looking at the Field the timestamp is compared against. Implemented
;; mostly to convenience driver implementations. You don't need to use this form directly when writing MBQL; datetime
;; literal strings are preferred instead.
;;
;; example:
;; [:= [:field 10 {:temporal-unit :day}] "2018-10-02"]
;;
;; becomes:
;; [:= [:field 10 {:temporal-unit :day}] [:absolute-datetime #inst "2018-10-02" :day]]
(def ^:internal ^{:clause-name :absolute-datetime} absolute-datetime
  "Schema for an `:absolute-datetime` clause."
  (s/conditional
   #(core/not (is-clause? :absolute-datetime %))
   (helpers/clause
    :absolute-datetime
    "t"
    #?(:clj (s/cond-pre java.time.LocalDate java.time.LocalDateTime java.time.OffsetDateTime java.time.ZonedDateTime)
       :cljs js/Date)
    "unit"
    DateTimeUnit)

   #(instance? #?(:clj java.time.LocalDate :cljs js/Date) (second %))
   (helpers/clause
    :absolute-datetime
    "date" #?(:clj java.time.LocalDate :cljs js/Date)
    "unit" DateUnit)

   :else
   (helpers/clause
    :absolute-datetime
    "datetime"
    #?(:clj (s/cond-pre java.time.LocalDateTime java.time.OffsetDateTime java.time.ZonedDateTime)
       :cljs js/Date)
    "unit"
    DateTimeUnit)))


;; almost exactly the same as `absolute-datetime`, but generated in some sitations where the literal in question was
;; clearly a time (e.g. "08:00:00.000") and/or the Field derived from `:type/Time` and/or the unit was a
;; time-bucketing unit
;;
;; TODO - should we have a separate `date` type as well
(defclause ^:internal time
  time #?(:clj (s/cond-pre java.time.LocalTime java.time.OffsetTime)
          :cljs js/Date)
  unit TimeUnit)

(def ^:private DatetimeLiteral
  "Schema for valid absolute datetime literals."
  (s/conditional
   (partial is-clause? :absolute-datetime)
   absolute-datetime

   (partial is-clause? :time)
   time

   :else
   (s/cond-pre
    ;; literal datetime strings and Java types will get transformed to `absolute-datetime` clauses automatically by
    ;; middleware so drivers don't need to deal with these directly. You only need to worry about handling
    ;; `absolute-datetime` clauses.
    TemporalLiteralString

    #?@(:clj
        [java.time.LocalTime
         java.time.LocalDate
         java.time.LocalDateTime
         java.time.OffsetTime
         java.time.OffsetDateTime
         java.time.ZonedDateTime]

        :cljs
        [js/Date]))))

(def DateTimeValue
  "Schema for a datetime value drivers will personally have to handle, either an `absolute-datetime` form or a
  `relative-datetime` form."
  (one-of absolute-datetime relative-datetime time))


;;; -------------------------------------------------- Other Values --------------------------------------------------

(def ValueTypeInfo
  "Type info about a value in a `:value` clause. Added automatically by `wrap-value-literals` middleware to values in
  filter clauses based on the Field in the clause."
  ;; TODO -- these should use `lisp-case` like everything else in MBQL.
  {(s/optional-key :database_type) (s/maybe helpers/NonBlankString)
   (s/optional-key :base_type)     (s/maybe helpers/FieldType)
   (s/optional-key :semantic_type) (s/maybe helpers/FieldSemanticOrRelationType)
   (s/optional-key :unit)          (s/maybe DateTimeUnit)
   (s/optional-key :name)          (s/maybe helpers/NonBlankString)
   s/Keyword                       s/Any})

;; Arguments to filter clauses are automatically replaced with [:value <value> <type-info>] clauses by the
;; `wrap-value-literals` middleware. This is done to make it easier to implement query processors, because most driver
;; implementations dispatch off of Object type, which is often not enough to make informed decisions about how to
;; treat certain objects. For example, a string compared against a Postgres UUID Field needs to be parsed into a UUID
;; object, since text <-> UUID comparision doesn't work in Postgres. For this reason, raw literals in `:filter`
;; clauses are wrapped in `:value` clauses and given information about the type of the Field they will be compared to.
(defclause ^:internal value
  value    s/Any
  type-info (s/maybe ValueTypeInfo))


;;; ----------------------------------------------------- Fields -----------------------------------------------------

;; Expression *references* refer to a something in the `:expressions` clause, e.g. something like
;;
;;    [:+ [:field 1 nil] [:field 2 nil]]
;;
;; As of 0.42.0 `:expression` references can have an optional options map
(defclause ^{:requires-features #{:expressions}} expression
  expression-name helpers/NonBlankString
  options         (optional (s/pred map? "map")))

(def BinningStrategyName
  "Schema for a valid value for the `strategy-name` param of a [[field]] clause with `:binning` information."
  (s/enum :num-bins :bin-width :default))

(defn- validate-bin-width [schema]
  (s/constrained
   schema
   (fn [{:keys [strategy bin-width]}]
     (if (core/= strategy :bin-width)
       bin-width
       true))
   "You must specify :bin-width when using the :bin-width strategy."))

(defn- validate-num-bins [schema]
  (s/constrained
   schema
   (fn [{:keys [strategy num-bins]}]
     (if (core/= strategy :num-bins)
       num-bins
       true))
   "You must specify :num-bins when using the :num-bins strategy."))

(def FieldBinningOptions
  "Schema for `:binning` options passed to a `:field` clause."
  (-> {:strategy                   BinningStrategyName
       (s/optional-key :num-bins)  helpers/IntGreaterThanZero
       (s/optional-key :bin-width) (s/constrained s/Num (complement neg?) "bin width must be >= 0.")
       s/Keyword                   s/Any}
      validate-bin-width
      validate-num-bins))

(defn valid-temporal-unit-for-base-type?
  "Whether `temporal-unit` (e.g. `:day`) is valid for the given `base-type` (e.g. `:type/Date`). If either is `nil` this
  will return truthy. Accepts either map of `field-options` or `base-type` and `temporal-unit` passed separately."
  ([{:keys [base-type temporal-unit] :as _field-options}]
   (valid-temporal-unit-for-base-type? base-type temporal-unit))

  ([base-type temporal-unit]
   (if-let [units (when (core/and temporal-unit base-type)
                    (condp #(isa? %2 %1) base-type
                      :type/Date     date-bucketing-units
                      :type/Time     time-bucketing-units
                      :type/DateTime datetime-bucketing-units
                      nil))]
     (contains? units temporal-unit)
     true)))

(defn- validate-temporal-unit [schema]
  ;; TODO - consider breaking this out into separate constraints for the three different types so we can generate more
  ;; specific error messages
  (s/constrained
   schema
   valid-temporal-unit-for-base-type?
   "Invalid :temporal-unit for the specified :base-type."))

(defn- no-binning-options-at-top-level [schema]
  (s/constrained
   schema
   (complement :strategy)
   "Found :binning keys at the top level of :field options. binning-related options belong under the :binning key."))

(def ^:private FieldOptions
  (-> {(s/optional-key :base-type)     (s/maybe helpers/FieldType)
       ;;
       ;; replaces `fk->`
       ;;
       ;; `:source-field` is used to refer to a Field from a different Table you would like IMPLICITLY JOINED to the
       ;; source table.
       ;;
       ;; If both `:source-field` and `:join-alias` are supplied, `:join-alias` should be used to perform the join;
       ;; `:source-field` should be for information purposes only.
       (s/optional-key :source-field)  (s/maybe (s/cond-pre helpers/IntGreaterThanZero helpers/NonBlankString))
       ;;
       ;; `:temporal-unit` is used to specify DATE BUCKETING for a Field that represents a moment in time of some sort.
       ;;
       ;; There is no requirement that all `:type/Temporal` derived Fields specify a `:temporal-unit`, but for legacy
       ;; reasons `:field` clauses that refer to `:type/DateTime` Fields will be automatically "bucketed" in the
       ;; `:breakout` and `:filter` clauses, but nowhere else. Auto-bucketing only applies to `:filter` clauses when
       ;; values for comparison are `yyyy-MM-dd` date strings. See the `auto-bucket-datetimes` middleware for more
       ;; details. `:field` clauses elsewhere will not be automatically bucketed, so drivers still need to make sure they
       ;; do any special datetime handling for plain `:field` clauses when their Field derives from `:type/DateTime`.
       (s/optional-key :temporal-unit) (s/maybe DateTimeUnit)
       ;;
       ;; replaces `joined-field`
       ;;
       ;; `:join-alias` is used to refer to a Field from a different Table/nested query that you are EXPLICITLY
       ;; JOINING against.
       (s/optional-key :join-alias)    (s/maybe helpers/NonBlankString)
       ;;
       ;; replaces `binning-strategy`
       ;;
       ;; Using binning requires the driver to support the `:binning` feature.
       (s/optional-key :binning)       (s/maybe FieldBinningOptions)
       ;;
       s/Keyword                       s/Any}
      validate-temporal-unit
      no-binning-options-at-top-level))

(defn- require-base-type-for-field-name [schema]
  (s/constrained
   schema
   (fn [[_ id-or-name {:keys [base-type]}]]
     (if (string? id-or-name)
       base-type
       true))
   ":field clauses using a string field name must specify :base-type."))

(def ^{:clause-name :field, :added "0.39.0"} field
  "Schema for a `:field` clause."
  (-> (helpers/clause
       :field
       "id-or-name" (s/cond-pre helpers/IntGreaterThanZero helpers/NonBlankString)
       "options"    (s/maybe (s/recursive #'FieldOptions)))
      require-base-type-for-field-name))

(def ^{:clause-name :field, :added "0.39.0"} field:id
  "Schema for a `:field` clause, with the added constraint that it must use an integer Field ID."
  (s/constrained
   field
   (fn [[_ id-or-name]]
     (integer? id-or-name))
   "Must be a :field with an integer Field ID."))

(def ^{:clause-name :field, :added "0.39.0"} field:name
  "Schema for a `:field` clause, with the added constraint that it must use an string Field name."
  (s/constrained
   field
   (fn [[_ id-or-name]]
     (string? id-or-name))
   "Must be a :field with a string Field name."))

(def ^:private Field*
  (one-of expression field))

;; TODO -- consider renaming this FieldOrExpression
(def Field
  "Schema for either a `:field` clause (reference to a Field) or an `:expression` clause (reference to an expression)."
  (s/recursive #'Field*))

;; aggregate field reference refers to an aggregation, e.g.
;;
;;    {:aggregation [[:count]]
;;     :order-by    [[:asc [:aggregation 0]]]} ;; refers to the 0th aggregation, `:count`
;;
;; Currently aggregate Field references can only be used inside order-by clauses. In the future once we support SQL
;; `HAVING` we can allow them in filter clauses too
;;
;; TODO - shouldn't we allow composing aggregations in expressions? e.g.
;;
;;    {:order-by [[:asc [:+ [:aggregation 0] [:aggregation 1]]]]}
;;
;; TODO - it would be nice if we could check that there's actually an aggregation with the corresponding index,
;; wouldn't it
;;
;; As of 0.42.0 `:aggregation` references can have an optional options map.
(defclause aggregation
  aggregation-clause-index s/Int
  options                  (optional (s/pred map? "map")))

(def FieldOrAggregationReference
  "Schema for any type of valid Field clause, or for an indexed reference to an aggregation clause."
  (s/if (partial is-clause? :aggregation)
    aggregation
    Field))


;;; -------------------------------------------------- Expressions ---------------------------------------------------

;; Expressions are "calculated column" definitions, defined once and then used elsewhere in the MBQL query.

(def string-expressions
  "String functions"
  #{:substring :trim :rtrim :ltrim :upper :lower :replace :concat :regex-match-first :coalesce :case})

(declare StringExpression)

(def ^:private StringExpressionArg
  (s/conditional
   string?
   s/Str

   (partial is-clause? string-expressions)
   (s/recursive #'StringExpression)

   (partial is-clause? :value)
   value

   :else
   Field))

(def arithmetic-expressions
  "Set of valid arithmetic expression clause keywords."
  #{:+ :- :/ :* :coalesce :length :round :ceil :floor :abs :power :sqrt :log :exp :case})

(def boolean-expressions
  "Set of valid boolean expression clause keywords."
  #{:and :or :not :< :<= :> :>= := :!=})

(def ^:private aggregations #{:sum :avg :stddev :var :median :percentile :min :max :cum-count :cum-sum :count-where :sum-where :share :distinct :metric :aggregation-options :count})

(declare ArithmeticExpression)
(declare BooleanExpression)
(declare Aggregation)

(def ^:private NumericExpressionArg
  (s/conditional
   number?
   s/Num

   (partial is-clause? arithmetic-expressions)
   (s/recursive #'ArithmeticExpression)

   (partial is-clause? aggregations)
   (s/recursive #'Aggregation)

   (partial is-clause? :value)
   value

   :else
   Field))

(def ^:private ExpressionArg
  (s/conditional
   number?
   s/Num

   boolean?
   s/Bool

   (partial is-clause? boolean-expressions)
   (s/recursive #'BooleanExpression)

   (partial is-clause? arithmetic-expressions)
   (s/recursive #'ArithmeticExpression)

   string?
   s/Str

   (partial is-clause? string-expressions)
   (s/recursive #'StringExpression)

   (partial is-clause? :value)
   value

   :else
   Field))

(def ^:private NumericExpressionArgOrInterval
  (s/if (partial is-clause? :interval)
    interval
    NumericExpressionArg))

(defclause ^{:requires-features #{:expressions}} coalesce
  a ExpressionArg, b ExpressionArg, more (rest ExpressionArg))

(defclause ^{:requires-features #{:expressions}} substring
  s StringExpressionArg, start NumericExpressionArg, length (optional NumericExpressionArg))

(defclause ^{:requires-features #{:expressions}} length
  s StringExpressionArg)

(defclause ^{:requires-features #{:expressions}} trim
  s StringExpressionArg)

(defclause ^{:requires-features #{:expressions}} rtrim
  s StringExpressionArg)

(defclause ^{:requires-features #{:expressions}} ltrim
  s StringExpressionArg)

(defclause ^{:requires-features #{:expressions}} upper
  s StringExpressionArg)

(defclause ^{:requires-features #{:expressions}} lower
  s StringExpressionArg)

(defclause ^{:requires-features #{:expressions}} replace
  s StringExpressionArg, match s/Str, replacement s/Str)

(defclause ^{:requires-features #{:expressions}} concat
  a StringExpressionArg, b StringExpressionArg, more (rest StringExpressionArg))

(defclause ^{:requires-features #{:expressions :regex}} regex-match-first
  s StringExpressionArg, pattern s/Str)

(defclause ^{:requires-features #{:expressions}} +
  x NumericExpressionArgOrInterval, y NumericExpressionArgOrInterval, more (rest NumericExpressionArgOrInterval))

(defclause ^{:requires-features #{:expressions}} -
  x NumericExpressionArg, y NumericExpressionArgOrInterval, more (rest NumericExpressionArgOrInterval))

(defclause ^{:requires-features #{:expressions}} /, x NumericExpressionArg, y NumericExpressionArg, more (rest NumericExpressionArg))

(defclause ^{:requires-features #{:expressions}} *, x NumericExpressionArg, y NumericExpressionArg, more (rest NumericExpressionArg))

(defclause ^{:requires-features #{:expressions}} floor
  x NumericExpressionArg)

(defclause ^{:requires-features #{:expressions}} ceil
  x NumericExpressionArg)

(defclause ^{:requires-features #{:expressions}} round
  x NumericExpressionArg)

(defclause ^{:requires-features #{:expressions}} abs
  x NumericExpressionArg)

(defclause ^{:requires-features #{:advanced-math-expressions}} power
  x NumericExpressionArg,  y NumericExpressionArg)

(defclause ^{:requires-features #{:advanced-math-expressions}} sqrt
  x NumericExpressionArg)

(defclause ^{:requires-features #{:advanced-math-expressions}} exp
  x NumericExpressionArg)

(defclause ^{:requires-features #{:advanced-math-expressions}} log
  x NumericExpressionArg)

(declare ArithmeticExpression*)

(def ^:private ArithmeticExpression
  "Schema for the definition of an arithmetic expression."
  (s/recursive #'ArithmeticExpression*))

(declare StringExpression*)

(def ^:private StringExpression
  "Schema for the definition of an string expression."
  (s/recursive #'StringExpression*))


;;; ----------------------------------------------------- Filter -----------------------------------------------------

(declare Filter)

(defclause and
  first-clause  (s/recursive #'Filter)
  second-clause (s/recursive #'Filter)
  other-clauses (rest (s/recursive #'Filter)))

(defclause or
  first-clause  (s/recursive #'Filter)
  second-clause (s/recursive #'Filter)
  other-clauses (rest (s/recursive #'Filter)))

(defclause not, clause (s/recursive #'Filter))

(def ^:private FieldOrRelativeDatetime
  (s/if (partial is-clause? :relative-datetime)
   relative-datetime
   Field))

(def ^:private EqualityComparable
  "Schema for things things that make sense in a `=` or `!=` filter, i.e. things that can be compared for equality."
  (s/maybe
   (s/cond-pre
    s/Bool
    s/Num
    s/Str
    DatetimeLiteral
    FieldOrRelativeDatetime
    ExpressionArg
    value)))

(def ^:private OrderComparable
  "Schema for things that make sense in a filter like `>` or `<`, i.e. things that can be sorted."
  (s/if (partial is-clause? :value)
    value
    (s/cond-pre
     s/Num
     s/Str
     DatetimeLiteral
     ExpressionArg
     FieldOrRelativeDatetime)))

;; For all of the non-compound Filter clauses below the first arg is an implicit Field ID

;; These are SORT OF SUGARY, because extra values will automatically be converted a compound clauses. Driver
;; implementations only need to handle the 2-arg forms.
;;
;; `=` works like SQL `IN` with more than 2 args
;;
;;    [:= [:field 1 nil] 2 3] --[DESUGAR]--> [:or [:= [:field 1 nil] 2] [:= [:field 1 nil] 3]]
;;
;; `!=` works like SQL `NOT IN` with more than 2 args
;;
;;    [:!= [:field 1 nil] 2 3] --[DESUGAR]--> [:and [:!= [:field 1 nil] 2] [:!= [:field 1 nil] 3]]

(defclause =,  field EqualityComparable, value-or-field EqualityComparable, more-values-or-fields (rest EqualityComparable))
(defclause !=, field EqualityComparable, value-or-field EqualityComparable, more-values-or-fields (rest EqualityComparable))

(defclause <,  field OrderComparable, value-or-field OrderComparable)
(defclause >,  field OrderComparable, value-or-field OrderComparable)
(defclause <=, field OrderComparable, value-or-field OrderComparable)
(defclause >=, field OrderComparable, value-or-field OrderComparable)

;; :between is INCLUSIVE just like SQL !!!
(defclause between field OrderComparable, min OrderComparable, max OrderComparable)

;; SUGAR CLAUSE: This is automatically written as a pair of `:between` clauses by the `:desugar` middleware.
(defclause ^:sugar inside
  lat-field OrderComparable
  lon-field OrderComparable
  lat-max   OrderComparable
  lon-min   OrderComparable
  lat-min   OrderComparable
  lon-max   OrderComparable)

;; SUGAR CLAUSES: These are rewritten as `[:= <field> nil]` and `[:not= <field> nil]` respectively
(defclause ^:sugar is-null,  field Field)
(defclause ^:sugar not-null, field Field)

;; These are rewritten as `[:or [:= <field> nil] [:= <field> ""]]` and
;; `[:and [:not= <field> nil] [:not= <field> ""]]`
(defclause ^:sugar is-empty,  field Field)
(defclause ^:sugar not-empty, field Field)

(def ^:private StringFilterOptions
  {(s/optional-key :case-sensitive) s/Bool}) ; default true

(defclause starts-with, field StringExpressionArg, string-or-field StringExpressionArg, options (optional StringFilterOptions))
(defclause ends-with,   field StringExpressionArg, string-or-field StringExpressionArg, options (optional StringFilterOptions))
(defclause contains,    field StringExpressionArg, string-or-field StringExpressionArg, options (optional StringFilterOptions))

;; SUGAR: this is rewritten as [:not [:contains ...]]
(defclause ^:sugar does-not-contain
  field StringExpressionArg, string-or-field StringExpressionArg, options (optional StringFilterOptions))

(def ^:private TimeIntervalOptions
  ;; Should we include partial results for the current day/month/etc? Defaults to `false`; set this to `true` to
  ;; include them.
  {(s/optional-key :include-current) s/Bool}) ; default false

;; Filter subclause. Syntactic sugar for specifying a specific time interval.
;;
;; Return rows where datetime Field 100's value is in the current month
;;
;;    [:time-interval [:field 100 nil] :current :month]
;;
;; Return rows where datetime Field 100's value is in the current month, including partial results for the
;; current day
;;
;;    [:time-interval [:field 100 nil] :current :month {:include-current true}]
;;
;; SUGAR: This is automatically rewritten as a filter clause with a relative-datetime value
(defclause ^:sugar time-interval
  field   Field
  n       (s/cond-pre
           s/Int
           (s/enum :current :last :next))
  unit    RelativeDatetimeUnit
  options (optional TimeIntervalOptions))

;; A segment is a special `macro` that saves some pre-definied filter clause, e.g. [:segment 1]
;; this gets replaced by a normal Filter clause in MBQL macroexpansion
;;
;; It can also be used for GA, which looks something like `[:segment "gaid::-11"]`. GA segments aren't actually MBQL
;; segments and pass-thru to GA.
(defclause ^:sugar segment, segment-id (s/cond-pre helpers/IntGreaterThanZero helpers/NonBlankString))

(declare BooleanExpression*)

(def ^:private BooleanExpression
  "Schema for the definition of an arithmetic expression."
  (s/recursive #'BooleanExpression*))

(def ^:private BooleanExpression*
  (one-of and or not < <= > >= = !=))

(def ^:private Filter*
  (s/conditional
   (partial is-clause? arithmetic-expressions) ArithmeticExpression
   (partial is-clause? string-expressions)     StringExpression
   (partial is-clause? boolean-expressions)    BooleanExpression
   :else
   (one-of
    ;; filters drivers must implement
    and or not = != < > <= >= between starts-with ends-with contains
    ;; SUGAR filters drivers do not need to implement
    does-not-contain inside is-empty not-empty is-null not-null time-interval segment)))

(def Filter
  "Schema for a valid MBQL `:filter` clause."
  (s/recursive #'Filter*))

(def ^:private CaseClause [(s/one Filter "pred") (s/one ExpressionArg "expr")])

(def ^:private CaseClauses [CaseClause])

(def ^:private CaseOptions
  {(s/optional-key :default) ExpressionArg})

(defclause ^{:requires-features #{:basic-aggregations}} case
  clauses CaseClauses, options (optional CaseOptions))

(def ^:private ArithmeticExpression*
  (one-of + - / * coalesce length floor ceil round abs power sqrt exp log case))

(def ^:private StringExpression*
  (one-of substring trim ltrim rtrim replace lower upper concat regex-match-first coalesce case))


(def FieldOrExpressionDef
  "Schema for anything that is accepted as a top-level expression definition, either an arithmetic expression such as a
  `:+` clause or a `:field` clause."
  (s/conditional
   (partial is-clause? arithmetic-expressions) ArithmeticExpression
   (partial is-clause? string-expressions)     StringExpression
   (partial is-clause? boolean-expressions)    BooleanExpression
   (partial is-clause? :case)                  case
   :else                                       Field))


;;; -------------------------------------------------- Aggregations --------------------------------------------------

;; For all of the 'normal' Aggregations below (excluding Metrics) fields are implicit Field IDs

;; cum-sum and cum-count are SUGAR because they're implemented in middleware. They clauses are swapped out with
;; `count` and `sum` aggregations respectively and summation is done in Clojure-land
(defclause ^{:requires-features #{:basic-aggregations}} ^:sugar count,     field (optional Field))
(defclause ^{:requires-features #{:basic-aggregations}} ^:sugar cum-count, field (optional Field))

;; technically aggregations besides count can also accept expressions as args, e.g.
;;
;;    [[:sum [:+ [:field 1 nil] [:field 2 nil]]]]
;;
;; Which is equivalent to SQL:
;;
;;    SUM(field_1 + field_2)

(defclause ^{:requires-features #{:basic-aggregations}} avg,      field-or-expression FieldOrExpressionDef)
(defclause ^{:requires-features #{:basic-aggregations}} cum-sum,  field-or-expression FieldOrExpressionDef)
(defclause ^{:requires-features #{:basic-aggregations}} distinct, field-or-expression FieldOrExpressionDef)
(defclause ^{:requires-features #{:basic-aggregations}} sum,      field-or-expression FieldOrExpressionDef)
(defclause ^{:requires-features #{:basic-aggregations}} min,      field-or-expression FieldOrExpressionDef)
(defclause ^{:requires-features #{:basic-aggregations}} max,      field-or-expression FieldOrExpressionDef)

(defclause ^{:requires-features #{:basic-aggregations}} sum-where
  field-or-expression FieldOrExpressionDef, pred Filter)

(defclause ^{:requires-features #{:basic-aggregations}} count-where
  pred Filter)

(defclause ^{:requires-features #{:basic-aggregations}} share
  pred Filter)

(defclause ^{:requires-features #{:standard-deviation-aggregations}} stddev
  field-or-expression FieldOrExpressionDef)

(declare ag:var) ;; for clj-kondo
(defclause ^{:requires-features #{:standard-deviation-aggregations}} [ag:var var]
  field-or-expression FieldOrExpressionDef)

(defclause ^{:requires-features #{:percentile-aggregations}} median
  field-or-expression FieldOrExpressionDef)

(defclause ^{:requires-features #{:percentile-aggregations}} percentile
  field-or-expression FieldOrExpressionDef, percentile NumericExpressionArg)


;; Metrics are just 'macros' (placeholders for other aggregations with optional filter and breakout clauses) that get
;; expanded to other aggregations/etc. in the expand-macros middleware
;;
;; METRICS WITH STRING IDS, e.g. `[:metric "ga:sessions"]`, are Google Analytics metrics, not Metabase metrics! They
;; pass straight thru to the GA query processor.
(defclause ^:sugar metric, metric-id (s/cond-pre helpers/IntGreaterThanZero helpers/NonBlankString))

;; the following are definitions for expression aggregations, e.g.
;;
;;    [:+ [:sum [:field 10 nil]] [:sum [:field 20 nil]]]

(def ^:private UnnamedAggregation*
  (s/if (partial is-clause? arithmetic-expressions)
    ArithmeticExpression
    (one-of count avg cum-count cum-sum distinct stddev sum min max metric share count-where
            sum-where case median percentile ag:var)))

(def ^:private UnnamedAggregation
  (s/recursive #'UnnamedAggregation*))

(def AggregationOptions
  "Additional options for any aggregation clause when wrapping it in `:aggregation-options`."
  {;; name to use for this aggregation in the native query instead of the default name (e.g. `count`)
   (s/optional-key :name)         helpers/NonBlankString
   ;; user-facing display name for this aggregation instead of the default one
   (s/optional-key :display-name) helpers/NonBlankString
   s/Keyword                      s/Any})

(defclause aggregation-options
  aggregation UnnamedAggregation
  options     AggregationOptions)

(def Aggregation
  "Schema for anything that is a valid `:aggregation` clause."
  (s/if (partial is-clause? :aggregation-options)
    aggregation-options
    UnnamedAggregation))


;;; ---------------------------------------------------- Order-By ----------------------------------------------------

;; order-by is just a series of `[<direction> <field>]` clauses like
;;
;;    {:order-by [[:asc [:field 1 nil]], [:desc [:field 2 nil]]]}
;;
;; Field ID is implicit in these clauses

(defclause asc,  field FieldOrAggregationReference)
(defclause desc, field FieldOrAggregationReference)

(def OrderBy
  "Schema for an `order-by` clause subclause."
  (one-of asc desc))


;;; +----------------------------------------------------------------------------------------------------------------+
;;; |                                                    Queries                                                     |
;;; +----------------------------------------------------------------------------------------------------------------+

;;; ---------------------------------------------- Native [Inner] Query ----------------------------------------------

;; Template tags are used to specify {{placeholders}} in native queries that are replaced with some sort of value when
;; the query itself runs. There are four basic types of template tag for native queries:
;;
;; 1. Field filters, which are used like
;;
;;        SELECT * FROM table WHERE {{field_filter}}
;;
;;   These reference specific Fields and are replaced with entire conditions, e.g. `some_field > 1000`
;;
;; 2. Raw values, which are used like
;;
;;        SELECT * FROM table WHERE my_field = {{x}}
;;
;;   These are replaced with raw values.
;;
;; 3. Native query snippets, which might be used like
;;
;;        SELECT * FROM ({{snippet: orders}}) source
;;
;;    These are replaced with `NativeQuerySnippet`s from the application database.
;;
;; 4. Source query Card IDs, which are used like
;;
;;        SELECT * FROM ({{#123}}) source
;;
;;   These are replaced with the query from the Card with that ID.
;;
;; Field filters and raw values usually have their value specified by `:parameters` (see [[Parameters]] below).

(def template-tag-types
  "List of valid template tag types."
  [:snippet :card :dimension :number :text :date])

(def TemplateTagType
  "Schema for valid values of template tag `:type`."
  (apply s/enum template-tag-types))

(def ^:private TemplateTag:Common
  "Things required by all template tag types."
  {;; TODO -- `:id` is actually 100% required but we have a lot of tests that don't specify it because this constraint
   ;; wasn't previously enforced; we need to go in and fix those tests and make this non-optional
   (s/optional-key :id) helpers/NonBlankString
   :name                helpers/NonBlankString
   :display-name        helpers/NonBlankString
   s/Keyword            s/Any})

;; Example:
;;
;;    {:id           "c2fc7310-44eb-4f21-c3a0-63806ffb7ddd"
;;     :name         "snippet: select"
;;     :display-name "Snippet: select"
;;     :type         :snippet
;;     :snippet-name "select"
;;     :snippet-id   1}
(def TemplateTag:Snippet
  "Schema for a native query snippet template tag."
  (merge
   TemplateTag:Common
   {:type                      (s/eq :snippet)
    :snippet-name              helpers/NonBlankString
    :snippet-id                helpers/IntGreaterThanZero
    ;; database to which this Snippet belongs. Doesn't always seen to be specified.
    (s/optional-key :database) helpers/IntGreaterThanZero}))

;; Example:
;;
;;    {:id           "fc5e14d9-7d14-67af-66b2-b2a6e25afeaf"
;;     :name         "#1635"
;;     :display-name "#1635"
;;     :type         :card
;;     :card-id      1635}
(def TemplateTag:SourceQuery
  "Schema for a source query template tag."
  (merge
   TemplateTag:Common
   {:type    (s/eq :card)
    :card-id helpers/IntGreaterThanZero}))

(def ^:private TemplateTag:Value:Common
  "Stuff shared between the Field filter and raw value template tag schemas."
  (merge
   TemplateTag:Common
   {;; default value for this parameter
    (s/optional-key :default)  s/Any
    ;; whether or not a value for this parameter is required in order to run the query
    (s/optional-key :required) s/Bool}))

(declare ParameterType)

;; Example:
;;
;;    {:id           "c20851c7-8a80-0ffa-8a99-ae636f0e9539"
;;     :name         "date"
;;     :display-name "Date"
;;     :type         :dimension,
;;     :dimension    [:field 4 nil]
;;     :widget-type  :date/all-options}
(def TemplateTag:FieldFilter
  "Schema for a field filter template tag."
  (merge
   TemplateTag:Value:Common
   {:type        (s/eq :dimension)
    :dimension   field
    ;; which type of widget the frontend should show for this Field Filter; this also affects which parameter types
    ;; are allowed to be specified for it.
    :widget-type (s/recursive #'ParameterType)}))

(def raw-value-template-tag-types
  "Set of valid values of `:type` for raw value template tags."
  #{:number :text :date :boolean})

(def TemplateTag:RawValue:Type
  "Valid values of `:type` for raw value template tags."
  (apply s/enum raw-value-template-tag-types))

;; Example:
;;
;;    {:id           "35f1ecd4-d622-6d14-54be-750c498043cb"
;;     :name         "id"
;;     :display-name "Id"
;;     :type         :number
;;     :required     true
;;     :default      "1"}
(def TemplateTag:RawValue
  "Schema for a raw value template tag."
  (merge
   TemplateTag:Value:Common
   ;; `:type` is used be the FE to determine which type of widget to display for the template tag, and to determine
   ;; which types of parameters are allowed to be passed in for this template tag.
   {:type TemplateTag:RawValue:Type}))

;; TODO -- if we were using core.spec here I would make this a multimethod-based spec instead and have it dispatch off
;; of `:type`. Then we could make it possible to add new types dynamically

(def TemplateTag
  "Schema for a template tag as specified in a native query. There are four types of template tags, differentiated by
  `:type` (see comments above)."
  (s/conditional
   #(core/= (:type %) :dimension) TemplateTag:FieldFilter
   #(core/= (:type %) :snippet)   TemplateTag:Snippet
   #(core/= (:type %) :card)      TemplateTag:SourceQuery
   :else                          TemplateTag:RawValue))

(def TemplateTagMap
  "Schema for the `:template-tags` map passed in as part of a native query."
  ;; map of template tag name -> template tag definition
  (-> {helpers/NonBlankString TemplateTag}
      ;; make sure people don't try to pass in a `:name` that's different from the actual key in the map.
      (s/constrained (fn [m]
                      (every? (fn [[tag-name tag-definition]]
                                (core/= tag-name (:name tag-definition)))
                              m))
                    "keys in template tag map must match the :name of their values")))

(def NativeQuery
  "Schema for a valid, normalized native [inner] query."
  {:query                          s/Any
   (s/optional-key :template-tags) TemplateTagMap
   ;; collection (table) this query should run against. Needed for MongoDB
   (s/optional-key :collection)    (s/maybe helpers/NonBlankString)
   ;; other stuff gets added in my different bits of QP middleware to record bits of state or pass info around.
   ;; Everyone else can ignore them.
   s/Keyword                       s/Any})


;;; ----------------------------------------------- MBQL [Inner] Query -----------------------------------------------

(declare Query MBQLQuery)

(def SourceQuery
  "Schema for a valid value for a `:source-query` clause."
  (s/if (every-pred map? :native)
    ;; when using native queries as source queries the schema is exactly the same except use `:native` in place of
    ;; `:query` for reasons I do not fully remember (perhaps to make it easier to differentiate them from MBQL source
    ;; queries).
    (set/rename-keys NativeQuery {:query :native})
    (s/recursive #'MBQLQuery)))

(def SourceQueryMetadata
  "Schema for the expected keys for a single column in `:source-metadata` (`:source-metadata` is a sequence of these
  entries), if it is passed in to the query.

  This metadata automatically gets added for all source queries that are referenced via the `card__id` `:source-table`
  form; for explicit `:source-query`s you should usually include this information yourself when specifying explicit
  `:source-query`s."
  ;; TODO - there is a very similar schema in `metabase.sync.analyze.query-results`; see if we can merge them
  {:name                           helpers/NonBlankString
   :base_type                      helpers/FieldType
   ;; this is only used by the annotate post-processing stage, not really needed at all for pre-processing, might be
   ;; able to remove this as a requirement
   :display_name                   helpers/NonBlankString
   (s/optional-key :semantic_type) (s/maybe helpers/FieldSemanticOrRelationType)
   ;; you'll need to provide this in order to use BINNING
   (s/optional-key :fingerprint)   (s/maybe helpers/Map)
   s/Any                           s/Any})

(def source-table-card-id-regex
  "Pattern that matches `card__id` strings that can be used as the `:source-table` of MBQL queries."
  #"^card__[1-9]\d*$")

(def SourceTable
  "Schema for a valid value for the `:source-table` clause of an MBQL query."
  (s/cond-pre helpers/IntGreaterThanZero source-table-card-id-regex))

(def join-strategies
  "Valid values of the `:strategy` key in a join map."
  #{:left-join :right-join :inner-join :full-join})

(def JoinStrategy
  "Strategy that should be used to perform the equivalent of a SQL `JOIN` against another table or a nested query.
  These correspond 1:1 to features of the same name in driver features lists; e.g. you should check that the current
  driver supports `:full-join` before generating a Join clause using that strategy."
  (apply s/enum join-strategies))

(declare Fields)

(def Join
  "Perform the equivalent of a SQL `JOIN` with another Table or nested `:source-query`. JOINs are either explicitly
  specified in the incoming query, or implicitly generated when one uses a `:field` clause with `:source-field`.

  In the top-level query, you can reference Fields from the joined table or nested query by including `:source-field`
  in the `:field` options (known as implicit joins); for explicit joins, you *must* specify `:join-alias` yourself; in
  the `:field` options, e.g.

    ;; for joins against other Tables/MBQL source queries
    [:field 1 {:join-alias \"my_join_alias\"}]

    ;; for joins against native queries
    [:field \"my_field\" {:base-type :field/Integer, :join-alias \"my_join_alias\"}]"
  (->
   {;; *What* to JOIN. Self-joins can be done by using the same `:source-table` as in the query where this is specified.
    ;; YOU MUST SUPPLY EITHER `:source-table` OR `:source-query`, BUT NOT BOTH!
    (s/optional-key :source-table)
    SourceTable

    (s/optional-key :source-query)
    SourceQuery
    ;;
    ;; The condition on which to JOIN. Can be anything that is a valid `:filter` clause. For automatically-generated
    ;; JOINs this is always
    ;;
    ;;    [:= <source-table-fk-field> [:field <dest-table-pk-field> {:join-alias <join-table-alias>}]]
    ;;
    :condition
    Filter
    ;;
    ;; Defaults to `:left-join`; used for all automatically-generated JOINs
    ;;
    ;; Driver implementations: this is guaranteed to be present after pre-processing.
    (s/optional-key :strategy)
    JoinStrategy
    ;;
    ;; The Fields to include in the results *if* a top-level `:fields` clause *is not* specified. This can be either
    ;; `:none`, `:all`, or a sequence of Field clauses.
    ;;
    ;; *  `:none`: no Fields from the joined table or nested query are included (unless indirectly included by
    ;;    breakouts or other clauses). This is the default, and what is used for automatically-generated joins.
    ;;
    ;; *  `:all`: will include all of the Fields from the joined table or query
    ;;
    ;; *  a sequence of Field clauses: include only the Fields specified. Valid clauses are the same as the top-level
    ;;    `:fields` clause. This should be non-empty and all elements should be distinct. The normalizer will
    ;;    automatically remove duplicate fields for you, and replace empty clauses with `:none`.
    ;;
    ;; Driver implementations: you can ignore this clause. Relevant fields will be added to top-level `:fields` clause
    ;; with appropriate aliases.
    (s/optional-key :fields)
    (s/named
     (s/cond-pre
      (s/enum :all :none)
      (s/recursive #'Fields))
     "Valid Join `:fields`: `:all`, `:none`, or a sequence of `:field` clauses that have `:join-alias`.")
    ;;
    ;; The name used to alias the joined table or query. This is usually generated automatically and generally looks
    ;; like `table__via__field`. You can specify this yourself if you need to reference a joined field with a
    ;; `:join-alias` in the options.
    ;;
    ;; Driver implementations: This is guaranteed to be present after pre-processing.
    (s/optional-key :alias)
    helpers/NonBlankString
    ;;
    ;; Used internally, only for annotation purposes in post-processing. When a join is implicitly generated via a
    ;; `:field` clause with `:source-field`, the ID of the foreign key field in the source Table will
    ;; be recorded here. This information is used to add `fk_field_id` information to the `:cols` in the query
    ;; results; I believe this is used to facilitate drill-thru? :shrug:
    ;;
    ;; Don't set this information yourself. It will have no effect.
    (s/optional-key :fk-field-id)
    (s/maybe helpers/IntGreaterThanZero)
    ;;
    ;; Metadata about the source query being used, if pulled in from a Card via the `:source-table "card__id"` syntax.
    ;; added automatically by the `resolve-card-id-source-tables` middleware.
    (s/optional-key :source-metadata)
    (s/maybe [SourceQueryMetadata])

    s/Keyword s/Any}
   (s/constrained
    (every-pred
     (some-fn :source-table :source-query)
     (complement (every-pred :source-table :source-query)))
    "Joins must have either a `source-table` or `source-query`, but not both.")))

(def Joins
  "Schema for a valid sequence of `Join`s. Must be a non-empty sequence, and `:alias`, if specified, must be unique."
  (s/constrained
   (helpers/non-empty [Join])
   #(helpers/empty-or-distinct? (filter some? (map :alias %)))
   "All join aliases must be unique."))

(def Fields
  "Schema for valid values of the MBQL `:fields` clause."
  (s/named
   (helpers/distinct (helpers/non-empty [Field]))
   "Distinct, non-empty sequence of Field clauses"))

(def MBQLQuery
  "Schema for a valid, normalized MBQL [inner] query."
  (->
   {(s/optional-key :source-query) SourceQuery
    (s/optional-key :source-table) SourceTable
    (s/optional-key :aggregation)  (helpers/non-empty [Aggregation])
    (s/optional-key :breakout)     (helpers/non-empty [Field])
    (s/optional-key :expressions)  {helpers/NonBlankString FieldOrExpressionDef}
    (s/optional-key :fields)       Fields
    (s/optional-key :filter)       Filter
    (s/optional-key :limit)        helpers/IntGreaterThanOrEqualToZero
    (s/optional-key :order-by)     (helpers/distinct (helpers/non-empty [OrderBy]))
    ;; page = page num, starting with 1. items = number of items per page.
    ;; e.g.
    ;; {:page 1, :items 10} = items 1-10
    ;; {:page 2, :items 10} = items 11-20
    (s/optional-key :page)         {:page  helpers/IntGreaterThanZero
                                    :items helpers/IntGreaterThanZero}
    ;;
    ;; Various bits of middleware add additonal keys, such as `fields-is-implicit?`, to record bits of state or pass
    ;; info to other pieces of middleware. Everyone else can ignore them.
    (s/optional-key :joins)        Joins
    ;;
    ;; Info about the columns of the source query. Added in automatically by middleware. This metadata is primarily
    ;; used to let power things like binning when used with Field Literals instead of normal Fields
    (s/optional-key :source-metadata) (s/maybe [SourceQueryMetadata])
    ;;
    ;; Other keys are added by middleware or frontend client for various purposes
    s/Keyword                      s/Any}

   (s/constrained
    (fn [query]
      (core/= 1 (core/count (select-keys query [:source-query :source-table]))))
    "Query must specify either `:source-table` or `:source-query`, but not both.")

   (s/constrained
    (fn [{:keys [breakout fields]}]
      (empty? (set/intersection (set breakout) (set fields))))
    "Fields specified in `:breakout` should not be specified in `:fields`; this is implied.")))


;;; ----------------------------------------------------- Params -----------------------------------------------------

;; `:parameters` specify the *values* of parameters previously definied for a Dashboard or Card (native query template
;; tag parameters.) See [[TemplateTag]] above for more information on the later.

;; There are three things called 'type' in play when we talk about parameters and template tags.
;;
;; Two are used when the parameters are specified/declared, in a [[TemplateTag]] or in a Dashboard parameter:
;;
;; 1. Dashboard parameter/template tag `:type` -- `:dimension` (for a Field filter parameter),
;;    otherwise `:text`, `:number`, `:boolean`, or `:date`
;;
;; 2. `:widget-type` -- only specified for Field filter parameters (where type is `:dimension`). This tells the FE
;;    what type of widget to display, and also tells us what types of parameters we should allow. Examples:
;;    `:date/all-options`, `:category`, etc.
;;
;; One type is used in the [[Parameter]] list (`:parameters`):
;;
;; 3. Parameter `:type` -- specifies the type of the value being passed in. e.g. `:text` or `:string/!=`
;;
;; Note that some types that makes sense as widget types (e.g. `:date/all-options`) but not as actual value types are
;; currently still allowed for backwards-compatibility purposes -- currently the FE client will just parrot back the
;; `:widget-type` in some cases. In these cases, the backend is just supposed to infer the actual type of the
;; parameter value.

(def parameter-types
  "Map of parameter-type -> info. Info is a map with the following keys:

  ### `:type`

  The general type of this parameter. `:numeric`, `:string`, `:boolean`, or `:date`, if applicable. Some parameter
  types like `:id` and `:category` don't have a particular `:type`. This is offered mostly so we can group stuff
  together or determine things like whether a given parameter is a date parameter.

  ### `:operator`

  Signifies this is one of the new 'operator' parameter types added in 0.39.0 or so. These parameters can only be used
  for [[TemplateTag:FieldFilter]]s or for Dashboard parameters mapped to MBQL queries. The value of this key is the
  arity for the parameter, either `:unary`, `:binary`, or `:variadic`. See
  the [[metabase.driver.common.parameters.operators]] namespace for more information.

  ### `:allowed-for`

  [[Parameter]]s with this `:type` may be supplied for [[TemplateTag]]s with these `:type`s (or `:widget-type` if
  `:type` is `:dimension`) types. Example: it is ok to pass a parameter of type `:date/range` for template tag with
  `:widget-type` `:date/all-options`; but it is NOT ok to pass a parameter of type `:date/range` for a template tag
  with a widget type `:date`. Why? It's a potential security risk if someone creates a Card with an \"exact-match\"
  Field filter like `:date` or `:text` and you pass in a parameter like `string/!=` `NOTHING_WILL_MATCH_THIS`.
  Non-exact-match parameters can be abused to enumerate *all* the rows in a table when the parameter was supposed to
  lock the results down to a single row or set of rows."
  {;; the basic raw-value types. These can be used with [[TemplateTag:RawValue]] template tags as well as
   ;; [[TemplateTag:FieldFilter]] template tags.
   :number  {:type :numeric, :allowed-for #{:number :number/= :id :category :location/zip_code}}
   :text    {:type :string,  :allowed-for #{:text :string/= :id :category
                                            :location/city :location/state :location/zip_code :location/country}}
   :date    {:type :date,    :allowed-for #{:date :date/single :date/all-options :id :category}}
   ;; I don't think `:boolean` is actually used on the FE at all.
   :boolean {:type :boolean, :allowed-for #{:boolean :id :category}}

   ;; as far as I can tell this is basically just an alias for `:date`... I'm not sure what the difference is TBH
   :date/single {:type :date, :allowed-for #{:date :date/single :date/all-options :id :category}}

   ;; everything else can't be used with raw value template tags -- they can only be used with Dashboard parameters
   ;; for MBQL queries or Field filters in native queries

   ;; `:id` and `:category` conceptually aren't types in a "the parameter value is of this type" sense, but they are
   ;; widget types. They have something to do with telling the frontend to show FieldValues list/search widgets or
   ;; something like that.
   ;;
   ;; Apparently the frontend might still pass in parameters with these types, in which case we're supposed to infer
   ;; the actual type of the parameter based on the Field we're filtering on. Or something like that. Parameters with
   ;; these types are only allowed if the widget type matches exactly, but you can also pass in something like a
   ;; `:number/=` for a parameter with widget type `:category`.
   ;;
   ;; TODO FIXME -- actually, it turns out the the FE client passes parameter type `:category` for parameters in
   ;; public Cards. Who knows why! For now, we'll continue allowing it. But we should fix it soon. See
   ;; [[metabase.api.public-test/execute-public-card-with-parameters-test]]
   :id       {:allowed-for #{:id}}
   :category {:allowed-for #{:category #_FIXME :number :text :date :boolean}}

   ;; Like `:id` and `:category`, the `:location/*` types are primarily widget types. They don't really have a meaning
   ;; as a parameter type, so in an ideal world they wouldn't be allowed; however it seems like the FE still passed
   ;; these in as parameter type on occasion anyway. In this case the backend is just supposed to infer the actual
   ;; type -- which should be `:text` and, in the case of ZIP code, possibly `:number`.
   ;;
   ;; As with `:id` and `:category`, it would be preferable to just pass in a parameter with type `:text` or `:number`
   ;; for these widget types, but for compatibility we'll allow them to continue to be used as parameter types for the
   ;; time being. We'll only allow that if the widget type matches exactly, however.
   :location/city     {:allowed-for #{:location/city}}
   :location/state    {:allowed-for #{:location/state}}
   :location/zip_code {:allowed-for #{:location/zip_code}}
   :location/country  {:allowed-for #{:location/country}}

   ;; date range types -- these match a range of dates
   :date/range        {:type :date, :allowed-for #{:date/range :date/all-options}}
   :date/month-year   {:type :date, :allowed-for #{:date/month-year :date/all-options}}
   :date/quarter-year {:type :date, :allowed-for #{:date/quarter-year :date/all-options}}
   :date/relative     {:type :date, :allowed-for #{:date/relative :date/all-options}}

   ;; Like `:id` and `:category` above, `:date/all-options` is primarily a widget type. It means that we should allow
   ;; any date option above.
   :date/all-options {:type :date, :allowed-for #{:date/all-options}}

   ;; "operator" parameter types.
   :number/!=               {:type :numeric, :operator :variadic, :allowed-for #{:number/!=}}
   :number/<=               {:type :numeric, :operator :unary, :allowed-for #{:number/<=}}
   :number/=                {:type :numeric, :operator :variadic, :allowed-for #{:number/= :number :id :category
                                                                                 :location/zip_code}}
   :number/>=               {:type :numeric, :operator :unary, :allowed-for #{:number/>=}}
   :number/between          {:type :numeric, :operator :binary, :allowed-for #{:number/between}}
   :string/!=               {:type :string, :operator :variadic, :allowed-for #{:string/!=}}
   :string/=                {:type :string, :operator :variadic, :allowed-for #{:string/= :text :id :category
                                                                                 :location/city :location/state
                                                                                 :location/zip_code :location/country}}
   :string/contains         {:type :string, :operator :unary, :allowed-for #{:string/contains}}
   :string/does-not-contain {:type :string, :operator :unary, :allowed-for #{:string/does-not-contain}}
   :string/ends-with        {:type :string, :operator :unary, :allowed-for #{:string/ends-with}}
   :string/starts-with      {:type :string, :operator :unary, :allowed-for #{:string/starts-with}}})

(defn valid-parameter-type?
  "Whether `param-type` is a valid non-abstract parameter type."
  [param-type]
  (get parameter-types param-type))

(def ParameterType
  "Schema for valid values of `:type` for a [[Parameter]]."
  (apply s/enum (keys parameter-types)))

;; the next few clauses are used for parameter `:target`... this maps the parameter to an actual template tag in a
;; native query or Field for MBQL queries.
;;
;; examples:
;;
;;    {:target [:dimension [:template-tag "my_tag"]]}
;;    {:target [:dimension [:template-tag {:id "my_tag_id"}]]}
;;    {:target [:variable [:template-tag "another_tag"]]}
;;    {:target [:variable [:template-tag {:id "another_tag_id"}]]}
;;    {:target [:dimension [:field 100 nil]]}
;;    {:target [:field 100 nil]}
;;
;; I'm not 100% clear on which situations we'll get which version. But I think the following is generally true:
;;
;; * Things are wrapped in `:dimension` when we're dealing with Field filter template tags
;; * Raw value template tags wrap things in `:variable` instead
;; * Dashboard parameters are passed in with plain Field clause targets.
;;
;; One more thing to note: apparently `:expression`... is allowed below as well. I'm not sure how this is actually
;; supposed to work, but we have test #18747 that attempts to set it. I'm not convinced this should actually be
;; allowed.

;; this is the reference like [:template-tag <whatever>], not the [[TemplateTag]] schema for when it's declared in
;; `:template-tags`
(defclause template-tag
  tag-name
  (s/cond-pre helpers/NonBlankString
              {:id helpers/NonBlankString}))

(defclause dimension
  target (s/cond-pre Field template-tag))

(defclause variable
  target template-tag)

(def ParameterTarget
  "Schema for the value of `:target` in a [[Parameter]]."
  ;; not 100% sure about this but `field` on its own comes from a Dashboard parameter and when it's wrapped in
  ;; `dimension` it comes from a Field filter template tag parameter (don't quote me on this -- working theory)
  (s/cond-pre
   Field
   (one-of dimension variable)))

(def Parameter
  "Schema for the *value* of a parameter (e.g. a Dashboard parameter or a native query template tag) as passed in as
  part of the `:parameters` list in a query."
  {:type                     ParameterType
   ;; TODO -- these definitely SHOULD NOT be optional but a ton of tests aren't passing them in like they should be.
   ;; At some point we need to go fix those tests and then make these keys required
   (s/optional-key :id)      helpers/NonBlankString
   (s/optional-key :target)  ParameterTarget
   ;; not specified if the param has no value. TODO - make this stricter; type of `:value` should be validated based
   ;; on the [[ParameterType]]
   (s/optional-key :value)   s/Any
   ;; the name of the parameter we're trying to set -- this is actually required now I think, or at least needs to get
   ;; merged in appropriately
   (s/optional-key :name)    helpers/NonBlankString
   ;; The following are not used by the code in this namespace but may or may not be specified depending on what the
   ;; code that constructs the query params is doing. We can go ahead and ignore these when present.
   (s/optional-key :slug)    helpers/NonBlankString
   (s/optional-key :default) s/Any
   ;; various other keys are used internally by the frontend
   s/Keyword                 s/Any})

(def ParameterList
  "Schema for a list of `:parameters` as passed in to a query."
  [Parameter]
  #_(->
     ;; TODO -- disabled for now since it breaks tests. Also, I'm not sure whether these should be distinct by
     ;; `:name` or `:id`... at any rate, neither is currently required.
     ;;
     (s/constrained (fn [parameters]
                      (apply distinct? (map :id parameters)))
                    "Cannot specify parameter more than once; IDs must be distinct")))

;;; ---------------------------------------------------- Options -----------------------------------------------------

(def ^:private Settings
  "Options that tweak the behavior of the query processor."
  ;; The timezone the query should be ran in, overriding the default report timezone for the instance.
  {(s/optional-key :report-timezone) helpers/NonBlankString
   ;; other Settings might be used somewhere, but I don't know about them. Add them if you come across them for
   ;; documentation purposes
   s/Keyword                         s/Any})

(def ^:private Constraints
  "Additional constraints added to a query limiting the maximum number of rows that can be returned. Mostly useful
  because native queries don't support the MBQL `:limit` clause. For MBQL queries, if `:limit` is set, it will
  override these values."
  (s/constrained
   { ;; maximum number of results to allow for a query with aggregations. If `max-results-bare-rows` is unset, this
    ;; applies to all queries
    (s/optional-key :max-results)           helpers/IntGreaterThanOrEqualToZero
    ;; maximum number of results to allow for a query with no aggregations.
    ;; If set, this should be LOWER than `:max-results`
    (s/optional-key :max-results-bare-rows) helpers/IntGreaterThanOrEqualToZero
    ;; other Constraints might be used somewhere, but I don't know about them. Add them if you come across them for
    ;; documentation purposes
    s/Keyword                               s/Any}
   (fn [{:keys [max-results max-results-bare-rows]}]
     (if-not (core/and max-results max-results-bare-rows)
       true
       (core/>= max-results max-results-bare-rows)))
   "max-results-bare-rows must be less or equal to than max-results"))

(def ^:private MiddlewareOptions
  "Additional options that can be used to toggle middleware on or off."
  {;; should we skip adding results_metadata to query results after running the query? Used by
   ;; `metabase.query-processor.middleware.results-metadata`; default `false`
   (s/optional-key :skip-results-metadata?)
   s/Bool

   ;; should we skip converting datetime types to ISO-8601 strings with appropriate timezone when post-processing
   ;; results? Used by `metabase.query-processor.middleware.format-rows`; default `false`
   (s/optional-key :format-rows?)
   s/Bool

   ;; disable the MBQL->native middleware. If you do this, the query will not work at all, so there are no cases where
   ;; you should set this yourself. This is only used by the [[metabase.query-processor/preprocess]] function to get
   ;; the fully pre-processed query without attempting to convert it to native.
   (s/optional-key :disable-mbql->native?)
   s/Bool

   ;; Userland queries are ones ran as a result of an API call, Pulse, or the like. Special handling is done in the
   ;; `process-userland-query` middleware for such queries -- results are returned in a slightly different format, and
   ;; QueryExecution entries are normally saved, unless you pass `:no-save` as the option.
   (s/optional-key :userland-query?)
   (s/maybe s/Bool)

   ;; Whether to add some default `max-results` and `max-results-bare-rows` constraints. By default, none are added,
   ;; although the functions that ultimately power most API endpoints tend to set this to `true`. See
   ;; `add-constraints` middleware for more details.
   (s/optional-key :add-default-userland-constraints?)
   (s/maybe s/Bool)

   ;; Whether to process a question's visualization settings and include them in the result metadata so that they can
   ;; incorporated into an export. Used by `metabase.query-processor.middleware.visualization-settings`; default `false`.
   (s/optional-key :process-viz-settings?)
   (s/maybe s/Bool)

   ;; other middleware options might be used somewhere, but I don't know about them. Add them if you come across them
   ;; for documentation purposes
   s/Keyword
   s/Any})


;;; ------------------------------------------------------ Info ------------------------------------------------------

;; This stuff is used for informational purposes, primarily to record QueryExecution entries when a query is ran. Pass
;; them along if applicable when writing code that creates queries, but when working on middleware and the like you
;; can most likely ignore this stuff entirely.

(def Context
  "Schema for `info.context`; used for informational purposes to record how a query was executed."
  (s/enum :ad-hoc
          :collection
          :csv-download
          :dashboard
          :embedded-dashboard
          :embedded-question
          :json-download
          :map-tiles
          :public-dashboard
          :public-question
          :pulse
          :question
          :xlsx-download))

;; TODO - this schema is somewhat misleading because if you use a function like
;; `qp/process-query-and-save-with-max-results-constraints!` some of these keys (e.g. `:context`) are in fact required
(def Info
  "Schema for query `:info` dictionary, which is used for informational purposes to record information about how a query
  was executed in QueryExecution and other places. It is considered bad form for middleware to change its behavior
  based on this information, don't do it!"
  {;; These keys are nice to pass in if you're running queries on the backend and you know these values. They aren't
   ;; used for permissions checking or anything like that so don't try to be sneaky
   (s/optional-key :context)      (s/maybe Context)
   (s/optional-key :executed-by)  (s/maybe helpers/IntGreaterThanZero)
   (s/optional-key :card-id)      (s/maybe helpers/IntGreaterThanZero)
   (s/optional-key :card-name)    (s/maybe helpers/NonBlankString)
   (s/optional-key :dashboard-id) (s/maybe helpers/IntGreaterThanZero)
   (s/optional-key :pulse-id)     (s/maybe helpers/IntGreaterThanZero)
   ;; Metadata for datasets when querying the dataset. This ensures that user edits to dataset metadata are blended in
   ;; with runtime computed metadata so that edits are saved.
   (s/optional-key :metadata/dataset-metadata) (s/maybe [{s/Any s/Any}])
   ;; `:hash` gets added automatically by `process-query-and-save-execution!`, so don't try passing
   ;; these in yourself. In fact, I would like this a lot better if we could take these keys out of `:info` entirely
   ;; and have the code that saves QueryExceutions figure out their values when it goes to save them
   (s/optional-key :query-hash) (s/maybe #?(:clj (Class/forName "[B")
                                            :cljs s/Any))})


;;; --------------------------------------------- Metabase [Outer] Query ---------------------------------------------

(def ^Integer saved-questions-virtual-database-id
  "The ID used to signify that a database is 'virtual' rather than physical.

   A fake integer ID is used so as to minimize the number of changes that need to be made on the frontend -- by using
   something that would otherwise be a legal ID, *nothing* need change there, and the frontend can query against this
   'database' none the wiser. (This integer ID is negative which means it will never conflict with a *real* database
   ID.)

   This ID acts as a sort of flag. The relevant places in the middleware can check whether the DB we're querying is
   this 'virtual' database and take the appropriate actions."
  -1337)
;; To the reader: yes, this seems sort of hacky, but one of the goals of the Nested Query Initiative™ was to minimize
;; if not completely eliminate any changes to the frontend. After experimenting with several possible ways to do this
;; implementation seemed simplest and best met the goal. Luckily this is the only place this "magic number" is defined
;; and the entire frontend can remain blissfully unaware of its value.

(def DatabaseID
  "Schema for a valid `:database` ID, in the top-level 'outer' query. Either a positive integer (referring to an
  actual Database), or the saved questions virtual ID, which is a placeholder used for queries using the
  `:source-table \"card__id\"` shorthand for a source query resolved by middleware (since clients might not know the
  actual DB for that source query.)"
  (s/cond-pre (s/eq saved-questions-virtual-database-id) helpers/IntGreaterThanZero))

(def Query
  "Schema for an [outer] query, e.g. the sort of thing you'd pass to the query processor or save in
  `Card.dataset_query`."
  (->
   {:database                         DatabaseID
    ;; Type of query. `:query` = MBQL; `:native` = native. TODO - consider normalizing `:query` to `:mbql`
    :type                             (s/enum :query :native)
    (s/optional-key :native)          NativeQuery
    (s/optional-key :query)           MBQLQuery
    (s/optional-key :parameters)      ParameterList
    ;;
    ;; OPTIONS
    ;;
    ;; These keys are used to tweak behavior of the Query Processor.
    ;; TODO - can we combine these all into a single `:options` map?
    ;;
    (s/optional-key :settings)        (s/maybe Settings)
    (s/optional-key :constraints)     (s/maybe Constraints)
    (s/optional-key :middleware)      (s/maybe MiddlewareOptions)
    ;;
    ;; INFO
    ;;
    ;; Used when recording info about this run in the QueryExecution log; things like context query was ran in and
    ;; User who ran it
    (s/optional-key :info)            (s/maybe Info)
    ;;
    ;; Other various keys get stuck in the query dictionary at some point or another by various pieces of QP
    ;; middleware to record bits of state. Everyone else can ignore them.
    s/Keyword                         s/Any}
   ;;
   ;; CONSTRAINTS
   ;;
   ;; Make sure we have the combo of query `:type` and `:native`/`:query`
   (s/constrained
    (every-pred
     (some-fn :native :query)
     (complement (every-pred :native :query)))
    "Query must specify either `:native` or `:query`, but not both.")
   (s/constrained
    (fn [{native :native, mbql :query, query-type :type}]
      (core/case query-type
        :native native
        :query  mbql))
    "Native queries must specify `:native`; MBQL queries must specify `:query`.")
   ;;
   ;; `:source-metadata` is added to queries when `card__id` source queries are resolved. It contains info about the
   ;; columns in the source query.
   ;;
   ;; Where this is added was changed in Metabase 0.33.0 -- previously, when `card__id` source queries were resolved,
   ;; the middleware would add `:source-metadata` to the top-level; to support joins against source queries, this has
   ;; been changed so it is always added at the same level the resolved `:source-query` is added.
   ;;
   ;; This should automatically be fixed by `normalize`; if we encounter it, it means some middleware is not
   ;; functioning properly
   (s/constrained
    (complement :source-metadata)
    "`:source-metadata` should be added in the same level as `:source-query` (i.e., the 'inner' MBQL query.)")))


;;; --------------------------------------------------- Validators ---------------------------------------------------

(def ^{:arglists '([query])} validate-query
  "Compiled schema validator for an [outer] Metabase query. (Pre-compling a validator is more efficient; use this
  instead of calling `(s/validate Query query)` or similar."
  (s/validator Query))
