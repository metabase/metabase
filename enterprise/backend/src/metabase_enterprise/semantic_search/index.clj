(ns metabase-enterprise.semantic-search.index
  (:require
   [clojure.string :as str]
   [honey.sql :as sql]
   [honey.sql.helpers :as sql.helpers]
   [metabase-enterprise.semantic-search.db :as db]
   [metabase-enterprise.semantic-search.embedding :as embedding]
   [metabase.models.interface :as mi]
   [metabase.search.core :as search]
   [metabase.util :as u]
   [metabase.util.json :as json]
   [metabase.util.log :as log]
   [nano-id.core :as nano-id]
   [next.jdbc :as jdbc]
   [toucan2.core :as t2])
  (:import
   [java.time LocalDate]
   [org.postgresql.util PGobject]))

(set! *warn-on-reflection* true)

(def ^:dynamic *index-table-name*
  "The name of the index table used for semantic search."
  :search_index)

(def ^:dynamic *batch-size*
  "The number of documents to process per batch when updating the index."
  150)

(defn- index-table-schema
  "Schema for the index table."
  [vector-dimensions]
  ;; Generate unique constraint name to avoid index name conflicts between multiple test tables
  (let [unique-constraint-name (keyword (str "unique_constraint_" (nano-id/nano-id) "_model_model_id"))]
    [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
     [:model :text :not-null]
     [:model_id :text :not-null]
     [:created_at :timestamp-with-time-zone [:default [:raw "CURRENT_TIMESTAMP"]] :not-null]
     [:creator_id :int]
     [:model_created_at :timestamp-with-time-zone]
     [:last_editor_id :int]
     [:model_updated_at :timestamp-with-time-zone]
     [:archived :boolean [:default false]]
     [:verified :boolean]
     [:official_collection :boolean]
     [:legacy_input :jsonb]
     [:embedding [:raw (format "vector(%d)" vector-dimensions)] :not-null]
     [:content :text :not-null]
     [:metadata :jsonb]
     [[:constraint unique-constraint-name]
      [:unique [:composite :model :model_id]]]]))

(defn- format-embedding
  "Formats the embedding vector for SQL insertion."
  [embedding]
  (str "'[" (str/join ", " embedding) "]'::vector"))

(defn- doc->db-record
  "Convert a document to a database record with a provided embedding."
  [embedding-vec {:keys [model id searchable_text created_at creator_id updated_at
                         last_editor_id archived verified official_collection legacy_input] :as doc}]
  {:model               model
   :model_id            id
   :creator_id          creator_id
   :model_created_at    created_at
   :last_editor_id      last_editor_id
   :model_updated_at    updated_at
   :archived            archived
   :verified            verified
   :official_collection official_collection
   :embedding           [:raw (format-embedding embedding-vec)]
   :content             searchable_text
   :legacy_input        [:cast (json/encode legacy_input) :jsonb]
   :metadata            [:cast (json/encode doc) :jsonb]})

(defn- batch-update!
  ([records->sql documents embeddings]
   (batch-update! @db/data-source records->sql documents embeddings))
  ([connectable records->sql documents embeddings]
   (when (seq documents)
     (u/prog1 (transduce (comp (map (fn [[doc embedding]] (doc->db-record embedding doc)))
                               (partition-all *batch-size*)
                               (map (fn [db-records]
                                      (jdbc/execute! connectable (records->sql db-records))
                                      ;; TODO should this return (or at least log) the number of docs actually
                                      ;; updated, not just the number in the batch?
                                      (u/prog1 (->> db-records (map :model) frequencies)
                                        (log/trace "semantic search processed a batch of" (count db-records)
                                                   "documents with frequencies" <>)))))
                         (partial merge-with +)
                         (map vector documents embeddings))
       (log/trace "semantic search processed" (count documents) "total documents with frequencies" <>)))))

(defn- batch-delete-ids!
  ([model ids->sql ids]
   (batch-delete-ids! @db/data-source model ids->sql ids))
  ([connectable model ids->sql ids]
   (when (seq ids)
     (u/prog1 (->> (transduce (comp (partition-all *batch-size*)
                                    (map (fn [ids]
                                           (jdbc/execute! connectable (ids->sql ids))
                                           (u/prog1 (count ids)
                                             (log/trace "semantic search deleted a batch of" <>
                                                        "documents with model type" model)))))
                              +
                              ids)
                   (array-map model))
       (log/trace "semantic search deleted" <> "total documents with model type" model)))))

(defn populate-index!
  "Inserts a set of documents into the index table. Throws when trying to insert
  existing model + model_id pairs. (Use upsert-index! to update existing documents)"
  [documents]
  (when (seq documents)
    (let [texts (mapv :searchable_text documents)
          embeddings (embedding/get-embeddings-batch texts)]
      (batch-update!
       (fn [db-records]
         (-> (sql.helpers/insert-into *index-table-name*)
             (sql.helpers/values db-records)
             sql/format))
       documents
       embeddings))))

(defn- db-records->update-set
  [db-records]
  (let [update-keys (-> db-records first (dissoc :id :model :model_id) keys)
        excluded-kw (fn [column] (keyword (str "excluded." (name column))))]
    (zipmap update-keys (map excluded-kw update-keys))))

(comment
  (db-records->update-set
   [{:id 123
     :model "card"
     :model_id 123
     :creator_id 456
     :content "foo"}]))

(defn upsert-index!
  "Inserts or updates documents in the index table. If a document with the same
  model + model_id already exists, it will be replaced."
  [documents]
  (when (seq documents)
    (let [texts (mapv :searchable_text documents)
          embeddings (embedding/get-embeddings-batch texts)]
      (batch-update!
       (fn [db-records]
         (->
          (sql.helpers/insert-into *index-table-name*)
          (sql.helpers/values db-records)
          (sql.helpers/on-conflict :model :model_id)
          (sql.helpers/do-update-set (db-records->update-set db-records))
          sql/format))
       documents
       embeddings))))

(defn- drop-index-table-sql
  []
  (sql/format (sql.helpers/drop-table :if-exists *index-table-name*)))

(defn drop-index-table!
  "Drop the index table if it exists."
  ([]   (jdbc/execute! @db/data-source (drop-index-table-sql)))
  ([tx] (jdbc/execute! tx (drop-index-table-sql))))

(defn create-index-table!
  "Ensure that the index table exists and is ready to be populated. If
  force-reset? is true, drops and recreates the table if it exists."
  [{:keys [force-reset?] :or {force-reset? false}}]
  (try
    (let [vector-dimensions (embedding/model-dimensions)]
      (jdbc/with-transaction [tx @db/data-source]
        (jdbc/execute! tx (sql/format (sql.helpers/create-extension :vector :if-not-exists)))
        (when force-reset? (drop-index-table! tx))
        (jdbc/execute!
         tx
         (-> (sql.helpers/create-table *index-table-name*)
             (sql.helpers/with-columns (index-table-schema vector-dimensions))
             sql/format))
        (jdbc/execute!
         tx
         (-> (sql.helpers/create-index
              (keyword (str "embedding_hnsw_index_" (nano-id/nano-id)))
              [*index-table-name* :using-hnsw [:raw "embedding vector_cosine_ops"]])
             sql/format))))
    (catch Exception e
      (throw (ex-info "Failed to create index table" {:cause e})))))

(defn- search-filters
  "Generate WHERE conditions based on search context filters."
  [{:keys [archived? verified models created-at created-by last-edited-at last-edited-by]}]
  (let [conditions (filter some?
                           [(when (some? archived?)
                              [:= :archived archived?])
                            (when (some? verified)
                              [:= :verified verified])
                            (when (seq models)
                              [:in :model models])
                            (when (seq created-by)
                              [:in :creator_id created-by])
                            (when (seq last-edited-by)
                              [:in :last_editor_id last-edited-by])
                            (when (and created-at (:start created-at) (:end created-at))
                              [:between :model_created_at
                               (LocalDate/parse (:start created-at))
                               (LocalDate/parse (:end created-at))])
                            (when (and last-edited-at (:start last-edited-at) (:end last-edited-at))
                              [:between :model_updated_at
                               (LocalDate/parse (:start last-edited-at))
                               (LocalDate/parse (:end last-edited-at))])])]
    (when (seq conditions)
      (into [:and] conditions))))

(defn- semantic-search-query
  "Build a semantic search query using vector similarity."
  [embedding search-context]
  (let [filters (search-filters search-context)
        base-query {:select [[:model_id :model_id]
                             [:model :model]
                             [:content :content]
                             [:verified :verified]
                             [[:raw (str "embedding <=> " (format-embedding embedding))] :distance]
                             [:metadata :metadata]]
                    :from   [*index-table-name*]
                    :order-by [[:distance :asc]]
                    :limit  100}]
    (if filters
      (assoc base-query :where filters)
      base-query)))

(defn- legacy-input-with-score
  "Fetches the legacy_input field from a result's metadata and attaches a score based on the
  embedding distance."
  [row]
  (-> (get-in row [:metadata :legacy_input])
      (assoc :score (- 1.0 (:distance row 1.0)))))

;; TODO: can the query return unqualified keys directly?
(defn- unqualify-keys
  "Remove table namespace from namespaced keywords in a result row."
  [row]
  (into {} (map (fn [[k v]] [(keyword (name k)) v]) row)))

(defn- decode-pgobject
  "Decode a PGObject (returned from a jsonb field) into a Clojure map."
  [^PGobject obj]
  (json/decode (.getValue ^PGobject obj) true))

(defn- decode-metadata
  "Decode `row`s `:metadata`."
  [row]
  (update row :metadata decode-pgobject))

(defn- filter-read-permitted
  "Returns only those documents in `docs` whose corresponding t2 instances pass an mi/can-read? check for the bound api user."
  [docs]
  (let [doc->t2-model (fn [doc] (:model (search/spec (:model doc))))
        t2-instances  (for [[t2-model docs] (group-by doc->t2-model docs)
                            t2-instance     (t2/select t2-model :id [:in (map :id docs)])]
                        t2-instance)
        doc->t2       (comp (u/index-by (juxt :id t2/model) t2-instances)
                            (fn [doc]
                              [(:id doc) (doc->t2-model doc)]))]
    (filterv (fn [doc] (some-> doc doc->t2 mi/can-read?)) docs)))

(defn query-index
  "Query the index for documents similar to the search string."
  [search-context]
  (let [search-string (:search-string search-context)]
    (when-not (str/blank? search-string)
      (let [embedding   (embedding/get-embedding search-string)
            query       (semantic-search-query embedding search-context)
            xform       (comp (map unqualify-keys)
                              (map decode-metadata)
                              (map legacy-input-with-score))
            reducible   (jdbc/plan @db/data-source (sql/format query))]
        (-> (transduce xform conj [] reducible)
            filter-read-permitted)))))

(defn delete-from-index!
  "Deletes documents from the index table based on model and model_ids."
  [model model-ids]
  (batch-delete-ids!
   model
   (fn [batch-ids]
     (-> (sql.helpers/delete-from *index-table-name*)
         (sql.helpers/where [:and
                             [:= :model model]
                             [:in :model_id batch-ids]])
         sql/format))
   model-ids))

(comment
  (create-index-table! {:force-reset? true})
  (populate-index! [{:model "card"
                     :id "1"
                     :searchable_text "This is a test card"}])
  (upsert-index! [{:model "card"
                   :id "1"
                   :searchable_text "This is a test card"}])
  (delete-from-index! "card" ["1"])
  (delete-from-index! "dashboard" ["13"])
  ;; no user
  (query-index {:search-string "Copper knife"})

  #_:clj-kondo/ignore
  (require '[metabase.test :as mt])
  (mt/with-test-user :crowberto
    (doall (query-index {:search-string "Copper knife"}))))
