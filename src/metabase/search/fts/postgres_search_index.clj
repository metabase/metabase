(ns metabase.search.fts.postgres-search-index
  (:require
   [clojure.string :as str]
   [honey.sql :as sql]
   [honey.sql.helpers :as sql.helpers]
   [toucan2.core :as t2]))

(def ^:private pending-prefix "search_index_")

;; This is not multi-index safe.
(def next-index
  "The name of the index that we are currently populating."
  (atom nil))

(defn reindexing-target
  "The name of the target where our re-indexing process should write to."
  []
  (or @next-index (t2/table-name :model/SearchIndex)))

(defn pending-indexes
  "Get a list of all the non-active search index tables."
  []
  (t2/select-fn-vec (comp keyword :table_name)
                    :information_schema.tables
                    :table_name [:like (str pending-prefix "%")]))

(defn- create-pending-index!
  "Create a non-active search index table."
  []
  (let [table-name (keyword (str/replace (str pending-prefix (random-uuid)) #"-" "_"))]
    (t2/query (-> (sql.helpers/create-table table-name)
                  (sql.helpers/with-columns
                    [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
                    ;; entity
                     [:model_id :int :not-null]
                     [:model [:varchar 254] :not-null] ;; TODO find the right size
                    ;; search
                     [:search_vector :tsvector :not-null]
                    ;; scoring related
                     [:model_rank :int :not-null]
                    ;; permission related entities
                     [:collection_id :int]
                     [:database_id :int]
                     [:table_id :int]
                    ;; filter related
                     [:archived :boolean]])))
    (t2/query
     (format
      "CREATE INDEX IF NOT EXISTS %s_tsvector_idx ON %s USING gin (search_vector)"
      (name table-name)
      (name table-name)))
    ;; TODO not-null constraints, fk relations, etc
    (reset! next-index table-name)))

(defn- delete-pending-indexes!
  "Delete all the non-active search index tables."
  []
  (boolean
   (when-let [table-names (seq (pending-indexes))]
     (t2/query (apply sql.helpers/drop-table table-names)))))

(defn- table-exists? [table-name]
  (t2/exists? :information_schema.tables :table_name (name table-name)))

(defn- activate-pending-index!
  "Drop the current search index, and make the given non-active index active instead."
  ([] (activate-pending-index! @next-index))
  ([table-name]
   (when (and table-name (table-exists? table-name))
     (let [active-index     (t2/table-name :model/SearchIndex)
           rename-statement (-> (sql.helpers/alter-table table-name)
                                (sql.helpers/rename-table active-index))]
       (t2/with-transaction [_conn]
         (when (table-exists? active-index)
           (t2/query (sql.helpers/drop-table [:if-exists active-index])))
         (t2/query rename-statement))
       (compare-and-set! next-index table-name nil)))))

(defn- has-active-index?
  "Check whether we currently have an index table"
  []
  (table-exists? (t2/table-name :model/SearchIndex)))

(defn reset-index!
  "Used on deployment to wipe out the existing index(es), in case the table schema or content is incompatible."
  []
  (delete-pending-indexes!)
  (activate-pending-index! (create-pending-index!)))

(comment
  (has-active-index?)
  (t2/query (sql.helpers/drop-table :search_index))
  @next-index
  (reindexing-target)
  (create-pending-index!)
  (pending-indexes)
  (delete-pending-indexes!)
  (activate-pending-index!)                                 ;; true, if there is one
  (activate-pending-index! :not-found)                      ;; false
  (activate-pending-index! :search_index)                   ;; borks, as it should
  (reset-index!))
