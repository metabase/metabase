(ns metabase.query-processor.middleware.parameters
  "Middleware for substituting parameters in queries."
  (:require [clojure
             [data :as data]
             [set :as set]]
            [clojure.tools.logging :as log]
            [metabase.mbql
             [normalize :as normalize]
             [schema :as mbql.s]
             [util :as mbql.u]]
            [metabase.query-processor.interface :as i]
            [metabase.query-processor.middleware.parameters
             [mbql :as params.mbql]
             [sql :as params.sql]]
            [metabase.util :as u]
            [schema.core :as s]))

(defn- join? [m]
  (:condition m))

(s/defn ^:private move-join-condition-to-source-query :- mbql.s/Join
  "Joins aren't allowed to have `:filter` clauses, generated by the `expand-mbql-params` function below. Move the filter
  clause into the `:source-query`, converting `:source-table` to a source query if needed."
  [{:keys [source-table source-query], filter-clause :filter, :as join}]
  (if-not filter-clause
    join
    (if source-table
      (-> (assoc join :source-query {:source-table source-table, :filter filter-clause})
          (dissoc :source-table :filter))
      ;; putting parameters in a join that has a `:source-query` is a little wacky (just add them to `:parameters` in
      ;; the source query itself), but we'll allow it for now
      (-> (update-in join [:source-query :filter] mbql.u/combine-filter-clauses filter-clause)
          (dissoc :filter)))))

(defn- expand-mbql-params [outer-query {:keys [parameters] :as m}]
  ;; HACK `params.mbql/expand` assumes it's operating on an outer query so wrap `m` to look like an outer query. TODO
  ;; - fix `params.mbql` to operate on abitrary maps instead of only on top-level queries.
  (let [wrapped           (assoc outer-query :query m)
        {expanded :query} (params.mbql/expand (dissoc wrapped :parameters) parameters)]
    (cond-> expanded
      (join? m) move-join-condition-to-source-query)))

(defn- expand-native-params [outer-query {:keys [parameters], is-source-query? :native, :as m}]
  ;; HACK totally rediculous, but top-level native queries use the key `:query` for SQL or equivalent, while native
  ;; source queries use `:native`; rename `:native` to `:query` so the `params.sql/` code, which thinks it's always
  ;; operation on top-level queries, works as expected.
  ;;
  ;; TODO - Like the MBQL stuff, `params.sql` should be fixed so it operates on any level instead of only top-level.
  (let [wrapped            (assoc outer-query :native (set/rename-keys m {:native :query}))
        {expanded :native} (params.sql/expand (dissoc wrapped :parameters) parameters)]
    ;; remove `:parameters` and `:template-tags` now that we've spliced them in to the query
    (cond-> expanded
      ;; rename `:query` back to `:native` if this was a native source query
      is-source-query? (set/rename-keys {:query :native}))))

(defn- expand-one
  "Expand `:parameters` in one [inner-query style] map that contains them."
  [outer-query {:keys [source-table source-query parameters], :as m}]
  ;; HACK - normalization does not yet operate on `:parameters` that aren't at the top level, so double-check that
  ;; they're normalized properly before proceeding.
  (let [m (cond-> m
            (seq parameters) (update :parameters (partial normalize/normalize-fragment [:parameters])))
        expanded ((if (or source-table source-query)
                    expand-mbql-params
                    expand-native-params) outer-query m)]
    (dissoc expanded :parameters :template-tags)))

(defn- expand-all
  "Expand all `:parameters` anywhere in the query."
  ([outer-query]
   (expand-all outer-query outer-query))

  ([outer-query m]
   (mbql.u/replace m
     (_ :guard (every-pred map? (some-fn :parameters :template-tags)))
     (let [expanded (expand-one outer-query &match)]
       ;; now recursively expand any remaining maps that contain `:parameters`
       (expand-all outer-query expanded)))))

(defn- move-top-level-params-to-inner-query
  "Move any top-level parameters to the same level (i.e., 'inner query') as the query the affect."
  [{:keys [parameters], query-type :type, :as outer-query}]
  {:pre [(#{:query :native} query-type)]}
  (cond-> (dissoc outer-query :parameters)
    (seq parameters)
    (assoc-in [query-type :parameters] parameters)))

(defn- expand-parameters
  "Expand parameters in the `outer-query`, and if the query is using a native source query, expand params in that as
  well."
  [outer-query]
  (-> outer-query move-top-level-params-to-inner-query expand-all))

(defn- substitute-parameters*
  "If any parameters were supplied then substitute them into the query."
  [query]
  (u/prog1 (expand-parameters query)
    (when (and (not i/*disable-qp-logging*)
               (not= <> query))
      (when-let [diff (second (data/diff query <>))]
        (log/debug (u/format-color 'cyan "\n\nPARAMS/SUBSTITUTED: %s\n%s" (u/emoji "ðŸ˜»") (u/pprint-to-str diff)))))))

(defn substitute-parameters
  "Substitute Dashboard or Card-supplied parameters in a query, replacing the param placeholers with appropriate values
  and/or modifiying the query as appropriate. This looks for maps that have the key `:parameters` and/or
  `:template-tags` and removes those keys, splicing appropriate conditions into the queries they affect.

  A SQL query with a param like `{{param}}` will have that part of the query replaced with an appropriate snippet as
  well as any prepared statement args needed. MBQL queries will have additional filter clauses added."
  [qp]
  (comp qp substitute-parameters*))
