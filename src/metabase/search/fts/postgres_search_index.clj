(ns metabase.search.fts.postgres-search-index
  (:require
   [clojure.string :as str]
   [honey.sql.helpers :as sql.helpers]
   [toucan2.core :as t2]))

(def next-index
  "The name of the index that we are currently populating."
  (atom nil))

(defn reindexing-target
  "The name of the target where our re-indexing process should write to."
  []
  (or @next-index (t2/table-name :model/SearchIndex)))

(defn pending-indexes
  "Get a list of all the non-active search index tables."
  []
  (map (comp keyword :table_name)
       (-> (sql.helpers/select :table_name)
           (sql.helpers/from :information_schema.tables)
           (sql.helpers/where [:like :table_name "search_index_%"])
           t2/query)))

(defn- create-pending-index!
  "Create a non-active search index table."
  []
  (let [table-name (keyword (str/replace (str "search_index_" (random-uuid)) #"-" "_"))]
    (t2/query (-> (sql.helpers/create-table table-name)
                  (sql.helpers/with-columns
                   [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
                    [:primary :text]
                    [:secondary :text]
                    [:model [:varchar 254]]                 ;; right size?
                    [:model_id :int]
                    [:model_rank :int]                      ;; used to order models, denormalized (why put in db?)
                    [:display_data #_:jsonb :text]
                    [:attrs :tsvector]
                    ;; create fks?
                    [:collection_id :int]
                    [:database_id :int]
                    [:table_id :int]
                    ])
                  ;; not-null constraints etc
                  ))
    (reset! next-index table-name)))

(defn- delete-pending-indexes!
  "Delete all the non-active search index tables."
  []
  (boolean
   (when-let [table-names (seq (pending-indexes))]
     (t2/query (apply sql.helpers/drop-table table-names)))))

(defn- table-exists? [table-name]
  (-> (sql.helpers/select :table_name)
      (sql.helpers/from :information_schema.tables)
      (sql.helpers/where [:= :table_name (name table-name)])
      t2/query
      seq
      boolean))

(defn- activate-pending-index!
  "Drop the current search index, and make the given non-active index active instead."
  ([] (activate-pending-index! @next-index))
  ([table-name]
   (when (and table-name (table-exists? table-name))
     (let [active-index     (t2/table-name :model/SearchIndex)
           rename-statement (-> (sql.helpers/alter-table table-name)
                                (sql.helpers/rename-table active-index))]
       (t2/with-transaction [_conn]
         (when (table-exists? active-index)
           (t2/query (sql.helpers/drop-table [:if-exists active-index])))
         (t2/query rename-statement))
       (compare-and-set! next-index table-name nil)))))

(defn- has-active-index?
  "Check whether we currently have an index table"
  []
  (table-exists? (t2/table-name :model/SearchIndex)))

(defn reset-index!
  "Used on deployment to wipe out the existing index(es), in case the table or display_data schemas are stale."
  []
  (delete-pending-indexes!)
  (activate-pending-index! (create-pending-index!)))

(comment
  (has-active-index?)
  (t2/query (sql.helpers/drop-table :search_index))
  @next-index
  (reindexing-target)
  (create-pending-index!)
  (pending-indexes)
  (delete-pending-indexes!)
  (activate-pending-index!)                                 ;; true, if there is one
  (activate-pending-index! :not-found)                      ;; false
  (activate-pending-index! :search_index)                   ;; borks, as it should
  (reset-index!))
