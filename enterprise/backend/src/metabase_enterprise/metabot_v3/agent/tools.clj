(ns metabase-enterprise.metabot-v3.agent.tools
  "Tool registry for the agent loop.
  Bridges existing deftool handlers to mu/defn format for tool-executor-rff."
  (:require
   [clojure.string :as str]
   [clojure.walk :as walk]
   [metabase-enterprise.metabot-v3.agent.profiles :as profiles]
   [metabase-enterprise.metabot-v3.agent.streaming :as streaming]
   [metabase-enterprise.metabot-v3.tools.ask-clarification :as ask-clarification-tools]
   [metabase-enterprise.metabot-v3.tools.create-autogenerated-dashboard :as autogen-dashboard-tools]
   [metabase-enterprise.metabot-v3.tools.create-chart :as create-chart-tools]
   [metabase-enterprise.metabot-v3.tools.create-dashboard-subscription :as create-subscription-tools]
   [metabase-enterprise.metabot-v3.tools.create-sql-query :as create-sql-query-tools]
   [metabase-enterprise.metabot-v3.tools.edit-chart :as edit-chart-tools]
   [metabase-enterprise.metabot-v3.tools.edit-sql-query :as edit-sql-query-tools]
   [metabase-enterprise.metabot-v3.tools.entity-details :as entity-details-tools]
   [metabase-enterprise.metabot-v3.tools.field-stats :as field-stats-tools]
   [metabase-enterprise.metabot-v3.tools.filters :as filter-tools]
   [metabase-enterprise.metabot-v3.tools.find-outliers :as outliers-tools]
   [metabase-enterprise.metabot-v3.tools.generate-insights :as insights-tools]
   [metabase-enterprise.metabot-v3.tools.invite-user :as invite-user-tools]
   [metabase-enterprise.metabot-v3.tools.navigate :as navigate-tools]
   [metabase-enterprise.metabot-v3.tools.read-resource :as read-resource-tools]
   [metabase-enterprise.metabot-v3.tools.replace-sql-query :as replace-sql-query-tools]
   [metabase-enterprise.metabot-v3.tools.search :as search-tools]
   [metabase-enterprise.metabot-v3.tools.show-results-to-user :as show-results-tools]
   [metabase-enterprise.metabot-v3.tools.snippets :as snippet-tools]
   [metabase-enterprise.metabot-v3.tools.sql-search :as sql-search-tools]
   [metabase-enterprise.metabot-v3.tools.todo :as todo-tools]
   [metabase-enterprise.metabot-v3.tools.transforms :as transform-tools]
   [metabase-enterprise.metabot-v3.tools.transforms-write :as transforms-write-tools]
   [metabase-enterprise.metabot-v3.util :as metabot-u]
   [metabase.util.log :as log]
   [metabase.util.malli :as mu]))

(set! *warn-on-reflection* true)

;; Tool wrapper pattern: Create mu/defn wrappers that call existing tool implementations
;; The tool-executor-rff expects vars with Malli schemas in the metadata
;; Each wrapper takes snake_case parameters from LLM and calls the kebab-case tool handler

;;; Search & Discovery Tools

(mu/defn search-tool
  "Search for tables, models, metrics, and saved questions in the Metabase instance."
  [{:keys [semantic_queries keyword_queries term_queries entity_types limit]} :- [:map {:closed true}
                                                                                  [:semantic_queries {:optional true}
                                                                                   [:maybe [:sequential [:string {:description "Semantic search queries"}]]]]
                                                                                  [:keyword_queries {:optional true}
                                                                                   [:maybe [:sequential [:string {:description "Keyword search queries"}]]]]
                                                                                  [:term_queries {:optional true}
                                                                                   [:maybe [:sequential [:string {:description "Search term queries"}]]]]
                                                                                  [:entity_types {:optional true}
                                                                                   [:maybe [:sequential [:enum "table" "model" "question" "metric" "dashboard" "database" "transform"]]]]
                                                                                  [:limit {:optional true} [:maybe [:int {:min 1 :max 100}]]]]]
  (let [combined-terms (seq (concat term_queries keyword_queries))]
    (search-tools/search-tool {:semantic-queries semantic_queries
                               :term-queries combined-terms
                               :entity-types entity_types
                               :limit (or limit 10)})))

;;; Query Construction Tools

(defn- normalize-ai-args
  "Normalize nested tool arguments to kebab-case keys and keyword enums."
  [value]
  (let [normalized (when value
                     (metabot-u/recursive-update-keys value metabot-u/safe->kebab-case-en))
        enum-keys #{:operation :bucket :function :sort-order :direction :field-granularity}
        normalize-enum (fn [v]
                         (cond
                           (keyword? v) v
                           (string? v) (case v
                                         "ascending" :asc
                                         "descending" :desc
                                         (keyword v))
                           :else v))]
    (walk/postwalk
     (fn [x]
       (if (map? x)
         (reduce-kv (fn [m k v]
                      (assoc m k (if (enum-keys k) (normalize-enum v) v)))
                    {}
                    x)
         x))
     normalized)))

(mu/defn query-metric-tool
  "Construct a query from a metric."
  [{:keys [metric_id filters group_by]} :- [:map {:closed true}
                                            [:metric_id :int]
                                            [:filters {:optional true} [:maybe [:sequential :map]]]
                                            [:group_by {:optional true} [:maybe [:sequential :map]]]]]
  (filter-tools/query-metric {:metric-id metric_id
                              :filters filters
                              :group-by group_by}))

(mu/defn query-model-tool
  "Construct a query from a model."
  [{:keys [model_id fields filters aggregations group_by order_by limit]}
   :- [:map {:closed true}
       [:model_id :int]
       [:fields {:optional true} [:maybe [:sequential :map]]]
       [:filters {:optional true} [:maybe [:sequential :map]]]
       [:aggregations {:optional true} [:maybe [:sequential :map]]]
       [:group_by {:optional true} [:maybe [:sequential :map]]]
       [:order_by {:optional true} [:maybe [:sequential :map]]]
       [:limit {:optional true} [:maybe :int]]]]
  (filter-tools/query-model {:model-id model_id
                             :fields fields
                             :filters filters
                             :aggregations aggregations
                             :group-by group_by
                             :order-by order_by
                             :limit limit}))

(def ^:private ai-field-item-schema
  [:map {:closed true}
   [:field_id :string]
   [:field_granularity {:optional true} [:maybe :string]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private ai-filter-schema
  [:map {:closed true}
   [:field_id :string]
   [:operation :string]
   [:value {:optional true} [:maybe :any]]
   [:values {:optional true} [:maybe [:sequential :any]]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private ai-aggregation-schema
  [:map {:closed true}
   [:field_id :string]
   [:function :string]
   [:sort_order {:optional true} [:maybe :string]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private ai-order-by-schema
  [:map {:closed true}
   [:field ai-field-item-schema]
   [:direction :string]])

(defn- collect-field-ids
  [fields filters aggregations group-by order-by]
  (let [from-items (fn [items]
                     (keep :field-id items))
        from-order-by (fn [items]
                        (keep (comp :field-id :field) items))]
    (vec (concat (from-items fields)
                 (from-items filters)
                 (from-items aggregations)
                 (from-items group-by)
                 (from-order-by order-by)))))

(mu/defn query-model-ai-tool
  "Construct a query from a model (AI service schema)."
  [{:keys [model_id fields filters aggregations group_by order_by limit]}
   :- [:map {:closed true}
       [:model_id :int]
       [:fields {:optional true} [:maybe [:sequential ai-field-item-schema]]]
       [:filters {:optional true} [:maybe [:sequential ai-filter-schema]]]
       [:aggregations {:optional true} [:maybe [:sequential ai-aggregation-schema]]]
       [:group_by {:optional true} [:maybe [:sequential ai-field-item-schema]]]
       [:order_by {:optional true} [:maybe [:sequential ai-order-by-schema]]]
       [:limit {:optional true} [:maybe :int]]]]
  (let [normalized-fields (normalize-ai-args fields)
        normalized-filters (normalize-ai-args filters)
        normalized-aggregations (normalize-ai-args aggregations)
        normalized-group-by (normalize-ai-args group_by)
        normalized-order-by (normalize-ai-args order_by)
        expected-prefix (str "c" model_id "-")
        field-ids (collect-field-ids normalized-fields normalized-filters normalized-aggregations
                                     normalized-group-by normalized-order-by)
        mismatched (seq (remove #(str/starts-with? % expected-prefix) field-ids))]
    (if mismatched
      {:output (str "Invalid field_id(s) for model_id " model_id
                    ". Expected IDs starting with " expected-prefix
                    ". If you are querying a table, use construct_notebook_query "
                    "or create_sql_query instead.")}
      (filter-tools/query-model {:model-id model_id
                                 :fields normalized-fields
                                 :filters normalized-filters
                                 :aggregations normalized-aggregations
                                 :group-by normalized-group-by
                                 :order-by normalized-order-by
                                 :limit limit}))))

(def ^:private construct-field-schema
  [:map {:closed true}
   [:field_id :string]
   [:field_granularity {:optional true} [:maybe :string]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private construct-metric-schema
  [:map {:closed true}
   [:field_id :string]
   [:function :string]
   [:sort_order {:optional true} [:maybe :string]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private construct-order-by-schema
  [:map {:closed true}
   [:field construct-field-schema]
   [:direction :string]])

(def ^:private construct-filter-schema
  [:map {:closed true}
   [:filter_type [:enum "multi_value" "single_value" "no_value"]]
   [:field_id :string]
   [:operation :string]
   [:bucket {:optional true} [:maybe :string]]
   [:value {:optional true} [:maybe :any]]
   [:values {:optional true} [:maybe [:sequential :any]]]])

(def ^:private construct-source-metric-schema
  [:map {:closed true}
   [:metric_id :int]])

(def ^:private construct-source-model-schema
  [:map {:closed true}
   [:model_id :int]])

(def ^:private construct-source-table-schema
  [:map {:closed true}
   [:table_id :int]])

(def ^:private construct-query-metric-schema
  [:map {:closed true}
   [:query_type [:enum "metric"]]
   [:source construct-source-metric-schema]
   [:filters [:sequential construct-filter-schema]]
   [:group_by [:sequential construct-field-schema]]])

(def ^:private construct-query-aggregate-schema
  [:map {:closed true}
   [:query_type [:enum "aggregate"]]
   [:source [:or construct-source-model-schema construct-source-table-schema]]
   [:aggregations [:sequential construct-metric-schema]]
   [:filters [:sequential construct-filter-schema]]
   [:group_by [:sequential construct-field-schema]]
   [:limit [:maybe :int]]])

(def ^:private construct-query-raw-schema
  [:map {:closed true}
   [:query_type [:enum "raw"]]
   [:source [:or construct-source-model-schema construct-source-table-schema]]
   [:filters [:sequential construct-filter-schema]]
   [:fields [:sequential construct-field-schema]]
   [:order_by [:sequential construct-order-by-schema]]
   [:limit [:maybe :int]]])

(def ^:private construct-query-schema
  [:or construct-query-metric-schema construct-query-aggregate-schema construct-query-raw-schema])

(def ^:private construct-visualization-schema
  [:map {:closed true}
   [:chart_type :string]])

(def ^:private construct-operation-aliases
  {"contains" :string-contains
   "not-contains" :string-not-contains
   "starts-with" :string-starts-with
   "ends-with" :string-ends-with
   "is-empty" :string-is-empty
   "is-not-empty" :string-is-not-empty})

(defn- normalize-construct-operation
  [operation]
  (let [op (cond
             (keyword? operation) operation
             (string? operation) (keyword operation)
             :else operation)]
    (get construct-operation-aliases (name op) op)))

(defn- normalize-construct-filter
  [filter]
  (let [normalized (normalize-ai-args filter)
        filter-type (:filter-type normalized)
        normalized (assoc normalized :operation (normalize-construct-operation (:operation normalized)))]
    (case filter-type
      :multi-value (-> normalized
                       (dissoc :filter-type :value)
                       (update :values (fn [vals]
                                         (cond
                                           (sequential? vals) (vec vals)
                                           (some? (:value normalized)) [(:value normalized)]
                                           :else []))))
      :single-value (-> normalized
                        (dissoc :filter-type :values)
                        (assoc :value (or (:value normalized)
                                          (first (:values normalized)))))
      :no-value (-> normalized
                    (dissoc :filter-type :value :values))
      (dissoc normalized :filter-type))))

(defn- normalize-construct-filters
  [filters]
  (mapv normalize-construct-filter filters))

(defn- chart-type->keyword
  [chart-type]
  (cond
    (keyword? chart-type) chart-type
    (string? chart-type) (keyword chart-type)
    :else chart-type))

(defn- query-type->keyword
  [query-type]
  (cond
    (keyword? query-type) query-type
    (string? query-type) (keyword query-type)
    :else query-type))

(mu/defn construct-notebook-query-tool
  "Construct and visualize a notebook query from a metric, model, or table."
  [{:keys [reasoning query visualization]} :- [:map {:closed true}
                                               [:reasoning :string]
                                               [:query construct-query-schema]
                                               [:visualization construct-visualization-schema]]]
  (try
    (let [normalized-query (normalize-ai-args query)
          normalized-visualization (normalize-ai-args visualization)
          query-type (query-type->keyword (:query-type normalized-query))
          chart-type (chart-type->keyword (:chart-type normalized-visualization))
          _ (log/debug "construct_notebook_query request"
                       {:query-type query-type
                        :chart-type chart-type})
          query-result (case query-type
                         :metric
                         (filter-tools/query-metric
                          {:metric-id (get-in normalized-query [:source :metric-id])
                           :filters (normalize-construct-filters (:filters normalized-query))
                           :group-by (normalize-ai-args (:group-by normalized-query))})
                         :aggregate
                         (filter-tools/query-datasource
                          {:model-id (get-in normalized-query [:source :model-id])
                           :table-id (get-in normalized-query [:source :table-id])
                           :aggregations (normalize-ai-args (:aggregations normalized-query))
                           :filters (normalize-construct-filters (:filters normalized-query))
                           :group-by (normalize-ai-args (:group-by normalized-query))
                           :limit (:limit normalized-query)})
                         :raw
                         (filter-tools/query-datasource
                          {:model-id (get-in normalized-query [:source :model-id])
                           :table-id (get-in normalized-query [:source :table-id])
                           :fields (normalize-ai-args (:fields normalized-query))
                           :filters (normalize-construct-filters (:filters normalized-query))
                           :order-by (normalize-ai-args (:order-by normalized-query))
                           :limit (:limit normalized-query)})
                         {:output (str "Unsupported query_type: " query-type)})
          structured (or (:structured-output query-result) (:structured_output query-result))]
      (if (and structured (:query-id structured) (:query structured))
        (let [chart-result (create-chart-tools/create-chart
                            {:query-id (:query-id structured)
                             :chart-type chart-type
                             :queries-state {(:query-id structured) (:query structured)}})
              navigate-url (get-in chart-result [:reactions 0 :url])]
          {:structured-output (assoc structured
                                     :chart-id (:chart-id chart-result)
                                     :chart-type (:chart-type chart-result)
                                     :chart-link (:chart-link chart-result)
                                     :chart-content (:chart-content chart-result))
           :instructions (str "Your query and chart have been created successfully.\n\n"
                              "Next steps to present the chart to the user:\n"
                              "- Always provide a direct link using: `[Chart](metabase://chart/"
                              (:chart-id chart-result) ")` where Chart is a meaningful link text\n"
                              "- If creating multiple charts, present all chart links")
           :data-parts (when navigate-url
                         [(streaming/navigate-to-part navigate-url)])})
        query-result))
    (catch Exception e
      (log/error e "Failed to construct notebook query")
      (if (:agent-error? (ex-data e))
        {:output (ex-message e)}
        {:output (str "Failed to construct notebook query: " (or (ex-message e) "Unknown error"))}))))

;;; Metadata & Details Tools

(mu/defn get-field-values-tool
  "Return statistics and/or values for a given field of a given entity."
  [{:keys [entity_type entity_id field_id limit]} :- [:map {:closed true}
                                                      [:entity_type [:enum "table" "model" "metric"]]
                                                      [:entity_id :int]
                                                      [:field_id :string]
                                                      [:limit {:optional true} [:maybe :int]]]]
  (field-stats-tools/field-values {:entity-type entity_type
                                   :entity-id entity_id
                                   :field-id field_id
                                   :limit limit}))

(mu/defn get-entity-details-tool
  "Get information about a given table or model."
  [{:keys [table_id model_id with_fields with_field_values with_related_tables
           with_metrics with_metric_default_temporal_breakout with_measures with_segments]}
   :- [:map {:closed true}
       [:table_id {:optional true} [:or :int :string]]
       [:model_id {:optional true} :int]
       [:with_fields {:optional true} [:maybe :boolean]]
       [:with_field_values {:optional true} [:maybe :boolean]]
       [:with_related_tables {:optional true} [:maybe :boolean]]
       [:with_metrics {:optional true} [:maybe :boolean]]
       [:with_metric_default_temporal_breakout {:optional true} [:maybe :boolean]]
       [:with_measures {:optional true} [:maybe :boolean]]
       [:with_segments {:optional true} [:maybe :boolean]]]]
  (entity-details-tools/get-table-details
   {:table-id table_id
    :model-id model_id
    :with-fields? with_fields
    :with-field-values? with_field_values
    :with-related-tables? with_related_tables
    :with-metrics? with_metrics
    :with-default-temporal-breakout? with_metric_default_temporal_breakout
    :with-measures? with_measures
    :with-segments? with_segments}))

(mu/defn get-metric-details-tool
  "Get information about a given metric."
  [{:keys [metric_id with_default_temporal_breakout with_field_values
           with_queryable_dimensions with_segments]}
   :- [:map {:closed true}
       [:metric_id :int]
       [:with_default_temporal_breakout {:optional true} [:maybe :boolean]]
       [:with_field_values {:optional true} [:maybe :boolean]]
       [:with_queryable_dimensions {:optional true} [:maybe :boolean]]
       [:with_segments {:optional true} [:maybe :boolean]]]]
  (entity-details-tools/get-metric-details
   {:metric-id metric_id
    :with-default-temporal-breakout? with_default_temporal_breakout
    :with-field-values? with_field_values
    :with-queryable-dimensions? with_queryable_dimensions
    :with-segments? with_segments}))

(mu/defn get-field-stats-tool
  "Get statistics for a field."
  [{:keys [entity_type entity_id field_id]}
   :- [:map {:closed true}
       [:entity_type [:enum "table" "model" "metric"]]
       [:entity_id :int]
       [:field_id :string]]]
  (field-stats-tools/field-values {:entity-type entity_type
                                   :entity-id entity_id
                                   :field-id field_id}))

;;; Visualization & Results Tools

(mu/defn show-results-to-user-tool
  "Show query results to the user.

  Takes a query_id from a previous query_model or query_metric result and displays
  those results to the user. The query is looked up from the queries_state which
  contains all queries created during the conversation."
  [{:keys [query_id queries_state]} :- [:map {:closed true}
                                        [:query_id :string]
                                        [:queries_state {:optional true} [:maybe :map]]
                                        ;; charts_state is injected by wrap-tools-with-state but not used by this tool
                                        [:charts_state {:optional true} [:maybe :map]]]]
  (show-results-tools/show-results-to-user {:query-id query_id
                                            :queries-state (or queries_state {})}))

;;; Analytics Tools

(mu/defn find-outliers-tool
  "Find outliers in the values provided by a data source for a given column."
  [{:keys [data_source]} :- [:map {:closed true}
                             [:data_source :map]]]
  (outliers-tools/find-outliers {:data-source data_source}))

(mu/defn generate-insights-tool
  "Generate insights for a given entity."
  [{:keys [for]} :- [:map {:closed true}
                     [:for :map]]]
  (insights-tools/generate-insights {:for for}))

;;; Action Tools

(mu/defn create-dashboard-subscription-tool
  "Create a dashboard subscription."
  [{:keys [dashboard_id email schedule]} :- [:map {:closed true}
                                             [:dashboard_id :int]
                                             [:email :string]
                                             [:schedule :map]]]
  (create-subscription-tools/create-dashboard-subscription
   {:dashboard-id dashboard_id
    :email email
    :schedule schedule}))

;;; Transform Tools

(mu/defn get-transform-details-tool
  "Get information about a transform."
  [{:keys [transform_id]} :- [:map {:closed true}
                              [:transform_id :int]]]
  (transform-tools/get-transform-details {:transform-id transform_id}))

;;; User Management Tools

(mu/defn invite-user-tool
  "Send a Metabase invitation to an email address."
  [{:keys [email]} :- [:map {:closed true}
                       [:email :string]]]
  (invite-user-tools/invite-user {:email email}))

;;; SQL Query Tools

(mu/defn create-sql-query-tool
  "Create a new SQL query."
  [{:keys [database_id sql name description collection_id]}
   :- [:map {:closed true}
       [:database_id :int]
       [:sql :string]
       [:name {:optional true} [:maybe :string]]
       [:description {:optional true} [:maybe :string]]
       [:collection_id {:optional true} [:maybe :int]]]]
  (create-sql-query-tools/create-sql-query-tool
   {:database-id database_id
    :sql sql
    :name name
    :description description
    :collection-id collection_id}))

(mu/defn edit-sql-query-tool
  "Edit an existing SQL query using structured edits."
  [{:keys [query_id edit name description queries_state]}
   :- [:map {:closed true}
       [:query_id [:or :string :int]]
       [:edit :map]
       [:name {:optional true} [:maybe :string]]
       [:description {:optional true} [:maybe :string]]
       [:queries_state {:optional true} [:maybe :map]]
       ;; charts_state is injected by wrap-tools-with-state but not used by this tool
       [:charts_state {:optional true} [:maybe :map]]]]
  (edit-sql-query-tools/edit-sql-query-tool
   {:query-id query_id
    :edit edit
    :name name
    :description description
    :queries-state (or queries_state {})}))

(mu/defn replace-sql-query-tool
  "Replace the SQL content of an existing query entirely."
  [{:keys [query_id sql name description queries_state]}
   :- [:map {:closed true}
       [:query_id [:or :string :int]]
       [:sql :string]
       [:name {:optional true} [:maybe :string]]
       [:description {:optional true} [:maybe :string]]
       [:queries_state {:optional true} [:maybe :map]]
       ;; charts_state is injected by wrap-tools-with-state but not used by this tool
       [:charts_state {:optional true} [:maybe :map]]]]
  (replace-sql-query-tools/replace-sql-query-tool
   {:query-id query_id
    :sql sql
    :name name
    :description description
    :queries-state (or queries_state {})}))

(mu/defn sql-search-tool
  "Search for SQL queries by content."
  [{:keys [query database_id limit]}
   :- [:map {:closed true}
       [:query :string]
       [:database_id {:optional true} [:maybe :int]]
       [:limit {:optional true} [:maybe [:int {:min 1 :max 50}]]]]]
  (sql-search-tools/sql-search-tool
   {:query query
    :database-id database_id
    :limit limit}))

;;; Chart Tools

(mu/defn create-chart-tool
  "Create a chart from a query.

  Takes a query ID and chart type, creates a new chart visualization.
  Returns the chart ID and a link to view it."
  [{:keys [query_id chart_type queries_state]}
   :- [:map {:closed true}
       [:query_id :string]
       [:chart_type [:enum "table" "bar" "line" "pie" "sunburst" "area" "combo"
                     "row" "pivot" "scatter" "waterfall" "sankey" "scalar"
                     "smartscalar" "gauge" "progress" "funnel" "object" "map"]]
       [:queries_state {:optional true} [:maybe :map]]
       ;; charts_state is injected by wrap-tools-with-state but not used by this tool
       [:charts_state {:optional true} [:maybe :map]]]]
  (create-chart-tools/create-chart-tool
   {:query-id query_id
    :chart-type (keyword chart_type)
    :queries-state (or queries_state {})}))

(mu/defn edit-chart-tool
  "Edit an existing chart's visualization type.

  Changes the chart type (e.g., bar to line, table to pie) but preserves
  the underlying query. Returns a new chart with the updated settings."
  [{:keys [chart_id new_chart_type charts_state]}
   :- [:map {:closed true}
       [:chart_id :string]
       [:new_chart_type [:enum "table" "bar" "line" "pie" "sunburst" "area" "combo"
                         "row" "pivot" "scatter" "waterfall" "sankey" "scalar"
                         "smartscalar" "gauge" "progress" "funnel" "object" "map"]]
       [:charts_state {:optional true} [:maybe :map]]
       ;; queries_state is injected by wrap-tools-with-state but not used by this tool
       [:queries_state {:optional true} [:maybe :map]]]]
  (edit-chart-tools/edit-chart-tool
   {:chart-id chart_id
    :new-chart-type (keyword new_chart_type)
    :charts-state (or charts_state {})}))

;;; Resource Reading Tools

(mu/defn read-resource-tool
  "Read detailed information about Metabase resources via URI patterns.

  Supports fetching multiple resources in parallel using metabase:// URIs:
  - metabase://table/{id}/fields - Get table structure with fields
  - metabase://model/{id}/fields/{field_id} - Get specific field details
  - metabase://metric/{id}/dimensions - Get metric dimensions
  - metabase://transform/{id} - Get transform details
  - metabase://dashboard/{id} - Get dashboard details"
  [{:keys [uris]}
   :- [:map {:closed true}
       [:uris [:sequential [:string {:description "Metabase resource URIs to fetch"}]]]]]
  (read-resource-tools/read-resource-tool {:uris uris}))

;;; Todo Tools

(mu/defn todo-write-tool
  "Create and manage a structured task list.
  Write or update the todo list with tasks for tracking progress.

  Each todo item must have:
  - id: Unique identifier for the task
  - content: Description of what needs to be done
  - status: One of 'pending', 'in_progress', 'completed', 'cancelled'
  - priority: One of 'high', 'medium', 'low'"
  [{:keys [todos memory_atom]}
   :- [:map {:closed true}
       [:todos [:sequential [:map {:closed true}
                             [:id :string]
                             [:content :string]
                             [:status [:enum "pending" "in_progress" "completed" "cancelled"]]
                             [:priority [:enum "high" "medium" "low"]]]]]
       [:memory_atom {:optional true} [:maybe :any]]]]
  (todo-tools/todo-write-tool {:todos todos
                               :memory-atom memory_atom}))

(mu/defn todo-read-tool
  "Read the current todo list from memory.
  Returns the list of todos that have been created during this conversation."
  [{:keys [memory_atom]}
   :- [:map {:closed true}
       [:memory_atom {:optional true} [:maybe :any]]]]
  (todo-tools/todo-read-tool {:memory-atom memory_atom}))

;;; Navigation Tools

(mu/defn navigate-user-tool
  "Navigate the user to a specific page or entity in Metabase.

  Use this tool to direct users to:
  - Pages: notebook_editor, metrics_browser, model_browser, database_browser, sql_editor, home
  - Entities: table, model, question, metric, dashboard, database, collection
  - Query results or charts from the current conversation"
  [{:keys [destination memory_atom]}
   :- [:map {:closed true}
       [:destination [:map
                      [:page {:optional true} [:maybe [:enum "notebook_editor" "metrics_browser"
                                                       "model_browser" "database_browser"
                                                       "sql_editor" "home"]]]
                      [:database_id {:optional true} [:maybe :int]]
                      [:entity_type {:optional true} [:maybe [:enum "table" "model" "question"
                                                              "metric" "dashboard" "database" "collection"]]]
                      [:entity_id {:optional true} [:maybe [:or :int :string]]]
                      [:query_id {:optional true} [:maybe :string]]
                      [:chart_id {:optional true} [:maybe :string]]]]
       [:memory_atom {:optional true} [:maybe :any]]]]
  (navigate-tools/navigate-tool {:destination destination
                                 :memory-atom memory_atom}))

;;; Snippet Tools

(mu/defn list-snippets-tool
  "List all SQL snippets available in the Metabase instance.

  Use this tool before editing or creating SQL transforms to understand what
  snippets are available. If any snippets may be relevant to the user's request,
  fetch their content using the get_snippet_details tool."
  [_args :- [:map {:closed true}]]
  (snippet-tools/get-snippets {}))

(mu/defn get-snippet-details-tool
  "Get the full details of a SQL snippet including its content.

  Use this tool to retrieve the actual SQL content of a snippet after identifying
  it with list_snippets."
  [{:keys [snippet_id]}
   :- [:map {:closed true}
       [:snippet_id :int]]]
  (snippet-tools/get-snippet-details {:snippet-id snippet_id}))

;;; Ask Clarification Tool

(mu/defn ask-for-sql-clarification-tool
  "Ask the user for clarification about their SQL query request.

  Use this tool when you need more information from the user to properly
  complete their SQL request. The agent will stop and wait for the user's response."
  [{:keys [question options]}
   :- [:map {:closed true}
       [:question :string]
       [:options {:optional true} [:maybe [:sequential :string]]]]]
  (ask-clarification-tools/ask-for-sql-clarification-tool {:question question
                                                           :options options}))

;;; Transform Write Tools

(mu/defn write-transform-sql-tool
  "Write new SQL queries or edit existing queries for transforms.

  Supports two modes:
  - edit: Targeted string replacements with partial edits
  - replace: Replace entire query atomically

  For edit mode, provide edits as an array of {old_string, new_string, replace_all} objects.
  For replace mode, provide new_content with the complete SQL."
  [{:keys [transform_id edit_action thinking transform_name transform_description
           source_database source_tables memory_atom context]}
   :- [:map {:closed true}
       [:transform_id {:optional true} [:maybe :int]]
       [:edit_action [:map
                      [:mode [:enum "edit" "replace"]]
                      [:edits {:optional true} [:maybe [:sequential [:map
                                                                     [:old_string :string]
                                                                     [:new_string :string]
                                                                     [:replace_all {:optional true} [:maybe :boolean]]]]]]
                      [:new_content {:optional true} [:maybe :string]]]]
       [:thinking {:optional true} [:maybe :string]]
       [:transform_name {:optional true} [:maybe :string]]
       [:transform_description {:optional true} [:maybe :string]]
       [:source_database {:optional true} [:maybe :int]]
       [:source_tables {:optional true} [:maybe :map]]
       [:memory_atom {:optional true} [:maybe :any]]
       [:context {:optional true} [:maybe :map]]]]
  (transforms-write-tools/write-transform-sql-tool
   {:transform_id transform_id
    :edit_action edit_action
    :thinking thinking
    :transform_name transform_name
    :transform_description transform_description
    :source_database source_database
    :source_tables source_tables
    :memory-atom memory_atom
    :context context}))

(mu/defn write-transform-python-tool
  "Write new Python code or edit existing code for transforms.

  Supports two modes:
  - edit: Targeted string replacements with partial edits
  - replace: Replace entire code atomically

  For edit mode, provide edits as an array of {old_string, new_string, replace_all} objects.
  For replace mode, provide new_content with the complete Python code."
  [{:keys [transform_id edit_action thinking transform_name transform_description
           source_database source_tables memory_atom context]}
   :- [:map {:closed true}
       [:transform_id {:optional true} [:maybe :int]]
       [:edit_action [:map
                      [:mode [:enum "edit" "replace"]]
                      [:edits {:optional true} [:maybe [:sequential [:map
                                                                     [:old_string :string]
                                                                     [:new_string :string]
                                                                     [:replace_all {:optional true} [:maybe :boolean]]]]]]
                      [:new_content {:optional true} [:maybe :string]]]]
       [:thinking {:optional true} [:maybe :string]]
       [:transform_name {:optional true} [:maybe :string]]
       [:transform_description {:optional true} [:maybe :string]]
       [:source_database {:optional true} [:maybe :int]]
       [:source_tables {:optional true} [:maybe :map]]
       [:memory_atom {:optional true} [:maybe :any]]
       [:context {:optional true} [:maybe :map]]]]
  (transforms-write-tools/write-transform-python-tool
   {:transform_id transform_id
    :edit_action edit_action
    :thinking thinking
    :transform_name transform_name
    :transform_description transform_description
    :source_database source_database
    :source_tables source_tables
    :memory-atom memory_atom
    :context context}))

;;; Autogenerated Dashboard Tool

(mu/defn create-autogenerated-dashboard-tool
  "Create an automatically generated dashboard using Metabase's X-ray feature.

  X-ray builds complete dashboards with multiple visualizations that showcase
  different aspects of your data - distributions, breakdowns by categories,
  trends over time, and relationships between fields.

  Specify one source type:
  - table_id: Create dashboard for a table
  - model_id: Create dashboard for a model
  - metric_id: Create dashboard for a metric
  - query_id: Create dashboard for query results from this conversation
  - report_id: Create dashboard for an existing report/question"
  [{:keys [source memory_atom]}
   :- [:map {:closed true}
       [:source [:map
                 [:table_id {:optional true} [:maybe :int]]
                 [:model_id {:optional true} [:maybe :int]]
                 [:metric_id {:optional true} [:maybe :int]]
                 [:query_id {:optional true} [:maybe :string]]
                 [:report_id {:optional true} [:maybe :int]]]]
       [:memory_atom {:optional true} [:maybe :any]]]]
  (autogen-dashboard-tools/create-autogenerated-dashboard-tool
   {:source source
    :memory-atom memory_atom}))

;; Tool registry - maps tool name to var
(def all-tools
  "Registry of all available tools."
  {"search"                        #'search-tool
   "query_metric"                  #'query-metric-tool
   "query_model"                   #'query-model-ai-tool
   "construct_notebook_query"      #'construct-notebook-query-tool
   "get_field_values"              #'get-field-values-tool
   "get_entity_details"            #'get-entity-details-tool
   "get_metric_details"            #'get-metric-details-tool
   "get_field_stats"               #'get-field-stats-tool
   "show_results_to_user"          #'show-results-to-user-tool
   "find_outliers"                 #'find-outliers-tool
   "generate_insights"             #'generate-insights-tool
   "create_dashboard_subscription" #'create-dashboard-subscription-tool
   "get_transform_details"         #'get-transform-details-tool
   "invite_user"                   #'invite-user-tool
   "create_sql_query"              #'create-sql-query-tool
   "edit_sql_query"                #'edit-sql-query-tool
   "replace_sql_query"             #'replace-sql-query-tool
   "sql_search"                    #'sql-search-tool
   "read_resource"                 #'read-resource-tool
   "create_chart"                  #'create-chart-tool
   "edit_chart"                    #'edit-chart-tool
   "todo_write"                    #'todo-write-tool
   "todo_read"                     #'todo-read-tool
   "navigate_user"                 #'navigate-user-tool
   "list_snippets"                 #'list-snippets-tool
   "get_snippet_details"           #'get-snippet-details-tool
   "ask_for_sql_clarification"     #'ask-for-sql-clarification-tool
   "write_transform_sql"           #'write-transform-sql-tool
   "write_transform_python"        #'write-transform-python-tool
   "create_autogenerated_dashboard" #'create-autogenerated-dashboard-tool})

;;; Capability-Based Tool Filtering
;;
;; Some tools require specific capabilities to be available.
;; Capabilities are passed in the request context and represent features/permissions.

(def ^:private tool-capabilities
  "Map of tool names to required capabilities.
  Tools not listed here have no special capability requirements."
  {"navigate_user"                  #{:frontend-navigate-user-v1}
   "create_autogenerated_dashboard" #{:automagic-dashboards}
   "write_transform_sql"            #{:feature-transforms :permission-write-transforms}
   "write_transform_python"         #{:feature-transforms :feature-transforms-python :permission-write-transforms}
   "list_snippets"                  #{:feature-snippets}
   "get_snippet_details"            #{:feature-snippets}
   "create_chart"                   #{:frontend-navigate-user-v1}
   "edit_chart"                     #{:frontend-navigate-user-v1}})

(defn filter-by-capabilities
  "Filter tool names by user capabilities.
  Removes tools that require capabilities the user doesn't have."
  [tool-names capabilities]
  (let [capabilities-set (set capabilities)]
    (filter (fn [tool-name]
              (let [required (get tool-capabilities tool-name #{})]
                (every? capabilities-set required)))
            tool-names)))

(defn get-tools-for-profile
  "Get tool registry filtered by profile configuration and user capabilities."
  [profile-id capabilities]
  (let [profile (profiles/get-profile profile-id)
        tool-names (or (:tools profile) [])]
    (select-keys all-tools (filter-by-capabilities tool-names capabilities))))

;;; State-aware tool wrapping
;;
;; Some tools need access to agent state (queries, charts) to function properly.
;; These tools are wrapped at runtime with access to the memory atom.

(def ^:private state-dependent-tools
  "Set of tool names that require access to agent state."
  #{"show_results_to_user" "create_chart" "edit_chart" "todo_write" "todo_read" "navigate_user"
    "write_transform_sql" "write_transform_python" "create_autogenerated_dashboard"
    "edit_sql_query" "replace_sql_query"})

(defn wrap-tools-with-state
  "Wrap state-dependent tools with access to the memory atom.
  Tools in `state-dependent-tools` will have their arguments augmented
  with queries_state, charts_state, and memory_atom from the current memory.

  Returns a new tools map where state-dependent tools are wrapped.
  Wrapped tools are returned as maps with :doc, :schema, and :fn keys
  to satisfy the Claude API schema validation."
  [tools memory-atom]
  (reduce-kv
   (fn [acc tool-name tool-var]
     (if (contains? state-dependent-tools tool-name)
       ;; Wrap the tool - return a map with :doc, :schema, :fn
       ;; This format is accepted by claude.clj schema and tool->claude
       (let [{:keys [doc schema system-instructions]} (meta tool-var)
             wrapped-fn (fn [args]
                          (let [memory @memory-atom
                                state (:state memory)
                                augmented-args (assoc args
                                                      :queries_state (get state :queries {})
                                                      :charts_state (get state :charts {})
                                                      :memory_atom memory-atom)]
                            (tool-var augmented-args)))]
         (assoc acc tool-name {:doc doc
                               :schema schema
                               :system-instructions system-instructions
                               :fn wrapped-fn}))
       ;; Keep non-state-dependent tools as-is
       (assoc acc tool-name tool-var)))
   {}
   tools))
