(ns metabase-enterprise.metabot-v3.agent.tools
  "Tool registry for the agent loop.
  Bridges existing deftool handlers to mu/defn format for tool-executor-rff."
  (:require
   [clojure.string :as str]
   [clojure.walk :as walk]
   [metabase-enterprise.metabot-v3.agent.profiles :as profiles]
   [metabase-enterprise.metabot-v3.agent.streaming :as streaming]
   [metabase-enterprise.metabot-v3.config :as metabot-v3.config]
   [metabase-enterprise.metabot-v3.tools.ask-clarification :as ask-clarification-tools]
   [metabase-enterprise.metabot-v3.tools.create-autogenerated-dashboard :as autogen-dashboard-tools]
   [metabase-enterprise.metabot-v3.tools.create-chart :as create-chart-tools]
   [metabase-enterprise.metabot-v3.tools.create-sql-query :as create-sql-query-tools]
   [metabase-enterprise.metabot-v3.tools.edit-chart :as edit-chart-tools]
   [metabase-enterprise.metabot-v3.tools.edit-sql-query :as edit-sql-query-tools]
   [metabase-enterprise.metabot-v3.tools.entity-details :as entity-details-tools]
   [metabase-enterprise.metabot-v3.tools.field-stats :as field-stats-tools]
   [metabase-enterprise.metabot-v3.tools.filters :as filter-tools]
   [metabase-enterprise.metabot-v3.tools.get-metadata :as metadata-tools]
   [metabase-enterprise.metabot-v3.tools.instructions :as instructions]
   [metabase-enterprise.metabot-v3.tools.navigate :as navigate-tools]
   [metabase-enterprise.metabot-v3.tools.read-resource :as read-resource-tools]
   [metabase-enterprise.metabot-v3.tools.replace-sql-query :as replace-sql-query-tools]
   [metabase-enterprise.metabot-v3.tools.search :as search-tools]
   [metabase-enterprise.metabot-v3.tools.snippets :as snippet-tools]
   [metabase-enterprise.metabot-v3.tools.todo :as todo-tools]
   [metabase-enterprise.metabot-v3.tools.transforms :as transform-tools]
   [metabase-enterprise.metabot-v3.tools.transforms-write :as transforms-write-tools]
   [metabase-enterprise.metabot-v3.util :as metabot-u]
   [metabase.util.log :as log]
   [metabase.util.malli :as mu]))

(set! *warn-on-reflection* true)

;; Tool wrapper pattern: Create mu/defn wrappers that call existing tool implementations
;; The tool-executor-rff expects vars with Malli schemas in the metadata
;; Each wrapper takes snake_case parameters from LLM and calls the kebab-case tool handler

(def ^:dynamic *memory-atom*
  "Dynamic memory atom bound for tools that need access to agent state."
  nil)

(defn- current-memory
  []
  (when *memory-atom*
    @*memory-atom*))

(defn- current-queries-state
  []
  (get-in (current-memory) [:state :queries] {}))

(defn- current-charts-state
  []
  (get-in (current-memory) [:state :charts] {}))

(defn- current-context
  []
  (get (current-memory) :context))

;;; Search & Discovery Tools

(defn- invalid-entity-types
  [entity-types allowed]
  (when (seq entity-types)
    (seq (remove allowed entity-types))))

(mu/defn search-tool
  "Search for tables, models, metrics, dashboards, and saved questions."
  [{:keys [semantic_queries keyword_queries entity_types]} :- [:map {:closed true}
                                                               [:semantic_queries [:sequential :string]]
                                                               [:keyword_queries [:sequential :string]]
                                                               [:entity_types {:optional true}
                                                                [:maybe [:sequential [:enum "table" "model" "metric" "dashboard" "question"]]]]]]
  (if-let [invalid (invalid-entity-types entity_types #{"table" "model" "metric" "dashboard" "question"})]
    {:output (str "Invalid entity_types for search: " (pr-str (vec invalid))
                  ". Allowed types: table, model, metric, dashboard, question.")}
    (search-tools/search-tool {:semantic-queries semantic_queries
                               :term-queries keyword_queries
                               :entity-types entity_types
                               :limit 10})))

(mu/defn sql-search-tool
  "Search for SQL-queryable data sources (tables and models) within a database."
  [{:keys [semantic_queries keyword_queries entity_types database_id]} :- [:map {:closed true}
                                                                           [:semantic_queries [:sequential :string]]
                                                                           [:keyword_queries [:sequential :string]]
                                                                           [:database_id :int]
                                                                           [:entity_types {:optional true}
                                                                            [:maybe [:sequential [:enum "table" "model"]]]]]]
  (if-let [invalid (invalid-entity-types entity_types #{"table" "model"})]
    {:output (str "Invalid entity_types for SQL search: " (pr-str (vec invalid))
                  ". Allowed types: table, model.")}
    (search-tools/search-tool {:semantic-queries semantic_queries
                               :term-queries keyword_queries
                               :entity-types entity_types
                               :database-id database_id
                               :limit 10})))

(mu/defn nlq-search-tool
  "Search for NLQ-queryable data sources (models, metrics, tables)."
  [{:keys [semantic_queries keyword_queries entity_types]} :- [:map {:closed true}
                                                               [:semantic_queries [:sequential :string]]
                                                               [:keyword_queries [:sequential :string]]
                                                               [:entity_types {:optional true}
                                                                [:maybe [:sequential [:enum "model" "metric" "table"]]]]]]
  (if-let [invalid (invalid-entity-types entity_types #{"model" "metric" "table"})]
    {:output (str "Invalid entity_types for NLQ search: " (pr-str (vec invalid))
                  ". Allowed types: model, metric, table.")}
    (search-tools/search-tool {:semantic-queries semantic_queries
                               :term-queries keyword_queries
                               :entity-types entity_types
                               :profile-id "nlq"
                               :limit 10})))

(mu/defn transform-search-tool
  "Search for transforms, tables, and models."
  [{:keys [semantic_queries keyword_queries entity_types search_native_query]} :- [:map {:closed true}
                                                                                   [:semantic_queries [:sequential :string]]
                                                                                   [:keyword_queries [:sequential :string]]
                                                                                   [:search_native_query {:optional true} [:maybe :boolean]]
                                                                                   [:entity_types {:optional true}
                                                                                    [:maybe [:sequential [:enum "table" "model" "transform"]]]]]]
  (if-let [invalid (invalid-entity-types entity_types #{"table" "model" "transform"})]
    {:output (str "Invalid entity_types for transform search: " (pr-str (vec invalid))
                  ". Allowed types: table, model, transform.")}
    (search-tools/search-tool {:semantic-queries semantic_queries
                               :term-queries keyword_queries
                               :entity-types entity_types
                               :search-native-query search_native_query
                               :limit 10})))

;;; Query Construction Tools

(defn- normalize-ai-args
  "Normalize nested tool arguments to kebab-case keys and keyword enums."
  [value]
  (let [normalized (when value
                     (metabot-u/recursive-update-keys value metabot-u/safe->kebab-case-en))
        enum-keys #{:operation :bucket :function :sort-order :direction :field-granularity}
        normalize-enum (fn [v]
                         (cond
                           (keyword? v) v
                           (string? v) (case v
                                         "ascending" :asc
                                         "descending" :desc
                                         (keyword v))
                           :else v))]
    (walk/postwalk
     (fn [x]
       (if (map? x)
         (reduce-kv (fn [m k v]
                      (assoc m k (if (enum-keys k) (normalize-enum v) v)))
                    {}
                    x)
         x))
     normalized)))

;; Query construction is handled by construct_notebook_query for parity with ai-service.

(def ^:private construct-field-schema
  [:map {:closed true}
   [:field_id :string]
   [:field_granularity {:optional true} [:maybe :string]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private construct-field-aggregation-schema
  [:map {:closed true}
   [:field_id :string]
   [:function :string]
   [:sort_order {:optional true} [:maybe :string]]
   [:bucket {:optional true} [:maybe :string]]])

(def ^:private construct-measure-aggregation-schema
  [:map {:closed true}
   [:measure_id :int]
   [:sort_order {:optional true} [:maybe :string]]])

(def ^:private construct-metric-schema
  [:or construct-field-aggregation-schema construct-measure-aggregation-schema])

(def ^:private construct-order-by-schema
  [:map {:closed true}
   [:field construct-field-schema]
   [:direction :string]])

(def ^:private construct-field-filter-schema
  [:map {:closed true}
   [:filter_type [:enum "multi_value" "single_value" "no_value"]]
   [:field_id :string]
   [:operation :string]
   [:bucket {:optional true} [:maybe :string]]
   [:value {:optional true} [:maybe :any]]
   [:values {:optional true} [:maybe [:sequential :any]]]])

(def ^:private construct-segment-filter-schema
  [:map {:closed true}
   [:filter_type [:enum "segment"]]
   [:segment_id :int]])

(def ^:private construct-filter-schema
  [:or construct-field-filter-schema construct-segment-filter-schema])

(def ^:private construct-source-metric-schema
  [:map {:closed true}
   [:metric_id :int]])

(def ^:private construct-source-model-schema
  [:map {:closed true}
   [:model_id :int]])

(def ^:private construct-source-table-schema
  [:map {:closed true}
   [:table_id :int]])

(def ^:private construct-query-metric-schema
  [:map {:closed true}
   [:query_type [:enum "metric"]]
   [:source construct-source-metric-schema]
   [:filters [:sequential construct-filter-schema]]
   [:group_by [:sequential construct-field-schema]]])

(def ^:private construct-query-aggregate-schema
  [:map {:closed true}
   [:query_type [:enum "aggregate"]]
   [:source [:or construct-source-model-schema construct-source-table-schema]]
   [:aggregations [:sequential construct-metric-schema]]
   [:filters [:sequential construct-filter-schema]]
   [:group_by [:sequential construct-field-schema]]
   [:limit [:maybe :int]]])

(def ^:private construct-query-raw-schema
  [:map {:closed true}
   [:query_type [:enum "raw"]]
   [:source [:or construct-source-model-schema construct-source-table-schema]]
   [:filters [:sequential construct-filter-schema]]
   [:fields [:sequential construct-field-schema]]
   [:order_by [:sequential construct-order-by-schema]]
   [:limit [:maybe :int]]])

(def ^:private construct-query-schema
  [:or construct-query-metric-schema construct-query-aggregate-schema construct-query-raw-schema])

(def ^:private construct-visualization-schema
  [:map {:closed true}
   [:chart_type :string]])

(def ^:private construct-operation-aliases
  {"contains" :string-contains
   "not-contains" :string-not-contains
   "starts-with" :string-starts-with
   "ends-with" :string-ends-with
   "is-empty" :string-is-empty
   "is-not-empty" :string-is-not-empty})

(defn- normalize-construct-operation
  [operation]
  (let [op (cond
             (keyword? operation) operation
             (string? operation) (keyword operation)
             :else operation)]
    (get construct-operation-aliases (name op) op)))

(defn- normalize-construct-filter
  [filter]
  (let [normalized (normalize-ai-args filter)
        filter-type (:filter-type normalized)
        normalized (assoc normalized :operation (normalize-construct-operation (:operation normalized)))]
    (case filter-type
      :multi-value (-> normalized
                       (dissoc :filter-type :value)
                       (update :values (fn [vals]
                                         (cond
                                           (sequential? vals) (vec vals)
                                           (some? (:value normalized)) [(:value normalized)]
                                           :else []))))
      :single-value (-> normalized
                        (dissoc :filter-type :values)
                        (assoc :value (or (:value normalized)
                                          (first (:values normalized)))))
      :no-value (-> normalized
                    (dissoc :filter-type :value :values))
      :segment (-> normalized
                   (dissoc :filter-type :field-id :operation :bucket :value :values))
      (dissoc normalized :filter-type))))

(defn- normalize-construct-filters
  [filters]
  (mapv normalize-construct-filter filters))

(defn- chart-type->keyword
  [chart-type]
  (cond
    (keyword? chart-type) chart-type
    (string? chart-type) (keyword chart-type)
    :else chart-type))

(defn- query-type->keyword
  [query-type]
  (cond
    (keyword? query-type) query-type
    (string? query-type) (keyword query-type)
    :else query-type))

(mu/defn construct-notebook-query-tool
  "Construct and visualize a notebook query from a metric, model, or table."
  [{:keys [reasoning query visualization]} :- [:map {:closed true}
                                               [:reasoning :string]
                                               [:query construct-query-schema]
                                               [:visualization construct-visualization-schema]]]
  (try
    (let [normalized-query (normalize-ai-args query)
          normalized-visualization (normalize-ai-args visualization)
          query-type (query-type->keyword (:query-type normalized-query))
          chart-type (chart-type->keyword (:chart-type normalized-visualization))
          _ (log/debug "construct_notebook_query request"
                       {:query-type query-type
                        :chart-type chart-type})
          query-result (case query-type
                         :metric
                         (filter-tools/query-metric
                          {:metric-id (get-in normalized-query [:source :metric-id])
                           :filters (normalize-construct-filters (:filters normalized-query))
                           :group-by (normalize-ai-args (:group-by normalized-query))})
                         :aggregate
                         (filter-tools/query-datasource
                          {:model-id (get-in normalized-query [:source :model-id])
                           :table-id (get-in normalized-query [:source :table-id])
                           :aggregations (normalize-ai-args (:aggregations normalized-query))
                           :filters (normalize-construct-filters (:filters normalized-query))
                           :group-by (normalize-ai-args (:group-by normalized-query))
                           :limit (:limit normalized-query)})
                         :raw
                         (filter-tools/query-datasource
                          {:model-id (get-in normalized-query [:source :model-id])
                           :table-id (get-in normalized-query [:source :table-id])
                           :fields (normalize-ai-args (:fields normalized-query))
                           :filters (normalize-construct-filters (:filters normalized-query))
                           :order-by (normalize-ai-args (:order-by normalized-query))
                           :limit (:limit normalized-query)})
                         {:output (str "Unsupported query_type: " query-type)})
          structured (or (:structured-output query-result) (:structured_output query-result))]
      (if (and structured (:query-id structured) (:query structured))
        (let [chart-result (create-chart-tools/create-chart
                            {:query-id (:query-id structured)
                             :chart-type chart-type
                             :queries-state {(:query-id structured) (:query structured)}})
              navigate-url (get-in chart-result [:reactions 0 :url])]
          {:structured-output (assoc structured
                                     :chart-id (:chart-id chart-result)
                                     :chart-type (:chart-type chart-result)
                                     :chart-link (:chart-link chart-result)
                                     :chart-content (:chart-content chart-result))
           :instructions (str "Your query and chart have been created successfully.\n\n"
                              "Next steps to present the chart to the user:\n"
                              "- Always provide a direct link using: `[Chart](metabase://chart/"
                              (:chart-id chart-result) ")` where Chart is a meaningful link text\n"
                              "- If creating multiple charts, present all chart links")
           :data-parts (when navigate-url
                         [(streaming/navigate-to-part navigate-url)])})
        query-result))
    (catch Exception e
      (log/error e "Failed to construct notebook query")
      (if (:agent-error? (ex-data e))
        {:output (ex-message e)}
        {:output (str "Failed to construct notebook query: " (or (ex-message e) "Unknown error"))}))))

;;; Metadata & Details Tools

(mu/defn list-available-data-sources-tool
  "List all data sources (metrics and models) available to the metabot instance."
  [_args :- [:map {:closed true}]]
  (entity-details-tools/answer-sources {:metabot-id metabot-v3.config/embedded-metabot-id
                                        :with-field-values? false}))

(mu/defn list-available-fields-tool
  "Retrieve metadata for tables, models, and metrics."
  [{:keys [table_ids model_ids metric_ids]} :- [:map {:closed true}
                                                [:table_ids [:sequential :int]]
                                                [:model_ids [:sequential :int]]
                                                [:metric_ids [:sequential :int]]]]
  (metadata-tools/get-metadata {:table-ids table_ids
                                :model-ids model_ids
                                :metric-ids metric_ids}))

(mu/defn get-field-values-tool
  "Return metadata for a given field of a given data source."
  [{:keys [data_source source_id field_id]} :- [:map {:closed true}
                                                [:data_source [:enum "table" "model" "metric"]]
                                                [:source_id :int]
                                                [:field_id :string]]]
  (field-stats-tools/field-values {:entity-type data_source
                                   :entity-id source_id
                                   :field-id field_id
                                   :limit nil}))

;;; Transform Tools

(mu/defn get-transform-details-tool
  "Get information about a transform."
  [{:keys [transform_id]} :- [:map {:closed true}
                              [:transform_id :int]]]
  (transform-tools/get-transform-details {:transform-id transform_id}))

(mu/defn get-transform-python-library-details-tool
  "Get information about a Python library by path."
  [{:keys [path]} :- [:map {:closed true}
                      [:path :string]]]
  (transform-tools/get-transform-python-library-details {:path path}))

;;; User Management Tools

;;; SQL Query Tools

(defn- normalize-context-type
  [type-val]
  (cond
    (keyword? type-val) (name type-val)
    (string? type-val) (str/lower-case type-val)
    :else ""))

(defn- first-code-editor-buffer-id
  []
  (let [memory (current-memory)]
    (when memory
      (let [viewing (get-in memory [:context :user_is_viewing] [])]
        (some->> viewing
                 (filter #(= "code-editor" (normalize-context-type (:type %))))
                 first
                 :buffers
                 first
                 :id)))))

(defn- code-edit-part
  [buffer-id sql]
  (streaming/code-edit-part {:buffer_id buffer-id
                             :mode "rewrite"
                             :value sql}))

(mu/defn create-sql-query-tool
  "Create a new SQL query."
  [{:keys [database_id sql_query]}
   :- [:map {:closed true}
       [:database_id :int]
       [:sql_query :string]]]
  (create-sql-query-tools/create-sql-query-tool
   {:database-id database_id
    :sql sql_query}))

(mu/defn create-sql-query-code-edit-tool
  "Create a new SQL query and update the code editor buffer."
  [{:keys [database_id sql_query]}
   :- [:map {:closed true}
       [:database_id :int]
       [:sql_query :string]]]
  (let [result (create-sql-query-tools/create-sql-query
                {:database-id database_id
                 :sql sql_query})
        buffer-id (first-code-editor-buffer-id)]
    (if buffer-id
      {:structured-output result
       :instructions instructions/query-created-instructions
       :data-parts [(code-edit-part buffer-id (:query-content result))]}
      {:output "No active code editor buffer found for SQL editing."})))

(mu/defn edit-sql-query-tool
  "Edit an existing SQL query using structured edits."
  [{:keys [query_id edits checklist]}
   :- [:map {:closed true}
       [:query_id [:or :string :int]]
       [:checklist :string]
       [:edits [:sequential [:map {:closed true}
                             [:old_string :string]
                             [:new_string :string]
                             [:replace_all {:optional true} [:maybe :boolean]]]]]]]
  (edit-sql-query-tools/edit-sql-query-tool
   {:query-id query_id
    :edits edits
    :checklist checklist
    :queries-state (current-queries-state)}))

(mu/defn edit-sql-query-code-edit-tool
  "Edit an existing SQL query and update the code editor buffer."
  [{:keys [query_id edits checklist]}
   :- [:map {:closed true}
       [:query_id [:or :string :int]]
       [:checklist :string]
       [:edits [:sequential [:map {:closed true}
                             [:old_string :string]
                             [:new_string :string]
                             [:replace_all {:optional true} [:maybe :boolean]]]]]]]
  (let [result (edit-sql-query-tools/edit-sql-query
                {:query-id query_id
                 :edits edits
                 :checklist checklist
                 :queries-state (current-queries-state)})
        buffer-id (first-code-editor-buffer-id)]
    (if buffer-id
      {:structured-output result
       :instructions instructions/edit-sql-query-instructions
       :data-parts [(code-edit-part buffer-id (:query-content result))]}
      {:output "No active code editor buffer found for SQL editing."})))

(mu/defn replace-sql-query-tool
  "Replace the SQL content of an existing query entirely."
  [{:keys [query_id new_query checklist]}
   :- [:map {:closed true}
       [:query_id [:or :string :int]]
       [:checklist :string]
       [:new_query :string]]]
  (replace-sql-query-tools/replace-sql-query-tool
   {:query-id query_id
    :sql new_query
    :checklist checklist
    :queries-state (current-queries-state)}))

(mu/defn replace-sql-query-code-edit-tool
  "Replace an SQL query and update the code editor buffer."
  [{:keys [query_id new_query checklist]}
   :- [:map {:closed true}
       [:query_id [:or :string :int]]
       [:checklist :string]
       [:new_query :string]]]
  (let [result (replace-sql-query-tools/replace-sql-query
                {:query-id query_id
                 :sql new_query
                 :checklist checklist
                 :queries-state (current-queries-state)})
        buffer-id (first-code-editor-buffer-id)]
    (if buffer-id
      {:structured-output result
       :instructions instructions/query-created-instructions
       :data-parts [(code-edit-part buffer-id (:query-content result))]}
      {:output "No active code editor buffer found for SQL editing."})))

;;; Chart Tools

(mu/defn create-chart-tool
  "Create a chart from a query.

  Provide a query_id in data_source and a chart_type in viz_settings."
  [{:keys [data_source viz_settings]}
   :- [:map {:closed true}
       [:data_source [:map {:closed true}
                      [:query_id :string]]]
       [:viz_settings [:map {:closed true}
                       [:chart_type [:enum "table" "bar" "line" "pie" "sunburst" "area" "combo"
                                     "row" "pivot" "scatter" "waterfall" "sankey" "scalar"
                                     "smartscalar" "gauge" "progress" "funnel" "object" "map"]]]]]]
  (create-chart-tools/create-chart-tool
   {:query-id (get data_source :query_id)
    :chart-type (keyword (get viz_settings :chart_type))
    :queries-state (current-queries-state)}))

(mu/defn edit-chart-tool
  "Edit an existing chart's visualization type.

  Provide a new chart_type in new_viz_settings."
  [{:keys [chart_id new_viz_settings]}
   :- [:map {:closed true}
       [:chart_id :string]
       [:new_viz_settings [:map {:closed true}
                           [:chart_type [:enum "table" "bar" "line" "pie" "sunburst" "area" "combo"
                                         "row" "pivot" "scatter" "waterfall" "sankey" "scalar"
                                         "smartscalar" "gauge" "progress" "funnel" "object" "map"]]]]]]
  (edit-chart-tools/edit-chart-tool
   {:chart-id chart_id
    :new-chart-type (keyword (get new_viz_settings :chart_type))
    :charts-state (current-charts-state)}))

;;; Resource Reading Tools

(mu/defn read-resource-tool
  "Read detailed information about Metabase resources via URI patterns.

  Supports fetching multiple resources in parallel using metabase:// URIs:
  - metabase://table/{id}/fields - Get table structure with fields
  - metabase://model/{id}/fields/{field_id} - Get specific field details
  - metabase://metric/{id}/dimensions - Get metric dimensions
  - metabase://transform/{id} - Get transform details
  - metabase://dashboard/{id} - Get dashboard details"
  [{:keys [uris]}
   :- [:map {:closed true}
       [:uris [:sequential [:string {:description "Metabase resource URIs to fetch"}]]]]]
  (read-resource-tools/read-resource-tool {:uris uris}))

;;; Todo Tools

(mu/defn todo-write-tool
  "Create and manage a structured task list.
  Write or update the todo list with tasks for tracking progress.

  Each todo item must have:
  - id: Unique identifier for the task
  - content: Description of what needs to be done
  - status: One of 'pending', 'in_progress', 'completed', 'cancelled'
  - priority: One of 'high', 'medium', 'low'"
  [{:keys [todos]}
   :- [:map {:closed true}
       [:todos [:sequential [:map {:closed true}
                             [:id :string]
                             [:content :string]
                             [:status [:enum "pending" "in_progress" "completed" "cancelled"]]
                             [:priority [:enum "high" "medium" "low"]]]]]]]
  (todo-tools/todo-write-tool {:todos todos
                               :memory-atom *memory-atom*}))

(mu/defn todo-read-tool
  "Read the current todo list from memory.
  Returns the list of todos that have been created during this conversation."
  [_args :- [:map {:closed true}]]
  (todo-tools/todo-read-tool {:memory-atom *memory-atom*}))

;;; Navigation Tools

(mu/defn navigate-user-tool
  "Navigate the user to a specific page or entity in Metabase.

  Use this tool to direct users to:
  - Pages: notebook_editor, metrics_browser, model_browser, database_browser, sql_editor
  - Entities: table, model, question, metric, dashboard
  - Query results or charts from the current conversation"
  [{:keys [destination]}
   :- [:map {:closed true}
       [:destination [:or
                      [:map {:closed true}
                       [:page [:enum "notebook_editor" "metrics_browser" "model_browser" "database_browser"]]]
                      [:map {:closed true}
                       [:page [:enum "sql_editor"]]
                       [:database_id :int]]
                      [:map {:closed true}
                       [:entity_type [:enum "table" "model" "question" "metric" "dashboard"]]
                       [:entity_id :int]]
                      [:map {:closed true}
                       [:query_id :string]]
                      [:map {:closed true}
                       [:chart_id :string]]]]]]
  (navigate-tools/navigate-tool {:destination destination
                                 :memory-atom *memory-atom*}))

;;; Snippet Tools

(mu/defn list-snippets-tool
  "List all SQL snippets available in the Metabase instance.

  Use this tool before editing or creating SQL transforms to understand what
  snippets are available. If any snippets may be relevant to the user's request,
  fetch their content using the get_snippet_details tool."
  [_args :- [:map {:closed true}]]
  (snippet-tools/get-snippets {}))

(mu/defn get-snippet-details-tool
  "Get the full details of a SQL snippet including its content.

  Use this tool to retrieve the actual SQL content of a snippet after identifying
  it with list_snippets."
  [{:keys [snippet_id]}
   :- [:map {:closed true}
       [:snippet_id :int]]]
  (snippet-tools/get-snippet-details {:snippet-id snippet_id}))

;;; Ask Clarification Tool

(mu/defn ask-for-sql-clarification-tool
  "Ask the user for clarification about their SQL query request.

  Use this tool when you need more information from the user to properly
  complete their SQL request. The agent will stop and wait for the user's response."
  [{:keys [question options]}
   :- [:map {:closed true}
       [:question :string]
       [:options {:optional true} [:maybe [:sequential :string]]]]]
  (ask-clarification-tools/ask-for-sql-clarification-tool {:question question
                                                           :options options}))

;;; Transform Write Tools

(mu/defn write-transform-sql-tool
  "Write new SQL queries or edit existing queries for transforms.

  Supports two modes:
  - edit: Targeted string replacements with partial edits
  - replace: Replace entire query atomically

  For edit mode, provide edits as an array of {old_string, new_string, replace_all} objects.
  For replace mode, provide new_content with the complete SQL."
  [{:keys [transform_id edit_action thinking transform_name transform_description
           source_database source_tables]}
   :- [:map {:closed true}
       [:transform_id {:optional true} [:maybe :int]]
       [:edit_action [:map
                      [:mode [:enum "edit" "replace"]]
                      [:edits {:optional true} [:maybe [:sequential [:map
                                                                     [:old_string :string]
                                                                     [:new_string :string]
                                                                     [:replace_all {:optional true} [:maybe :boolean]]]]]]
                      [:new_content {:optional true} [:maybe :string]]]]
       [:thinking {:optional true} [:maybe :string]]
       [:transform_name {:optional true} [:maybe :string]]
       [:transform_description {:optional true} [:maybe :string]]
       [:source_database {:optional true} [:maybe :int]]
       [:source_tables {:optional true} [:maybe :map]]]]
  (transforms-write-tools/write-transform-sql-tool
   {:transform_id transform_id
    :edit_action edit_action
    :thinking thinking
    :transform_name transform_name
    :transform_description transform_description
    :source_database source_database
    :source_tables source_tables
    :memory-atom *memory-atom*
    :context (current-context)}))

(mu/defn write-transform-python-tool
  "Write new Python code or edit existing code for transforms.

  Supports two modes:
  - edit: Targeted string replacements with partial edits
  - replace: Replace entire code atomically

  For edit mode, provide edits as an array of {old_string, new_string, replace_all} objects.
  For replace mode, provide new_content with the complete Python code."
  [{:keys [transform_id edit_action thinking transform_name transform_description
           source_database source_tables]}
   :- [:map {:closed true}
       [:transform_id {:optional true} [:maybe :int]]
       [:edit_action [:map
                      [:mode [:enum "edit" "replace"]]
                      [:edits {:optional true} [:maybe [:sequential [:map
                                                                     [:old_string :string]
                                                                     [:new_string :string]
                                                                     [:replace_all {:optional true} [:maybe :boolean]]]]]]
                      [:new_content {:optional true} [:maybe :string]]]]
       [:thinking {:optional true} [:maybe :string]]
       [:transform_name {:optional true} [:maybe :string]]
       [:transform_description {:optional true} [:maybe :string]]
       [:source_database {:optional true} [:maybe :int]]
       [:source_tables {:optional true} [:maybe :map]]]]
  (transforms-write-tools/write-transform-python-tool
   {:transform_id transform_id
    :edit_action edit_action
    :thinking thinking
    :transform_name transform_name
    :transform_description transform_description
    :source_database source_database
    :source_tables source_tables
    :memory-atom *memory-atom*
    :context (current-context)}))

;;; Autogenerated Dashboard Tool

(mu/defn create-autogenerated-dashboard-tool
  "Create an automatically generated dashboard using Metabase's X-ray feature.

  X-ray builds complete dashboards with multiple visualizations that showcase
  different aspects of your data - distributions, breakdowns by categories,
  trends over time, and relationships between fields.

  Specify one source type:
  - table_id: Create dashboard for a table
  - model_id: Create dashboard for a model
  - metric_id: Create dashboard for a metric
  - query_id: Create dashboard for query results from this conversation
  - report_id: Create dashboard for an existing report/question"
  [{:keys [source]}
   :- [:map {:closed true}
       [:source [:map
                 [:table_id {:optional true} [:maybe :int]]
                 [:model_id {:optional true} [:maybe :int]]
                 [:metric_id {:optional true} [:maybe :int]]
                 [:query_id {:optional true} [:maybe :string]]
                 [:report_id {:optional true} [:maybe :int]]]]]]
  (autogen-dashboard-tools/create-autogenerated-dashboard-tool
   {:source source
    :memory-atom *memory-atom*}))

;; Tool registry - maps tool name to var
(def all-tools
  "Registry of all available tools."
  {"search"                        #'search-tool
   "construct_notebook_query"      #'construct-notebook-query-tool
   "list_available_data_sources"   #'list-available-data-sources-tool
   "list_available_fields"         #'list-available-fields-tool
   "get_field_values"              #'get-field-values-tool
   "get_transform_details"         #'get-transform-details-tool
   "get_transform_python_library_details" #'get-transform-python-library-details-tool
   "create_sql_query"              #'create-sql-query-tool
   "edit_sql_query"                #'edit-sql-query-tool
   "replace_sql_query"             #'replace-sql-query-tool
   "read_resource"                 #'read-resource-tool
   "create_chart"                  #'create-chart-tool
   "edit_chart"                    #'edit-chart-tool
   "todo_write"                    #'todo-write-tool
   "todo_read"                     #'todo-read-tool
   "navigate_user"                 #'navigate-user-tool
   "list_snippets"                 #'list-snippets-tool
   "get_snippet_details"           #'get-snippet-details-tool
   "ask_for_sql_clarification"     #'ask-for-sql-clarification-tool
   "write_transform_sql"           #'write-transform-sql-tool
   "write_transform_python"        #'write-transform-python-tool
   "create_autogenerated_dashboard" #'create-autogenerated-dashboard-tool})

(def ^:private profile-tool-overrides
  {:embedding_next {"list_available_data_sources" #'list-available-data-sources-tool}
   :sql {"search" #'sql-search-tool
         "create_sql_query" #'create-sql-query-code-edit-tool
         "edit_sql_query" #'edit-sql-query-code-edit-tool
         "replace_sql_query" #'replace-sql-query-code-edit-tool}
   :nlq {"search" #'nlq-search-tool}
   :transforms_codegen {"search" #'transform-search-tool}})

;;; Capability-Based Tool Filtering
;;
;; Some tools require specific capabilities to be available.
;; Capabilities are passed in the request context and represent features/permissions.

(def ^:private tool-capabilities
  "Map of tool names to required capabilities.
  Tools not listed here have no special capability requirements."
  {"navigate_user"                  #{:frontend-navigate-user-v1}
   "create_autogenerated_dashboard" #{:automagic-dashboards}
   "write_transform_sql"            #{:feature-transforms :permission-write-transforms}
   "write_transform_python"         #{:feature-transforms :feature-transforms-python :permission-write-transforms}
   "list_snippets"                  #{:feature-snippets}
   "get_snippet_details"            #{:feature-snippets}})

(defn filter-by-capabilities
  "Filter tool names by user capabilities.
  Removes tools that require capabilities the user doesn't have."
  [tool-names capabilities]
  (let [capabilities-set (set capabilities)]
    (filter (fn [tool-name]
              (let [required (get tool-capabilities tool-name #{})]
                (every? capabilities-set required)))
            tool-names)))

(defn get-tools-for-profile
  "Get tool registry filtered by profile configuration and user capabilities."
  [profile-id capabilities]
  (let [profile (profiles/get-profile profile-id)
        tool-names (or (:tools profile) [])
        base-tools (select-keys all-tools (filter-by-capabilities tool-names capabilities))
        overrides (get profile-tool-overrides profile-id {})]
    (merge base-tools overrides)))

;;; State-aware tool wrapping
;;
;; Some tools need access to agent state (queries, charts) to function properly.
;; These tools are wrapped at runtime with access to the memory atom.

(def ^:private state-dependent-tools
  "Set of tool names that require access to agent state."
  #{"create_chart" "edit_chart" "todo_write" "todo_read" "navigate_user"
    "write_transform_sql" "write_transform_python" "create_autogenerated_dashboard"
    "create_sql_query" "edit_sql_query" "replace_sql_query"})

(defn wrap-tools-with-state
  "Wrap state-dependent tools with access to the memory atom.
  Tools in `state-dependent-tools` will have access to the memory atom
  via the dynamic `*memory-atom*` binding.

  Returns a new tools map where state-dependent tools are wrapped.
  Wrapped tools are returned as maps with :doc, :schema, and :fn keys
  to satisfy the Claude API schema validation."
  [tools memory-atom]
  (reduce-kv
   (fn [acc tool-name tool-var]
     (if (contains? state-dependent-tools tool-name)
       ;; Wrap the tool - return a map with :doc, :schema, :fn
       ;; This format is accepted by claude.clj schema and tool->claude
       (let [{:keys [doc schema system-instructions]} (meta tool-var)
             wrapped-fn (fn [args]
                          (binding [*memory-atom* memory-atom]
                            (tool-var args)))]
         (assoc acc tool-name {:doc doc
                               :schema schema
                               :system-instructions system-instructions
                               :fn wrapped-fn}))
       ;; Keep non-state-dependent tools as-is
       (assoc acc tool-name tool-var)))
   {}
   tools))
