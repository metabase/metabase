(ns metabase-enterprise.semantic-search.index
  (:require
   [cheshire.core :as json]
   [clojure.string :as str]
   [honey.sql :as sql]
   [honey.sql.helpers :as sql.helpers]
   [nano-id.core :as nano-id]
   [next.jdbc :as jdbc]
   [semantic-search.db :as db]
   [semantic-search.embedding :as embedding]))

(def ^:dynamic *index-table-name*
  :search_index)

(defn- index-table-schema
  "Schema for the index table."
  [table-name]
  ;; Generate unique constraint name to avoid index name conflicts for multiple test tables
  (let [constraint-name (keyword (str "unique_constraint_" (nano-id/nano-id) "_model_model_id"))]
    [[:id :bigint [:primary-key] [:raw "GENERATED BY DEFAULT AS IDENTITY"]]
     [:model :text :not-null]
     [:model_id :text :not-null]
     [:embedding [:raw "vector(1024)"] :not-null]
     [:content :text :not-null]
     [:metadata :jsonb]
     [:created_at :timestamp-with-time-zone
      [:default [:raw "CURRENT_TIMESTAMP"]] :not-null]
     [[:constraint constraint-name]
      [:unique [:composite :model :model_id]]]]))

(defn- format-embedding
  "Formats the embedding vector for SQL insertion."
  [embedding]
  (str "'[" (str/join ", " embedding) "]'::vector"))

(defn populate-index!
  "Inserts a set of documents into the index table."
  [documents]
  (jdbc/with-transaction [tx @db/data-source]
    (doseq [doc documents]
      (let [{:keys [model id searchable_text]} doc
            embedding (embedding/get-embedding searchable_text)]
        (jdbc/execute!
         tx
         (sql/format
          (-> (sql.helpers/insert-into *index-table-name*)
              (sql.helpers/values
               [{:model model
                 :model_id id
                 :embedding [:raw (format-embedding embedding)]
                 :content searchable_text
                 :metadata [:cast (json/encode doc) :jsonb]}]))))))))

(defn- upsert-honeysql
  [{:keys [model id searchable_text] :as doc} embedding]
  (->
   (sql.helpers/insert-into *index-table-name*)
   (sql.helpers/values
    [{:model model
      :model_id id
      :embedding [:raw (format-embedding embedding)]
      :content searchable_text
      :metadata [:cast (json/encode doc) :jsonb]}])
   (sql.helpers/on-conflict :model :model_id)
   (sql.helpers/do-update-set
    {:embedding [:raw (format-embedding embedding)]
     :content searchable_text
     :metadata [:cast (json/encode doc) :jsonb]
     :created_at [:raw "CURRENT_TIMESTAMP"]})))

(defn upsert-index!
  "Inserts or updates documents in the index table. If a document with the same
  model + model_id already exists, it will be replaced."
  [documents]
  (jdbc/with-transaction [tx @db/data-source]
    (doseq [{:keys [searchable_text] :as doc} documents]
      (let [embedding (embedding/get-embedding searchable_text)]
        (jdbc/execute!
         tx
         (sql/format
          (upsert-honeysql doc embedding)))))))

(defn- drop-index-table-sql
  []
  (sql/format (sql.helpers/drop-table :if-exists *index-table-name*)))

(defn drop-index-table!
  "Drop the index table if it exists."
  ([]   (jdbc/execute! @db/data-source (drop-index-table-sql)))
  ([tx] (jdbc/execute! tx (drop-index-table-sql))))

(defn create-index-table!
  "Ensure that the index table exists and is ready to be populated. If
  force-reset? is true, drops and recreates the table if it exists."
  [{:keys [force-reset?] :or {force-reset? false}}]
  (try
    (jdbc/with-transaction [tx @db/data-source]
      (jdbc/execute! tx (sql/format (sql.helpers/create-extension :vector :if-not-exists)))
      (when force-reset? (drop-index-table! tx))
      (jdbc/execute!
       tx
       (-> (sql.helpers/create-table *index-table-name*)
           (sql.helpers/with-columns (index-table-schema *index-table-name*))
           sql/format)))
    (catch Exception e
      (throw (ex-info "Failed to create index table" {:cause e})))))

(defn- semantic-search-query
  "Build a semantic search query using vector similarity."
  [embedding]
  {:select [[:model_id :model_id]
            [:model :model]
            [:content :content]
            [[:raw (str "embedding <=> " (format-embedding embedding))] :distance]
            [:metadata :metadata]]
   :from   [*index-table-name*]
   :order-by [[:distance :asc]]
   :limit  100})

(defn- legacy-input-with-score [index-row]
  (-> (:legacy_input index-row)
      (assoc  :score (:distance index-row 1.0))))

;; TODO: can the query return unqualified keys directly?
(defn- unqualify-keys
  "Remove table namespace from namespaced keywords in a result row."
  [row]
  (into {} (map (fn [[k v]] [(keyword (name k)) v]) row)))

(defn- decode-pgobject
  "Decode a PGObject (returned from a jsonb field) into a Clojure map."
  [pgobject]
  (json/parse-string (.getValue pgobject) true))

(defn query-index
  "Query the index for documents similar to the search string."
  [search-string]
  (when-not (str/blank? search-string)
    (let [embedding (embedding/get-embedding search-string)
          query     (semantic-search-query embedding)]
      (->> (db/execute! (sql/format query))
           (map unqualify-keys)
           (map :metadata)
           (map decode-pgobject)
           (map legacy-input-with-score)))))

(defn delete-from-index!
  "Deletes documents from the index table based on model and model_ids."
  [model model-ids]
  (jdbc/with-transaction [tx @db/data-source]
    (jdbc/execute!
     tx
     (sql/format
      (-> (sql.helpers/delete-from *index-table-name*)
          (sql.helpers/where [:and
                              [:= :model model]
                              [:in :model_id model-ids]]))))))

(comment
  (create-index-table! {:force-reset? true})
  (populate-index! [{:model "card"
                     :id "1"
                     :searchable_text "This is a test card"}])
  (time (query-index "metrics"))
  (delete-from-index! "dashboard" ["13"]))
