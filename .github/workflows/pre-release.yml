name: Release 2 - Pre-release testing
run-name: Pre-release testing of ${{ inputs.version }}

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Metabase version (e.g. v0.46.3)"
        type: string
        required: true
      commit:
        description: "A full-length commit SHA-1 hash"
        type: string
        required: true
  workflow_call:
    inputs:
      version:
        description: "Metabase version (e.g. v0.46.3)"
        type: string
        required: true
      commit:
        description: "A full-length commit SHA-1 hash"
        type: string
        required: true

jobs:
  test-mode-config:
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    outputs:
      run_mode: ${{ fromJson(steps.config.outputs.result).runMode }}
      dev_server: ${{ fromJson(steps.config.outputs.result).metastoreDevServer }}
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            release
            .github
      - name: Prepare release scripts
        uses: ./.github/actions/prepare-release-scripts
      # note: this block can be removed after we stop needing to be able to test versions before v55
      - name: Get test mode config
        id: config
        uses: actions/github-script@v7
        with:
          script: | # js
            const { getMajorVersion } = require('${{ github.workspace }}/release/dist/index.cjs');

            // Versions before v55 used a single token for testing
            // with v55 and later we use enterprise tokens that mirror actual Metabase plans
            const MULTIPLE_TEST_TOKEN_THRESHOLD = 55;

            const version = '${{ inputs.version }}';
            const majorVersion = Number(getMajorVersion(version));
            const oldTestToken = majorVersion < MULTIPLE_TEST_TOKEN_THRESHOLD;

            return ({
              runMode: oldTestToken ? 'prod' : 'e2e',
              metastoreDevServer: oldTestToken ? '' : '${{ vars.METASTORE_DEV_SERVER_URL }}'
            });

  release-artifact:
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    strategy:
      matrix:
        edition: [oss, ee]
    outputs:
      ee_version: ${{ steps.version-properties.outputs.ee_version }}
      oss_version: ${{ steps.version-properties.outputs.oss_version }}
      commit: ${{ steps.version-properties.outputs.commit }}
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: .github
      - name: Retrieve release uberjar artifact for ${{ matrix.edition }}
        uses: ./.github/actions/fetch-artifact
        with:
          commit: ${{ inputs.commit }}
          edition: ${{ matrix.edition }}
          release: "true"

      - name: Extract version number from  version.properties
        id: version-properties
        run: |
          cat version.properties
          echo "commit=$(cat ./COMMIT-ID)" >> $GITHUB_OUTPUT

          version=$(grep -o '^tag=.*' version.properties | cut -d'=' -f2)

          if [[ "${{ matrix.edition }}" == "ee" ]]; then
            echo "ee_version=$version" >> $GITHUB_OUTPUT
          else
            echo "oss_version=$version" >> $GITHUB_OUTPUT
          fi
        shell: bash
      - name: Upload Metabase ${{ matrix.edition }} JAR as artifact
        uses: actions/upload-artifact@v4
        with:
          name: metabase-test-${{ matrix.edition }}-uberjar
          path: |
            ./metabase.jar
            ./COMMIT-ID
            ./SHA256.sum

  check-uberjar-health:
    needs: [release-artifact]
    runs-on: ubuntu-22.04
    name: Is ${{ matrix.edition }} (java ${{ matrix.java-version }}) healthy?
    timeout-minutes: 10
    strategy:
      matrix:
        edition: [oss, ee]
        java-version: [21]
    steps:
      - name: Prepare JRE (Java Run-time Environment)
        uses: actions/setup-java@v4
        with:
          java-package: jre
          java-version: ${{ matrix.java-version }}
          distribution: "temurin"
      - run: java -version
      - uses: actions/download-artifact@v4
        name: Retrieve uberjar artifact
        with:
          name: metabase-test-${{ matrix.edition }}-uberjar
      - name: Launch uberjar (and keep it running)
        run: >-
          java --add-opens java.base/java.nio=ALL-UNNAMED -jar ./metabase.jar &
      - name: Wait for Metabase to start
        run: while ! curl -s 'http://localhost:3000/api/health' | grep '{"status":"ok"}'; do sleep 1; done

  run-sanity-check:
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    needs: [test-mode-config, release-artifact]
    strategy:
      matrix:
        edition: [oss, ee]
    env:
      MB_EDITION: ${{ matrix.edition }}
      DISPLAY: ""
      MB_RUN_MODE: ${{ needs.test-mode-config.outputs.run_mode }}
      METASTORE_DEV_SERVER_URL: ${{ needs.test-mode-config.outputs.dev_server }}
      CYPRESS_MB_ALL_FEATURES_TOKEN: ${{ secrets.STAGING_MB_ALL_FEATURES_TOKEN }}
      CYPRESS_MB_STARTER_CLOUD_TOKEN: ${{ secrets.STAGING_MB_STARTER_CLOUD_TOKEN }}
      CYPRESS_MB_PRO_CLOUD_TOKEN: ${{ secrets.STAGING_MB_PRO_CLOUD_TOKEN }}
      CYPRESS_MB_PRO_SELF_HOSTED_TOKEN: ${{ secrets.STAGING_MB_PRO_SELF_HOSTED_TOKEN }}
      # these are needed for backwards compatibility with release branches earlier than v55, since
      # this workflow always runs from master, but we run tests from the release branch
      CYPRESS_ALL_FEATURES_TOKEN: ${{ secrets.MB_ALL_FEATURES_TOKEN }}
      CYPRESS_NO_FEATURES_TOKEN: ${{ secrets.MB_STARTER_CLOUD_TOKEN }}
      # disabled because of out of memory issues
      # probably related to https://github.com/cypress-io/cypress/issues/27415
      CYPRESS_NO_COMMAND_LOG: 1
      MB_SNOWPLOW_AVAILABLE: true
      MB_SNOWPLOW_URL: "http://localhost:9090" # Snowplow micro
      TERM: xterm
    steps:
      - name: Check out the code
        uses: actions/checkout@v4
      - name: Prepare Docker containers
        uses: ./.github/actions/e2e-prepare-containers
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          maildev: true
          snowplow: true
      - name: Prepare front-end environment
        uses: ./.github/actions/prepare-frontend
      - name: Prepare back-end environment
        uses: ./.github/actions/prepare-backend
      - name: Compile CLJS
        run: bun run build-pure:cljs
      - name: Prepare Cypress environment
        id: cypress-prep
        uses: ./.github/actions/prepare-cypress
      - uses: actions/download-artifact@v4
        name: Retrieve uberjar artifact for ${{ matrix.edition }}
        with:
          name: metabase-test-${{ matrix.edition }}-uberjar
      - name: Get the version info
        run: |
          jar xf metabase.jar version.properties
          mv version.properties resources/

      - name: Move jar
        run: mkdir -p ./target/uberjar && cp metabase.jar ./target/uberjar/metabase.jar

      - name: Run Metabase
        run: node e2e/runner/run_cypress_ci.js start

      # For now we only need the default snapshots for pre-release checks.
      # If we decide to include tests that rely on the external QA databases, we should:
      #   1. remove the --spec ... line
      #   2. add postgres, mysql, and mongo to the prepare-containers step
      - name: Make app db snapshot
        run: |
          node e2e/runner/run_cypress_ci.js snapshot \
            --spec "e2e/snapshot-creators/default.cy.snap.js"

      - name: Run a few important OSS Cypress tests as sanity check
        if: ${{ matrix.edition == 'oss' }}
        env:
          CYPRESS_BROWSER: ${{ steps.cypress-prep.outputs.chrome-path }}
        run: |
          node e2e/runner/run_cypress_ci.js e2e \
            --env grepTags="@smoke+-@EE" \
            --spec './e2e/test/scenarios/**/*.cy.spec.(js|ts)'

      - name: Run a few important EE Cypress tests as sanity check
        if: ${{ matrix.edition == 'ee' }}
        env:
          CYPRESS_BROWSER: ${{ steps.cypress-prep.outputs.chrome-path }}
        run: |
          node e2e/runner/run_cypress_ci.js e2e \
            --env grepTags="@smoke+-@OSS" \
            --spec './e2e/test/scenarios/**/*.cy.spec.(js|ts)'

      - name: Upload Cypress Artifacts upon failure
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-failed-tests-recording
          path: |
            ./cypress
            ./logs/test.log
          if-no-files-found: ignore

  containerize-oss:
    needs: release-artifact
    uses: ./.github/workflows/containerize-jar.yml
    secrets: inherit
    with:
      edition: oss
      commit: ${{ inputs.commit }}
      repo: ${{ vars.DOCKERHUB_OWNER }}/${{ vars.DOCKERHUB_STAGING_REPO }}
      tag: ${{ needs.release-artifact.outputs.oss_version }}-${{ inputs.commit }}
      release: "true"

  containerize-ee:
    needs: release-artifact
    uses: ./.github/workflows/containerize-jar.yml
    secrets: inherit
    with:
      edition: ee
      commit: ${{ inputs.commit }}
      repo: ${{ vars.DOCKERHUB_OWNER }}/${{ vars.DOCKERHUB_STAGING_REPO }}
      tag: ${{ needs.release-artifact.outputs.ee_version }}-${{ inputs.commit }}
      release: "true"

  tests-complete-message:
    if: always()
    runs-on: ubuntu-22.04
    needs:
      [
        run-sanity-check,
        check-uberjar-health,
        containerize-ee,
        containerize-oss,
      ]
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            release
            .github
      - name: Prepare release scripts
        uses: ./.github/actions/prepare-release-scripts
      - name: Send tests complete message
        uses: actions/github-script@v7
        env:
          SLACK_RELEASE_CHANNEL: ${{ vars.SLACK_RELEASE_CHANNEL }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        with:
          script: | # js
            const { sendTestsCompleteMessage } = require('${{ github.workspace }}/release/dist/index.cjs');

            const allJobsSuccessful =
              '${{ needs.run-sanity-check.result }}' === 'success' &&
              '${{ needs.check-uberjar-health.result }}' === 'success' &&
              '${{ needs.containerize-ee.result }}' === 'success' &&
              '${{ needs.containerize-oss.result }}' === 'success';

            await sendTestsCompleteMessage({
              owner: context.repo.owner,
              repo: context.repo.repo,
              version: '${{ inputs.version }}',
              runId: '${{ github.run_id }}',
              channelName: '${{ vars.SLACK_RELEASE_CHANNEL }}',
              testStatus: allJobsSuccessful ? 'success' : 'failure',
            }).catch(console.error);
