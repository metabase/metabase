(ns metabase-enterprise.metabot-v3.tools.util
  (:require
   [clojure.string :as str]
   [medley.core :as m]
   [metabase.api.common :as api]
   [metabase.lib-be.metadata.jvm :as lib.metadata.jvm]
   [metabase.lib.core :as lib]
   [metabase.lib.metadata :as lib.metadata]
   [metabase.lib.types.isa :as lib.types.isa]
   [metabase.models.interface :as mi]
   [metabase.util :as u]
   [toucan2.core :as t2]))

(defn handle-agent-error
  "Return an agent output for agent errors, re-throw `e` otherwise."
  [e]
  (if (-> e ex-data :agent-error?)
    {:output (ex-message e)}
    (throw e)))

(defn convert-field-type
  "Return tool type for `column`."
  [column]
  (let [column (u/normalize-map column)]
    (cond
      (lib.types.isa/boolean? column)                :boolean
      (lib.types.isa/string-or-string-like? column)  :string
      (lib.types.isa/numeric? column)                :number
      (isa? (:effective-type column) :type/DateTime) :datetime
      (isa? (:effective-type column) :type/Time)     :time
      (lib.types.isa/temporal? column)               :date)))

(defn table-field-id-prefix
  "Return the field ID prefix for `table-id`."
  [table-id]
  (str "t" table-id "/"))

(defn card-field-id-prefix
  "Return the field ID prefix for a model or a metric with ID `card-id`."
  [card-id]
  (str "c" card-id "/"))

(defn query-field-id-prefix
  "Return the field ID prefix for `query-id`."
  [query-id]
  (str "q" query-id "/"))

(def any-prefix-pattern
  "A prefix pattern accepting columns from any entity."
  #"^.*/(\d+)")

(defn ->result-column
  "Return tool result columns for `column` of `query`. The position of `column` is determined by `index`.
  The ID is then generated by prefixing the position with `field-id-prefix`."
  [query column index field-id-prefix]
  (let [semantic-type (some-> (:semantic-type column) name u/->snake_case_en)]
    (-> {:field-id (str field-id-prefix index)
         :name (lib/display-name query column)
         :type (convert-field-type column)}
        (m/assoc-some :description (:description column)
                      :semantic-type semantic-type
                      :field-values (:field-values column)
                      :table-reference (:table-reference column)))))

(defn resolve-column-index
  "Resolve the reference `field_id` to the index of the result columns in the entity with `field-id-prefix`."
  [field-id field-id-prefix]
  (if (string? field-id-prefix)
    (if (str/starts-with? field-id field-id-prefix)
      (-> field-id (subs (count field-id-prefix)) parse-long)
      (throw (ex-info (str "field " field-id " not found") {:agent-error? true
                                                            :expected-prefix field-id-prefix})))
    (if-let [id-str (when (instance? java.util.regex.Pattern field-id-prefix)
                      (-> (re-matches field-id-prefix field-id)
                          second))]
      (parse-long id-str)
      (throw (ex-info (str "invalid field_id " field-id " for prefix " field-id-prefix)
                      {:agent-error? true
                       :expected-prefix (str field-id-prefix)
                       :field-id field-id})))))

(defn resolve-column
  "Resolve the reference `field-id` in filter `item` by finding the column in `columns` specified by `field-id`.
  `field-id-prefix` is used to check if the filter refers to a column from the right entity."
  [{:keys [field-id] :as item} field-id-prefix columns]
  (let [index (resolve-column-index field-id field-id-prefix)]
    (assoc item :column (nth columns index))))

(defn get-table
  "Get the `fields` of the table with ID `id`."
  [id & fields]
  (-> (t2/select-one (into [:model/Table :id] fields) id)
      api/read-check))

(defn get-card
  "Retrieve the card with `id` from the app DB."
  [id]
  (-> (t2/select-one :model/Card :id id)
      api/read-check))

(defn get-metrics-and-models
  "Retrieve the metric and model cards from the collection with name `collection-name` from the app DB."
  [collection-name]
  (let [collection-query {:select [:id]
                          :from :collection
                          :where [:= :name collection-name]}]
    (-> (t2/select :model/Card
                   :type [:in [:metric :model]]
                   :collection_id [:in collection-query]
                   :archived false
                   {:order-by [:id]})
        (->> (filter mi/can-read?)))))

(defn card-query
  "Return a query based on the model with ID `model-id`."
  [card-id]
  (when-let [card (get-card card-id)]
    (let [mp (lib.metadata.jvm/application-database-metadata-provider (:database_id card))]
      (lib/query mp (cond-> (lib.metadata/card mp card-id)
                      ;; pivot questions have strange result-columns so we work with the dataset-query
                      (#{:question} (:type card)) (get :dataset-query))))))

(defn metric-query
  "Return a query based on the model with ID `model-id`."
  [metric-id]
  (when-let [card (get-card metric-id)]
    (let [mp (lib.metadata.jvm/application-database-metadata-provider (:database_id card))]
      (lib/query mp (lib.metadata/metric mp metric-id)))))

(defn table-query
  "Return a query based on the table with ID `table-id`."
  [table-id]
  (when-let [table (get-table table-id :db_id)]
    (let [mp (lib.metadata.jvm/application-database-metadata-provider (:db_id table))]
      (lib/query mp (lib.metadata/table mp table-id)))))

(comment
  (binding [api/*current-user-permissions-set* (delay #{"/"})]
    (let [collection-name "__METABOT__"]
      (map #(dissoc % :result_metadata :creator :collection) (get-metrics-and-models collection-name))))
  -)
