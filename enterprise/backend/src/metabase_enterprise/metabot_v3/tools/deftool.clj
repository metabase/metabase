(ns metabase-enterprise.metabot-v3.tools.deftool
  "Macro for defining metabot tool endpoints with standard encoding/decoding behavior."
  (:require
   [malli.core :as mc]
   [malli.transform :as mtx]
   [metabase-enterprise.metabot-v3.context :as metabot-v3.context]
   [metabase.api.macros :as api.macros]
   [metabase.util.malli.registry :as mr]
   [metabase.util.malli.schema :as ms]))

;;; ---------------------------------------------------- Schemas ----------------------------------------------------

(mr/def ::tool-request
  "Base schema for all tool requests. Contains the conversation ID and optional profile ID."
  [:map
   [:conversation_id ms/UUIDString]
   [:profile_id {:optional true} [:maybe :string]]])

(def request-transformer
  "Transformer for encoding tool request arguments (snake_case -> kebab-case).
   Converts snake_case keys to kebab-case and string enum values to keywords."
  (mtx/transformer {:name :tool-api-request}))

(def ^:private response-transformer
  "Transformer for decoding tool response data (kebab-case -> snake_case)."
  (mtx/transformer {:name :tool-api-response}))

(defn invoke-tool
  "Core tool invocation logic. Handles encoding, calling the handler, decoding, and logging.
  This is the runtime implementation called by endpoints generated by `deftool`.

  Arguments:
  - `body` - The request body containing `:arguments` and `:conversation_id`
  - `request` - The Ring request map (used to extract `:metabot-v3/metabot-id`)
  - `opts` - A map with:
    - `:api-name` - Keyword name for logging (e.g., `:field-values`)
    - `:args-schema` - Malli schema for encoding arguments (optional)
    - `:result-schema` - Malli schema for decoding results (optional)
    - `:handler` - Function to call with encoded arguments (receives args map with :metabot-id)

  The handler receives a single map argument containing the encoded args plus `:metabot-id`
  and `:profile-id` (extracted from the request body)."
  [{:keys [arguments conversation_id profile_id] :as body}
   request
   {:keys [api-name args-schema result-schema handler]}]
  (metabot-v3.context/log (assoc body :api api-name) :llm.log/llm->be)
  (let [metabot-id   (:metabot-v3/metabot-id request)
        encoded-args (cond-> (if args-schema
                               (mc/encode args-schema arguments request-transformer)
                               {})
                       metabot-id (assoc :metabot-id metabot-id)
                       profile_id (assoc :profile-id profile_id))
        raw-result   (handler encoded-args)
        result       (if result-schema
                       (mc/decode result-schema raw-result response-transformer)
                       raw-result)]
    (doto (assoc result :conversation_id conversation_id)
      (metabot-v3.context/log :llm.log/be->llm))))

(defmacro deftool
  "Define a tool endpoint with standard encoding/decoding and logging behavior.

  This macro generates a `defendpoint` with the boilerplate needed for tool endpoints:
  - Logging incoming requests and outgoing responses
  - Encoding arguments from snake_case to kebab-case (via `:tool-api-request` transformer)
  - Decoding results from kebab-case to snake_case (via `:tool-api-response` transformer)
  - Attaching `conversation_id` to responses
  - Extracting `:metabot-id` and `:profile-id` from the request body and including them in the args map

  Options:
    :args-schema    - Malli schema for arguments (optional - omit for no-args tools)
    :args-optional? - If true, arguments are marked as optional in the request body schema
    :result-schema  - Malli schema for result (required for response schema generation)
    :handler        - Function to call. Always receives an args map (may be empty for no-args tools)
                      with `:metabot-id` included when available from the request.

  Example:
    (deftool \"/field-values\"
      \"Return statistics and/or values for a given field.\"
      {:args-schema   ::field-values-arguments
       :result-schema ::field-values-result
       :handler       metabot-v3.tools.field-stats/field-values})"
  [route docstring {:keys [args-schema args-optional? result-schema handler]}]
  (let [api-name        (keyword (subs route 1)) ; "/field-values" -> :field-values
        body-schema     (if args-schema
                          (if args-optional?
                            `[:merge [:map [:arguments {:optional true} ~args-schema]] ::tool-request]
                            `[:merge [:map [:arguments ~args-schema]] ::tool-request])
                          `::tool-request)
        response-schema `[:merge ~result-schema ::tool-request]
        tool-opts       {:api-name      api-name
                         :args-schema   args-schema
                         :result-schema result-schema
                         :handler       handler}]
    `(api.macros/defendpoint :post ~route :- ~response-schema
       ~docstring
       [~'_route-params ~'_query-params ~'body :- ~body-schema ~'request]
       (invoke-tool ~'body ~'request ~tool-opts))))
