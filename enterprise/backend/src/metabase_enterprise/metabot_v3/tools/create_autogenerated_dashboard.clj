(ns metabase-enterprise.metabot-v3.tools.create-autogenerated-dashboard
  "Tool for creating auto-generated dashboards using Metabase's X-ray feature.
  X-ray builds complete dashboards with multiple visualizations that showcase
  different aspects of data - distributions, breakdowns, trends, and relationships."
  (:require
   [clojure.string :as str]
   [metabase.util.log :as log]
   [toucan2.core :as t2]))

(set! *warn-on-reflection* true)

;;; Source Resolution

(defn- resolve-source
  "Resolve the source entity from the provided source parameters.
  Returns the entity to analyze and the path for navigation."
  [{:keys [table_id model_id metric_id query_id report_id]} memory]
  (cond
    table_id
    (let [table (t2/select-one :model/Table :id table_id)]
      (when-not table
        (throw (ex-info (str "Table not found with ID: " table_id)
                        {:agent-error? true :table-id table_id})))
      {:entity table
       :path (str "/auto/dashboard/table/" table_id)})

    model_id
    (let [model (t2/select-one :model/Card :id model_id :type :model)]
      (when-not model
        (throw (ex-info (str "Model not found with ID: " model_id)
                        {:agent-error? true :model-id model_id})))
      {:entity model
       :path (str "/auto/dashboard/model/" model_id)})

    metric_id
    (let [metric (t2/select-one :model/Card :id metric_id :type :metric)]
      (when-not metric
        (throw (ex-info (str "Metric not found with ID: " metric_id)
                        {:agent-error? true :metric-id metric_id})))
      {:entity metric
       :path (str "/auto/dashboard/metric/" metric_id)})

    report_id
    (let [report (t2/select-one :model/Card :id report_id :type :question)]
      (when-not report
        (throw (ex-info (str "Report/Question not found with ID: " report_id)
                        {:agent-error? true :report-id report_id})))
      {:entity report
       :path (str "/auto/dashboard/question/" report_id)})

    query_id
    ;; For query_id, we need to resolve from memory
    (let [queries-state (get-in memory [:state :queries] {})
          query (get queries-state query_id)]
      (when-not query
        (throw (ex-info (str "Query not found in memory with ID: " query_id
                             ". Available queries: [" (str/join ", " (keys queries-state)) "]")
                        {:agent-error? true
                         :query-id query_id
                         :available-queries (keys queries-state)})))
      ;; For queries, we create a transient card-like structure
      {:entity {:dataset_query query}
       :path (str "/auto/dashboard/adhoc/" query_id)})

    :else
    (throw (ex-info "Invalid source: must specify one of table_id, model_id, metric_id, query_id, or report_id"
                    {:agent-error? true}))))

;;; Response Messages

(def ^:private response-messages
  ["Ok, here is a dashboard that may answer it for you."
   "I've created a dashboard that may answer your question."
   "Here is a dashboard that may help you with your question."
   "I've generated a dashboard with insights about your data."])

(defn- random-response-message []
  (rand-nth response-messages))

;;; Main Tool Implementation

(defn create-autogenerated-dashboard
  "Create an auto-generated dashboard using Metabase's X-ray feature.

  X-ray builds complete dashboards with multiple visualizations that showcase
  different aspects of your data - distributions, breakdowns by categories,
  trends over time, and relationships between fields.

  Parameters:
  - source: Map specifying what to analyze. One of:
    - {:table_id 123} - Create dashboard for a table
    - {:model_id 456} - Create dashboard for a model
    - {:metric_id 789} - Create dashboard for a metric
    - {:query_id \"abc\"} - Create dashboard for query results
    - {:report_id 101} - Create dashboard for an existing report/question
  - memory-atom: Atom containing agent memory (for query resolution)

  Returns map with:
  - :structured-output - Message and dashboard info
  - :reactions - Navigation action to show the dashboard
  - :final-response? - Signals that the agent should stop (user is viewing dashboard)"
  [{:keys [source memory-atom]}]
  (log/info "Creating autogenerated dashboard" {:source source})

  (let [memory (when memory-atom @memory-atom)
        {:keys [entity path]} (resolve-source source memory)
        response-message (str (random-response-message) "\n\nLet me know if you need anything else.")]

    ;; Note: The actual automagic analysis happens on navigation to the /auto/dashboard/... URL
    ;; The frontend handles rendering the X-ray dashboard

    (log/info "Autogenerated dashboard created" {:path path})

    {:structured-output {:message response-message
                         :path path}
     :reactions [{:type :metabot.reaction/redirect :url path}]
     :final-response? true
     :instructions "The dashboard has been created and the user has been navigated to view it. Do not describe the dashboard contents."}))
