(ns metabase-enterprise.metabot-v3.tools.util
  (:require
   [clojure.string :as str]
   [medley.core :as m]
   [metabase.api.common :as api]
   [metabase.collections.models.collection :as collection]
   [metabase.lib-be.metadata.jvm :as lib.metadata.jvm]
   [metabase.lib.core :as lib]
   [metabase.lib.metadata :as lib.metadata]
   [metabase.lib.types.isa :as lib.types.isa]
   [metabase.lib.util :as lib.util]
   [metabase.premium-features.core :as premium-features]
   [metabase.util :as u]
   [toucan2.core :as t2]))

(defn handle-agent-error
  "Return an agent output for agent errors, re-throw `e` otherwise."
  [e]
  (if (-> e ex-data :agent-error?)
    {:output (ex-message e)}
    (throw e)))

(defn convert-field-type
  "Return tool type for `column`."
  [column]
  (let [column (u/normalize-map column)]
    (cond
      (lib.types.isa/boolean? column)                :boolean
      (lib.types.isa/string-or-string-like? column)  :string
      (lib.types.isa/numeric? column)                :number
      (isa? (:effective-type column) :type/DateTime) :datetime
      (isa? (:effective-type column) :type/Time)     :time
      (lib.types.isa/temporal? column)               :date)))

(defn add-table-reference
  "Add table-reference to columns that have FK relationships."
  [query col]
  (cond-> col
    (and (:fk-field-id col)
         (:table-id col))
    (assoc :table-reference (-> (lib/display-name query (lib.metadata/field query (:fk-field-id col)))
                                lib.util/strip-id))))

(defn table-field-id-prefix
  "Return the field ID prefix for `table-id`."
  [table-id]
  (str "t" table-id "/"))

(defn card-field-id-prefix
  "Return the field ID prefix for a model or a metric with ID `card-id`."
  [card-id]
  (str "c" card-id "/"))

(defn query-field-id-prefix
  "Return the field ID prefix for `query-id`."
  [query-id]
  (str "q" query-id "/"))

(def any-prefix-pattern
  "A prefix pattern accepting columns from any entity."
  #"^.*/(\d+)")

(defn ->result-column
  "Return tool result columns for `column` of `query`. The position of `column` is determined by `index`.
  The ID is then generated by prefixing the position with `field-id-prefix`."
  [query column index field-id-prefix]
  (let [semantic-type (some-> (:semantic-type column) name u/->snake_case_en)]
    (-> {:field-id (str field-id-prefix index)
         :name (:name column)
         :display_name (lib/display-name query column)
         :type (convert-field-type column)}
        (m/assoc-some :description (:description column)
                      :semantic-type semantic-type
                      :field-values (:field-values column)
                      :table-reference (:table-reference column)))))

(defn resolve-column-index
  "Resolve the reference `field_id` to the index of the result columns in the entity with `field-id-prefix`."
  [field-id field-id-prefix]
  (if (string? field-id-prefix)
    (if (str/starts-with? field-id field-id-prefix)
      (-> field-id (subs (count field-id-prefix)) parse-long)
      (throw (ex-info (str "field " field-id " not found") {:agent-error? true
                                                            :expected-prefix field-id-prefix})))
    (if-let [id-str (when (instance? java.util.regex.Pattern field-id-prefix)
                      (-> (re-matches field-id-prefix field-id)
                          second))]
      (parse-long id-str)
      (throw (ex-info (str "invalid field_id " field-id " for prefix " field-id-prefix)
                      {:agent-error? true
                       :expected-prefix (str field-id-prefix)
                       :field-id field-id})))))

(defn resolve-column
  "Resolve the reference `field-id` in filter `item` by finding the column in `columns` specified by `field-id`.
  `field-id-prefix` is used to check if the filter refers to a column from the right entity."
  [{:keys [field-id] :as item} field-id-prefix columns]
  (let [index (resolve-column-index field-id field-id-prefix)]
    (assoc item :column (nth columns index))))

(defn get-table
  "Get the `fields` of the table with ID `id`."
  [id & fields]
  (-> (t2/select-one (into [:model/Table :id] fields) id)
      api/read-check))

(defn get-card
  "Retrieve the card with `id` from the app DB."
  [id]
  (-> (t2/select-one :model/Card :id id)
      api/read-check))

(defn card-query
  "Return a query based on the model with ID `model-id`."
  [card-id]
  (when-let [card (get-card card-id)]
    (let [mp (lib.metadata.jvm/application-database-metadata-provider (:database_id card))]
      (lib/query mp (cond-> (lib.metadata/card mp card-id)
                      ;; pivot questions have strange result-columns so we work with the dataset-query
                      (#{:question} (:type card)) (get :dataset-query))))))

(defn metric-query
  "Return a query based on the model with ID `model-id`."
  [metric-id]
  (when-let [card (get-card metric-id)]
    (let [mp (lib.metadata.jvm/application-database-metadata-provider (:database_id card))]
      (lib/query mp (lib.metadata/metric mp metric-id)))))

(defn table-query
  "Return a query based on the table with ID `table-id`."
  [table-id]
  (when-let [table (get-table table-id :db_id)]
    (let [mp (lib.metadata.jvm/application-database-metadata-provider (:db_id table))]
      (lib/query mp (lib.metadata/table mp table-id)))))

(defn metabot-metrics-and-models-query
  "Return the metric and model cards in metabot scope visible to the current user.

  Takes a metabot-id and returns all metric and model cards in that metabot's collection
  and its subcollections. If the metabot has use_verified_content enabled, only verified
  content is returned."
  [metabot-id]
  (let [metabot (t2/select-one :model/Metabot :id metabot-id)
        metabot-collection-id (:collection_id metabot)
        use-verified-content? (:use_verified_content metabot)
        collection-filter (if metabot-collection-id
                            (let [collection (t2/select-one :model/Collection :id metabot-collection-id)
                                  collection-ids (conj (collection/descendant-ids collection) metabot-collection-id)]
                              [:in :collection_id collection-ids])
                            [:and true])
        base-query {:select [:report_card.*]
                    :from   [[:report_card]]
                    :where  [:and
                             collection-filter
                             [:in :type [:inline ["metric" "model"]]]
                             [:= :archived false]
                             (collection/visible-collection-filter-clause :collection_id)]}]
    (if (and use-verified-content? (premium-features/has-feature? :content-verification))
      (-> base-query
          (assoc :left-join [[:moderation_review :mr] [:and
                                                       [:= :mr.moderated_item_id :report_card.id]
                                                       [:= :mr.moderated_item_type [:inline "card"]]
                                                       [:= :mr.most_recent true]]])
          (update :where conj [:= :mr.status [:inline "verified"]]))
      base-query)))

(comment
  (binding [api/*current-user-id* 2
            api/*is-superuser?* true]
    (t2/select-fn-vec #(select-keys % [:id :name :type])
                      :model/Card
                      (metabot-metrics-and-models-query 1)))
  -)

(defn get-metrics-and-models
  "Retrieve the metric and model cards for the Metabot instance with ID `metabot-id` from the app DB.

  Only cards visible to the current user are returned."
  [metabot-id]
  (t2/select :model/Card (-> (metabot-metrics-and-models-query metabot-id)
                             (assoc :order-by [:id]))))
